<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meijuna</title>
  
  <subtitle>没有比脚更长的路，走过去，前面是个天！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-17T13:55:50.450Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>MeiJuna</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>npm 包管理工具</title>
    <link href="http://yoursite.com/2019/06/17/npm%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/06/17/npm包管理工具/</id>
    <published>2019-06-17T13:50:35.677Z</published>
    <updated>2019-06-17T13:55:50.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="npm-包管理工具"><a href="#npm-包管理工具" class="headerlink" title="npm 包管理工具"></a>npm 包管理工具</h1><h2 id="1-什么是-npm"><a href="#1-什么是-npm" class="headerlink" title="1. 什么是 npm ?"></a>1. 什么是 npm ?</h2><ul><li>npm是 Node 的包管理工具 ，是全球最大的开源库生态系统</li><li>官网 <a href="https://www.npmjs.com/" target="_blank" rel="noopener">https://www.npmjs.com/</a></li></ul><h2 id="2-常见命令"><a href="#2-常见命令" class="headerlink" title="2. 常见命令"></a>2. 常见命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">初始化项目</span><br><span class="line">    $ npm init</span><br><span class="line">    $ npm init --yes 默认配置</span><br><span class="line"> </span><br><span class="line">下载命令:</span><br><span class="line">    npm init 初始化包管理文件</span><br><span class="line">    npm install 包名  下载</span><br><span class="line">    npm install 包名 -g 下载到全局</span><br><span class="line">    npm install 包名 --save-dev--    包管理文件生成开发依赖 devDependencies:&#123;xxx:xxx&#125;</span><br><span class="line">    npm install 包名 -d    --save-dev--的简写</span><br><span class="line">    npm config ls 查看npm的默认配置</span><br><span class="line">    </span><br><span class="line">    //开发环境使用 devDepencies</span><br><span class="line">    -D  === --save--dev  </span><br><span class="line">    // 生产环境使用  </span><br><span class="line">    -S  ==  --save</span><br><span class="line">   </span><br><span class="line">卸载命令:</span><br><span class="line">    npm uninstall 包名卸载本地包</span><br><span class="line">    npm unpublish 包名@版本号  卸载发布后的远程包 发布1小时内有效</span><br></pre></td></tr></table></figure><h2 id="3-上传包"><a href="#3-上传包" class="headerlink" title="3. 上传包"></a>3. 上传包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">上传包:</span><br><span class="line">    1) 登入npm官方网站 www.npmjs.com</span><br><span class="line">    2) 注册 设置好邮箱</span><br><span class="line">    3) 在dos命令窗口登入npm adduser (注意密码输入不显示)</span><br><span class="line">    4) 发布包 npm publish</span><br><span class="line">    5) package.json中必备两个字段 name(包名) version(版本号)</span><br><span class="line">    ps:如果发布的包名与npm官网重复会导致发布失败</span><br></pre></td></tr></table></figure><h2 id="2-设置淘宝镜像"><a href="#2-设置淘宝镜像" class="headerlink" title="2.  设置淘宝镜像"></a>2.  设置淘宝镜像</h2>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//1. 安装 cnpm 设置淘宝镜像</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">//2. 下载 nrm 用于切换源</span><br><span class="line">  cnpm install nrm -g </span><br><span class="line">  nrm ls 查看当前源</span><br><span class="line">  nrm use xx 切换源</span><br></pre></td></tr></table></figure><h2 id="3-npm脚本"><a href="#3-npm脚本" class="headerlink" title="3. npm脚本"></a>3. npm脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">npm run build = node build.js </span><br><span class="line">为什么使用npm 脚本： 命令会记录在build</span><br><span class="line">1. 集中存放当前项目的所有脚本命令</span><br><span class="line">2. 外接口，用户不同项目的脚本命令，只要功能相同，就可以是同样的</span><br><span class="line">3. 提供很多辅助功能（多个脚本执行(&amp;|$$) 通配符 *.js </span><br><span class="line"></span><br><span class="line">以下npm 脚本可以简写</span><br><span class="line">    npm start </span><br><span class="line">    np stop</span><br><span class="line">    npm test</span><br><span class="line">    npm restart </span><br><span class="line">    </span><br><span class="line">默认提供脚本：</span><br><span class="line">1. &quot;start&quot;: &quot;node server.js&quot;</span><br><span class="line">2. &quot;install&quot;: &quot;node-gyp rebuild&quot;</span><br><span class="line">3. &quot;build&quot;: &quot;node build.js&quot;</span><br><span class="line"></span><br><span class="line">钩子： pre和pst两个钩子</span><br></pre></td></tr></table></figure><h2 id="4-nvm-node版本管理"><a href="#4-nvm-node版本管理" class="headerlink" title="4.  nvm node版本管理"></a>4.  nvm node版本管理</h2><p>下载安装 nvm  <a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">nvm-setup.zip</a> </p><ul><li><p>nvm 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nvm list #查看本地所有node版本</span><br><span class="line"></span><br><span class="line">nvm install 4.2.2 #安装 4.2.2 版本</span><br><span class="line"></span><br><span class="line">nvm use 4.2.2 #切换至 4.2.2 版本</span><br><span class="line"></span><br><span class="line">nvm uninstall 4.2.2 #卸载4.2.2 版本</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;npm-包管理工具&quot;&gt;&lt;a href=&quot;#npm-包管理工具&quot; class=&quot;headerlink&quot; title=&quot;npm 包管理工具&quot;&gt;&lt;/a&gt;npm 包管理工具&lt;/h1&gt;&lt;h2 id=&quot;1-什么是-npm&quot;&gt;&lt;a href=&quot;#1-什么是-npm&quot; class
      
    
    </summary>
    
      <category term="npm" scheme="http://yoursite.com/categories/npm/"/>
    
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB</title>
    <link href="http://yoursite.com/2019/06/17/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2019/06/17/mongodb数据库/</id>
    <published>2019-06-17T13:50:31.688Z</published>
    <updated>2019-06-17T13:52:50.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">show dbs      查看数据库</span><br><span class="line">use dbname    创建数据库 如果不存在创建数据库，否则切换到数据库</span><br><span class="line">show collections 显示数据库集合</span><br><span class="line"></span><br><span class="line">1.添加数据</span><br><span class="line"></span><br><span class="line">db.web.save(&#123;&quot;name&quot;: &quot;meiejuna&quot;&#125;)  创建了名称为 web 的名称，名</span><br><span class="line">db.web.insert(&#123;&quot;name&quot;: &quot;meijuna&quot;&#125;)  </span><br><span class="line">插入相同的数据，sava 覆盖，insert 报错</span><br><span class="line"></span><br><span class="line">2.删除数据</span><br><span class="line">      </span><br><span class="line">   db.students.remove( &#123;&#125; )      删除 students 集合下的所有数据</span><br><span class="line">   db.students.remove(&#123;&quot;name&quot;: &quot;meijuna&quot; &#125;) 删除 students 集合为 name 为 meijuna 的数据</span><br><span class="line">   db.students.drop() or db.runCommand(&#123;&quot;&quot;&#125;)删除 students 集合</span><br><span class="line">   db.runCommand( &#123; dropDaatabase: 1 &#125; )    删除当前数据库</span><br><span class="line">   </span><br><span class="line">3.修改数据</span><br><span class="line"></span><br><span class="line">db.students.updata(&#123;&quot;name&quot;: &quot;meijuna&quot;&#125;,set:&#123;&quot;sex&quot;:&quot;women&quot;&#125;)                单行修改</span><br><span class="line">db.students.updata(&#123;&quot;name&quot;: &quot;meijuna&quot;&#125;,&#123;$set:&#123;&quot;sex&quot;:&quot;women&quot;&#125;&#125;, true, true) 多行修改</span><br><span class="line">     //&#123;查找条件&#125; , &#123; 修改内容 &#125;      匹配所有条件数据 修改所有匹配项</span><br><span class="line"></span><br><span class="line">4.查找数据</span><br><span class="line">  db.students.find()          查找 students 集合中的 所有    数据</span><br><span class="line">  db.students.findONe()       查找 students 集合中的 第一条  数据</span><br><span class="line">  db.students.find().pretty() 可视化查询 </span><br><span class="line">  </span><br><span class="line">5.排序 </span><br><span class="line">db.students.find().sort(&#123;&quot;age&quot;: 1&#125;) 1 升 -1 降序</span><br><span class="line"></span><br><span class="line">6.截取</span><br><span class="line">db.students.find().skip(2)  下标为 2 开始截取</span><br><span class="line">db.students.find().limit(2)   截取 2 条数据</span><br><span class="line"></span><br><span class="line">7.筛选显示</span><br><span class="line">db.students.find(&#123;age:20&#125;,&#123;_id:0,age:1,name:1&#125;)</span><br><span class="line">        0,筛选的结果不显示，1筛选结果显示</span><br></pre></td></tr></table></figure><h2 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h2><ul><li><p>关系型数据库 以行和列的形式存储数据，以便于用户理解。这一系列的行和列被称为表，一组表组成了数据库。表与表之间的数据记录有关系。</p></li><li><p><strong>关系型</strong>数据库有：<strong>mySql</strong> <strong>oracle</strong>   <strong>SqlServer</strong>  <strong>Access</strong>  <strong>db2 </strong> 等</p></li></ul><h2 id="NoSQL简介"><a href="#NoSQL简介" class="headerlink" title="NoSQL简介"></a>NoSQL简介</h2><ul><li>NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。</li><li>NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</li><li><strong>非关系型</strong>数据库: <strong>MongoDB</strong>，<strong>Redis</strong>，<strong>HBase</strong>，<strong>CouchDB </strong> 等</li></ul><h2 id="非关系型数据库与关系型数据库区别"><a href="#非关系型数据库与关系型数据库区别" class="headerlink" title="非关系型数据库与关系型数据库区别"></a>非关系型数据库与关系型数据库区别</h2><h3 id="关系型数据库的优势："><a href="#关系型数据库的优势：" class="headerlink" title="关系型数据库的优势："></a>关系型数据库的优势：</h3><h4 id="1-复杂查询"><a href="#1-复杂查询" class="headerlink" title="1. 复杂查询"></a>1. 复杂查询</h4><ul><li>可以用SQL语句方便的在多个表之间做非常复杂的数据查询。 </li></ul><h4 id="2-事务支持"><a href="#2-事务支持" class="headerlink" title="2. 事务支持"></a>2. 事务支持</h4><ul><li>使得对于安全性能很高的数据访问要求得以实现。</li></ul><h3 id="非关系型数据库的优势："><a href="#非关系型数据库的优势：" class="headerlink" title="非关系型数据库的优势："></a>非关系型数据库的优势：</h3><h4 id="1-性能"><a href="#1-性能" class="headerlink" title="1. 性能"></a>1. 性能</h4><ul><li>NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li></ul><h4 id="2-可扩展性"><a href="#2-可扩展性" class="headerlink" title="2. 可扩展性"></a>2. 可扩展性</h4><ul><li>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li></ul><h2 id="MongoDB优点"><a href="#MongoDB优点" class="headerlink" title="MongoDB优点"></a>MongoDB优点</h2><p>它的特点是高性能、易部署、易使用，存储数据非常方便。</p><p>主要功能特性有：</p><ul><li><p>面向集合存储，易存储对象类型的数据。</p></li><li><p>模式自由。</p></li><li><p>支持动态查询。</p></li><li><p>支持完全索引，包含内部对象。</p></li><li><p>支持查询。</p></li><li><p>支持复制和故障恢复。</p></li><li><p>使用高效的二进制数据存储，包括大型对象（如视频等）。</p></li><li><p>自动处理碎片，以支持云计算层次的扩展性</p></li><li><p>支持RUBY，PYTHON，JAVA，C++，PHP等多种语言。</p></li><li><p>文件存储格式为BSON（一种JSON的扩展）</p></li></ul><p>#### </p><h2 id="BSON-存储格式"><a href="#BSON-存储格式" class="headerlink" title="BSON 存储格式"></a>BSON 存储格式</h2><p>BSON是一种类似<a href="http://baike.baidu.com/view/136475.htm" target="_blank" rel="noopener">json</a>的二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的<strong>文档对象</strong>和<strong>数组对象</strong>，但是<strong>BSON</strong>有JSON没有的一些数据类型，**如Date和BinData类型。</p><p>BSON有三个特点：<strong>轻量性</strong>、<strong>可遍历性</strong>、<strong>高效性</strong>。 </p><p>非关系型数据库文件存储格式为 <strong>BSON</strong>（一种JSON的扩展）。</p><h2 id="MongoDB下载与安装"><a href="#MongoDB下载与安装" class="headerlink" title="MongoDB下载与安装"></a>MongoDB下载与安装</h2><h3 id="1-MongoDB下载："><a href="#1-MongoDB下载：" class="headerlink" title="1. MongoDB下载："></a>1. MongoDB下载：</h3><p><a href="https://www.mongodb.com/download-center#community" target="_blank" rel="noopener">https://www.mongodb.com/download-center#community</a>&gt;</p><h3 id="2-设置环境变量"><a href="#2-设置环境变量" class="headerlink" title="2. 设置环境变量"></a>2. 设置环境变量</h3><p>在环境变量窗口中一般有两个变量，一个是你当前所使用的用户独有的环境变量，另一个是所有用户都可以访问的系统变量。其实如果在你的电脑上你只使用一个用户的话，那么不管你修改的用户的环境变量还是系统变量，效果都是一样的。为了以防未来会新建其他用户，那么我建议你修改系统变量而不是某个用户独有的环境变量。</p><h3 id="3-测试连接"><a href="#3-测试连接" class="headerlink" title="3. 测试连接"></a>3. 测试连接</h3><ul><li>管理员身份运行 cmd 输入 <code>mongo</code></li><li>启动 mongdb 服务 <code>net start mongdb</code></li><li>关闭 mongdb 服务 <code>net stop MongoDB</code></li></ul><h3 id="4-安装可视化工具-Robo-3T"><a href="#4-安装可视化工具-Robo-3T" class="headerlink" title="4. 安装可视化工具(Robo 3T)"></a>4. 安装可视化工具(Robo 3T)</h3><p><a href="https://robomongo.org/download" target="_blank" rel="noopener">https://robomongo.org/download</a></p><p>node 使用 MongoDB</p><p>连接 MongoDB</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 下载 mongoose </span></span><br><span class="line">cnpm i mongoose -D </span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 引入 mongoose </span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>( <span class="string">'mongoose'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 连接 mongoose </span></span><br><span class="line"><span class="comment">// 连接本地mongodb ，本机的ip 127.0.0.1，端口：27017 数据库：student</span></span><br><span class="line">mongoose.connect(<span class="string">"mongodb://127.0.0.1:27017/student"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!err)&#123; </span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"connected to Mongodb"</span>); <span class="comment">//连接成功</span></span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">throw</span> err;<span class="comment">//如果连接失败，则抛出异常</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>存储数据</p><p>Schema不仅<strong>定义了文档结构和使用性能</strong>，还可以有扩展插件、实例方法、静态方法、复合索引、文档生命周期钩子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schema  ：   一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力</span><br><span class="line"></span><br><span class="line">Model   ：   由Schema发布生成的模型，具有抽象属性和行为的数据库操作对</span><br><span class="line"></span><br><span class="line">Entity  ：   由Model创建的实体，他的操作也会影响数据库</span><br></pre></td></tr></table></figure><p>存储数据步骤：定义Schema (骨架) &gt; 创建model（模型）&gt;  Entity实例化方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>( <span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"></span><br><span class="line">mongoose.connect( <span class="string">'mongodb://127.0.0.1:27017/meijuna'</span>,(error) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> ( error ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> error</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'database is connected~'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123;  <span class="comment">//定义数据模型</span></span><br><span class="line">  username: <span class="built_in">String</span>,</span><br><span class="line">  password: <span class="built_in">String</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过模式studentSchema  创建一个模型studentModel </span></span><br><span class="line"><span class="keyword">var</span> studentModel = mongoose.model(<span class="string">"students"</span>,studentSchema );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> studentModel (); </span><br><span class="line">instance1.name=<span class="string">"tangyan"</span>;</span><br><span class="line">instance1.age=<span class="string">"18"</span>;</span><br><span class="line"></span><br><span class="line">instance1.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;   <span class="comment">//通过save方法保存</span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'保存失败'</span>);  </span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>查询数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 查</span><br><span class="line">userModel.find(&#123;&#125;, ( error, result ) =&gt; &#123;</span><br><span class="line"> if ( error ) throw error </span><br><span class="line">console.log ( result )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>修改数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">userModel.find(&#123; <span class="attr">username</span>: <span class="string">'aaa'</span>&#125;, ( error, result) =&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> _id = result[<span class="number">0</span>]._id</span><br><span class="line"></span><br><span class="line">  userModel.findById(_id, ( error, doc ) =&gt; &#123;    <span class="comment">// 修改</span></span><br><span class="line">    <span class="keyword">if</span> (error ) <span class="keyword">throw</span> error</span><br><span class="line">    <span class="built_in">console</span>.log( doc );</span><br><span class="line">    doc.username = <span class="string">"meijuna"</span>;</span><br><span class="line">    doc.save ( <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> error</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"数据修改成功"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>删除数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">userModel.find(&#123; <span class="attr">username</span>: <span class="string">'aaa'</span>&#125;, ( error, result) =&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error</span><br><span class="line">  <span class="keyword">const</span> _id = result[<span class="number">0</span>]._id</span><br><span class="line"></span><br><span class="line">  userModel.findById(_id, ( error, doc ) =&gt; &#123;    <span class="comment">// 删除</span></span><br><span class="line">    <span class="keyword">if</span> (error ) <span class="keyword">throw</span> error</span><br><span class="line"></span><br><span class="line">    doc.remove( <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) <span class="keyword">throw</span> error</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'数据删除成功！'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注册</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"></span><br><span class="line">mongoose.connect(<span class="string">'mongodb://127.0.0.1:27017/meijuna'</span>, (error) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="keyword">throw</span> error</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'database is connected !!!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123; <span class="comment">//定义数据模型</span></span><br><span class="line">  username: <span class="built_in">String</span>,</span><br><span class="line">  password: <span class="built_in">String</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> userModel = mongoose.model(<span class="string">'users'</span>, userSchema) <span class="comment">//模型创建</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> userModel(); <span class="comment">//创建实体</span></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username,  password &#125; = req.query;</span><br><span class="line">  <span class="built_in">console</span>.log(username,password);</span><br><span class="line">   userModel.find(&#123;&#125;, (error, result) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> flag = result.some(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item.username === username</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123; <span class="comment">//用户名存在</span></span><br><span class="line">      res.render(<span class="string">'register'</span>, &#123;</span><br><span class="line">        data: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">          ret: <span class="literal">true</span>, <span class="comment">//身份验证 权限验证</span></span><br><span class="line">          status: <span class="number">2</span> <span class="comment">//0 表示失败 1：成功  2：</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      user.username = username;</span><br><span class="line">      user.password = password;</span><br><span class="line">      user.save();</span><br><span class="line"></span><br><span class="line">      res.render(<span class="string">'register'</span>, &#123;</span><br><span class="line">        data: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">          ret : <span class="literal">true</span>,</span><br><span class="line">          status: <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MongoDB&quot;&gt;&lt;a href=&quot;#MongoDB&quot; class=&quot;headerlink&quot; title=&quot;MongoDB&quot;&gt;&lt;/a&gt;MongoDB&lt;/h1&gt;&lt;p&gt;MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
      <category term="mongoDB" scheme="http://yoursite.com/tags/mongoDB/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>express Node 核心框架</title>
    <link href="http://yoursite.com/2019/06/17/express%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2019/06/17/express框架/</id>
    <published>2019-06-17T13:50:29.972Z</published>
    <updated>2019-06-17T14:13:38.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="express-Node-核心框架"><a href="#express-Node-核心框架" class="headerlink" title="express Node 核心框架"></a>express Node 核心框架</h1><p>express是一个功能极简, 完全是由路由和中间件构成的一个web开发框架,是非侵入式的框架</p><h2 id="1-为什么要学习-express"><a href="#1-为什么要学习-express" class="headerlink" title="1. 为什么要学习 express ?"></a>1. 为什么要学习 express ?</h2><pre><code>- express 是 Node 的核心框架- express 可以帮助我们快速构建 web 服务器 / api 服务器- express 提供了一个快速生成工具 express-generator   - 快速生成工具： 帮助我们快速创建一个项目的工具</code></pre><h2 id="2-安装方式"><a href="#2-安装方式" class="headerlink" title="2. 安装方式"></a>2. 安装方式</h2><h3 id="1-全局安装"><a href="#1-全局安装" class="headerlink" title="1. 全局安装"></a>1. 全局安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm i express-generator -g  </span><br><span class="line">or </span><br><span class="line"><span class="meta">$</span> yarn add express-generator -g</span><br></pre></td></tr></table></figure><h3 id="2-npx-安装"><a href="#2-npx-安装" class="headerlink" title="2. npx 安装"></a>2. npx 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(如果npm版本在 5.2+，那可以不用全局，用npx)</span><br><span class="line"></span><br><span class="line">$ npx express -e express_demo</span><br><span class="line"></span><br><span class="line">-e : 指的是我们使用一个叫 ejs 的模板（ejs.js 可以兼容html标签, 可以在标签中写 js ）</span><br></pre></td></tr></table></figure><h2 id="3-项目目录"><a href="#3-项目目录" class="headerlink" title="3. 项目目录"></a>3. 项目目录</h2><ul><li><p>bin </p><ul><li>www 启动了一个静态服务器 （ web服务器 ）</li></ul></li><li><p>node_modules 这个项目的依赖包</p></li><li><p>public 静态资源文件 ( html，css，images)</p></li><li><p>routes 路由文件夹</p></li><li><p>view</p><ul><li>xxx.ejs （ 项目模板 )</li></ul></li></ul><ul><li>app.js  ( 这个项目的入口文件 )</li></ul><h2 id="4-app-js-文件代码解读"><a href="#4-app-js-文件代码解读" class="headerlink" title="4. app.js 文件代码解读"></a>4. app.js 文件代码解读</h2><pre><code>- app对象的功能  1.  通过app.use来使用具有特定功能的函数 ( 又叫中间件 )- 中间件分类  1.  应用中间件 （ cors )  2.  路由中间件 app.get( &apos;/&apos; , (req, res, next ) =&gt; { } )   3.  错误处理中间件 function( err, req, res, next ) { }</code></pre><h2 id="5-express-创建-api-服务器-（-创建接口-）"><a href="#5-express-创建-api-服务器-（-创建接口-）" class="headerlink" title="5. express 创建 api 服务器 （ 创建接口 ）"></a>5. express 创建 api 服务器 （ 创建接口 ）</h2><ul><li>api  服务器是给前端提供接口数据</li><li>api 服务器需要使用的给测试工具来测试，不能用浏览器展示</li><li>注意： 后端个前端发送的数据类型是 JSON 字符串，前端需要 JSON.parse() 转换成对象</li></ul><h2 id="6-restful-api-规则"><a href="#6-restful-api-规则" class="headerlink" title="6. restful api 规则"></a>6. restful api 规则</h2><p>​    restful aip 规则 是一个暴露接口的规则 ，实现是一个接口使用不同的数据请求方式来实现不同的功能</p><h2 id="7-数据请求格式"><a href="#7-数据请求格式" class="headerlink" title="7. 数据请求格式"></a>7. 数据请求格式</h2><h3 id="1-get"><a href="#1-get" class="headerlink" title="1. get"></a>1. get</h3><ul><li>发送数据时，携带的参数时，形式是 Query string Parameters</li><li><p>后端 req.query 获取前端传来的数据</p><h3 id="2-post"><a href="#2-post" class="headerlink" title="2. post"></a>2. post</h3></li><li><p>发送数据时，携带的参数时，形式是 Form Data</p></li><li>前端 req.body 获取前端传来的数据</li></ul><h2 id="8-ecj-模板"><a href="#8-ecj-模板" class="headerlink" title="8. ecj 模板"></a>8. ecj 模板</h2><p><a href="https://ejs.bootcss.com/" target="_blank" rel="noopener">ecj 官网</a></p><p>EJS 是一套简单的模板语言，帮你利用 JavaScript 代码生成 HTML 页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ejs模板语法:</span><br><span class="line"></span><br><span class="line">    &lt;% jsCode %&gt;执行正常js代码</span><br><span class="line">    &lt;% =data %&gt;转移输出</span><br><span class="line">    &lt;% -&quot;data&quot; %&gt;非转义输出</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;express-Node-核心框架&quot;&gt;&lt;a href=&quot;#express-Node-核心框架&quot; class=&quot;headerlink&quot; title=&quot;express Node 核心框架&quot;&gt;&lt;/a&gt;express Node 核心框架&lt;/h1&gt;&lt;p&gt;express是一个
      
    
    </summary>
    
      <category term="express" scheme="http://yoursite.com/categories/express/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Node 基础语法</title>
    <link href="http://yoursite.com/2019/06/17/Node%E5%9F%BA%E7%A1%80%E8%A6%81%E7%82%B9/"/>
    <id>http://yoursite.com/2019/06/17/Node基础要点/</id>
    <published>2019-06-17T13:50:27.400Z</published>
    <updated>2019-06-17T13:54:31.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-基础语法"><a href="#Node-基础语法" class="headerlink" title="Node 基础语法"></a>Node 基础语法</h1><ul><li><p>浏览器Javascript 不能做什么？</p><ol><li>访问数据库</li><li>不能对文件进行操作</li><li>不能对系统进行操作</li></ol><p>原因是为了安全，和浏览器的运行机制有关</p></li><li><p>在开发人员能力相同的情况下编程语言的能力取决于什么？</p><p>取决于平台，</p><ul><li>cordova hbuilder    平台  platform</li><li>java   java虚拟机        （运行平台）</li><li>php    php虚拟机</li><li>+c#     .net framework   mono</li><li>+js     解析内核  chrome v8 </li></ul></li></ul><h2 id="1-node-特点"><a href="#1-node-特点" class="headerlink" title="1.  node 特点"></a>1.  node 特点</h2><h3 id="什么是node"><a href="#什么是node" class="headerlink" title="什么是node ?"></a>什么是node ?</h3><ul><li><p>Node.js 是一个运行在Chrome V8 引擎的JavaScript 的一个运行环境 </p></li><li><p>Node.js使用了一个事件驱动、非阻塞式I/O的模型,使其轻量又高效</p><ul><li><p>事件驱动： 任务执行，发布者，订阅者，事件驱动 （  on  emit  ）</p></li><li><p>非阻塞： 执行某一个任务的同时也可以执行其他任务</p></li><li><p>阻塞： 执行某一个任务，这个任务如果没有执行完成，其他任务必须等待</p><ul><li>同步</li><li>异步</li></ul></li><li><p>I/O: 输入/输出（ 数据库，文件系统操作等操作  ）</p><ul><li>非阻塞I/O模型： 当我们使用Node.js来实现数据库操作、文件系统等操作时，要进行的异步操作，异步操作的核心传统实现方式就是回调函数</li></ul></li></ul></li></ul><h2 id="2-服务器："><a href="#2-服务器：" class="headerlink" title="2. 服务器："></a>2. 服务器：</h2><ul><li><p>定义： 可以运行在服务端的一个网站（站点）</p></li><li><p>种类：</p><ol><li><p>web服务器（ 静态服务器 ），可以运行在浏览器中的服务器</p></li><li><p>api 服务器（ 后端接口 )，后端语言暴露一个数据接口，用于前端的请求</p></li></ol></li></ul><h4 id="1-http-创建web服务器："><a href="#1-http-创建web服务器：" class="headerlink" title="1. http 创建web服务器："></a>1. http 创建web服务器：</h4><ul><li><p>http 模块</p><ul><li>createServer( callback(request, response, [next]){ })</li><li>listen(port, host, callback)  //监听服务器 （ 反馈服务器状态）</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">// 1. 引入http模块(对象)</span></span><br><span class="line"> <span class="keyword">const</span> http = reqiure(<span class="string">'http'</span>);</span><br><span class="line"> <span class="comment">//2. 通过httpP模块上的 createServer 这个api 创建一个函数</span></span><br><span class="line"> <span class="comment">//3. 创建服务器端口和域名</span></span><br><span class="line"> <span class="keyword">const</span> port = <span class="number">8888</span>;</span><br><span class="line"> <span class="keyword">const</span> host = <span class="string">'localhost'</span>;<span class="comment">//127.0.0.1</span></span><br><span class="line"> <span class="keyword">const</span> server = http.createServer( <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">     response.writeHead(<span class="number">200</span>, &#123;   <span class="comment">//设置响应头</span></span><br><span class="line">         <span class="string">'Content-Type'</span>: <span class="string">'text/html;charset=UTFf8'</span></span><br><span class="line"> &#125;)</span><br><span class="line"> response.write(<span class="string">'返回给客户端的数据'</span>);<span class="comment">//向前台发送信息</span></span><br><span class="line">     response.end(); <span class="comment">//发送已经结束</span></span><br><span class="line"> &#125;).listen( port, host, () =&gt; &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">`The server running at:http://<span class="subst">$&#123; host &#125;</span> : <span class="subst">$&#123; port &#125;</span> `</span>)</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line">ps:因为浏览器在请求时会默认发送favicon.ico图标请求,如需阻止在http回调函数里环境里判断阻止</span><br><span class="line">代码示例:</span><br><span class="line">    <span class="keyword">if</span>(request.url.indexOf(<span class="string">"favicon.ico"</span>) === <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">ps:关于设置响应头解析类型的设置</span><br><span class="line">    <span class="string">"Content-type"</span>:<span class="string">"text/html;charset=utf-8"</span>解析HTML标签以及属性</span><br><span class="line">                    <span class="string">"text/plain"</span>纯文本</span><br><span class="line">                    <span class="string">"text/css"</span>解析css</span><br><span class="line">                    <span class="string">"text/javascript"</span>解析js</span><br><span class="line">                    <span class="string">"text/png"</span>解析图片</span><br><span class="line">                    <span class="string">"text/json"</span>json数据</span><br><span class="line">                    <span class="string">"......"</span></span><br></pre></td></tr></table></figure><h4 id="2-express-来创建api服务器"><a href="#2-express-来创建api服务器" class="headerlink" title="2. express 来创建api服务器"></a>2. express 来创建api服务器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(路由路径，(路由回调函数(路由中间件),next) =&gt; &#123; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express() <span class="comment">//创建了一个app对象</span></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res, next)  =&gt; &#123;&#125;)</span><br><span class="line">app.listen(port, hostname, () =&gt; &#123;  <span class="comment">//创建一个服务器</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`The server is runinng at:http://<span class="subst">$&#123; hostname&#125;</span>:<span class="subst">$&#123; port &#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-Node-中文乱码问题解决："><a href="#3-Node-中文乱码问题解决：" class="headerlink" title="3. Node 中文乱码问题解决："></a>3. Node 中文乱码问题解决：</h2><h4 id="1-设置请求头"><a href="#1-设置请求头" class="headerlink" title="1. 设置请求头"></a>1. 设置请求头</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line"> <span class="string">'Content-Type'</span>: <span class="string">'text/html;charset=UTF8'</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h4 id="2-发送-response-write"><a href="#2-发送-response-write" class="headerlink" title="2. 发送 response.write()"></a>2. 发送 response.write()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.write(<span class="string">'&lt;meta charset=UTF-8&gt;'</span>)</span><br></pre></td></tr></table></figure><h4 id="3-toString"><a href="#3-toString" class="headerlink" title="3. toString()"></a>3. toString()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对二进制有效：将二进制 -》 toSrgin()</span><br></pre></td></tr></table></figure><h2 id="4-Node-实时监听-自动刷新"><a href="#4-Node-实时监听-自动刷新" class="headerlink" title="4. Node 实时监听(自动刷新)"></a>4. Node 实时监听(自动刷新)</h2><p>借助第三方工具：</p><ul><li>nodemon [ 推荐 ]</li><li>supervisor</li></ul><h2 id="5-commonJS规范"><a href="#5-commonJS规范" class="headerlink" title="5. commonJS规范"></a>5. commonJS规范</h2><ul><li>CommonJs 规范的提出，主要是为了弥补 javascript 没有标准的缺陷，希望javascript 能在任何地方运行，能向java和Python具有开发大型应用的基础能力，可不是停留在脚本程序的阶段。</li><li>commonJS规范思想 是单独的文件就是一个模块,每一个模块都是一个独立的作用域</li><li>每个文件对外接口都是module.exports对象</li></ul><h3 id="1-CommonJs的模块规范"><a href="#1-CommonJs的模块规范" class="headerlink" title="1. CommonJs的模块规范"></a>1. CommonJs的模块规范</h3><p>CommonJS对模块的定义主要分为：</p><h4 id="1-模块定义"><a href="#1-模块定义" class="headerlink" title="1. 模块定义"></a>1. 模块定义</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 模块定义</span></span><br><span class="line"><span class="keyword">const</span> student = &#123;   <span class="comment">//可以是对象(可以传多个)、函数、字符串</span></span><br><span class="line">    name: <span class="string">'meijuna'</span>,</span><br><span class="line">    jineng () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I cn fly'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-模块导出"><a href="#2-模块导出" class="headerlink" title="2. 模块导出"></a>2. 模块导出</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 模块导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = student; <span class="comment">//安全性不高，只能到处多个</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;  <span class="comment">//更安全，批量导出</span></span><br><span class="line">student,</span><br><span class="line">fn</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-模块引用"><a href="#3-模块引用" class="headerlink" title="3. 模块引用"></a>3. 模块引用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 模块引用</span></span><br><span class="line"><span class="keyword">const</span> student = <span class="built_in">require</span>(<span class="string">'./xx.js'</span>); <span class="comment">// or</span></span><br><span class="line"><span class="keyword">const</span> &#123; student, fn &#125; = requie(<span class="string">'./xx.js); //可以按需引用</span></span><br></pre></td></tr></table></figure><h3 id="2-模块标识符主要分类："><a href="#2-模块标识符主要分类：" class="headerlink" title="2. 模块标识符主要分类："></a>2. 模块标识符主要分类：</h3><h4 id="1-内置模块-（http、fs"><a href="#1-内置模块-（http、fs" class="headerlink" title="1. 内置模块 （http、fs)"></a>1. 内置模块 （http、fs)</h4><h6 id="1）url-模块：处理-url"><a href="#1）url-模块：处理-url" class="headerlink" title="1）url 模块：处理 url"></a>1）url 模块：处理 url</h6><p>URL模块提供了三种处理path的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 将path字符类型转成对象</span><br><span class="line">left url = <span class="string">"http://user:pass@host.com:8080/p/a/t/h?query=string#hash"</span>;</span><br><span class="line">url.parse(url,[可选布尔值],[可选项布尔值]);</span><br><span class="line">    &#123;</span><br><span class="line">        单词解释解析属性属性解释</span><br><span class="line">        协议protocol:<span class="string">"http:"</span>,协议</span><br><span class="line">        斜线slashes:<span class="literal">true</span>,是否有<span class="comment">//</span></span><br><span class="line">        认证auth:<span class="string">"user:pass"</span>,用户名与密码</span><br><span class="line">        主机host:<span class="string">"host.com:8080"</span>,主机</span><br><span class="line">        接口port:<span class="string">"8080"</span>,端口</span><br><span class="line">        主机名hostname:<span class="string">"host.com"</span>,域名</span><br><span class="line">        搞砸hash:<span class="string">"#hash"</span>, 片段标识符,指向html页面某个dom元素的id</span><br><span class="line">        搜索search:<span class="string">"?query=string"</span>,? + 查询字符串</span><br><span class="line">        查询query:<span class="string">"query=string"</span>,查询字符</span><br><span class="line">        路径名pathname:<span class="string">"/p/a/t/h"</span>,端口号和?之间的 路径那部分</span><br><span class="line">        路径path:<span class="string">"/p/a/t/h?query=string"</span>,pathname + search </span><br><span class="line">        水平基准href:全路径url 原始路径</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="number">2</span>) 将对象转成url字符串</span><br><span class="line">url.format(obj)</span><br><span class="line">ps:参考结合parse方法;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) 替换或者替换(未验证)</span><br><span class="line">url.resolve(<span class="keyword">from</span>,to)</span><br><span class="line"><span class="keyword">from</span> 源地址</span><br><span class="line">to需要添加或替换的标签</span><br><span class="line">ps:form源地址末尾有/就是添加  没有就是替换 具体待验证</span><br></pre></td></tr></table></figure><h6 id="2-fs-模块"><a href="#2-fs-模块" class="headerlink" title="2) fs 模块"></a>2) fs 模块</h6><p>fs 模块是专门处理操作磁盘文件,特点每个方法都有同步和异步两种 (需注意:同步以sync结尾)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">读取文件:</span><br><span class="line">fs.readFile(<span class="string">"文件路径"</span>,&#123;opt&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">&#123;opt&#125;:可选项</span><br><span class="line">encoding:<span class="string">"utf-8"</span>以utf<span class="number">-8</span>国际编码读取文件内容</span><br><span class="line">flag:<span class="string">"r+"</span>read的简称,只读取文件,不存在即报错</span><br><span class="line">flag:<span class="string">"w+"</span>write的简称,读写文件,不存在则自动创建</span><br><span class="line"></span><br><span class="line">err:errorObject报错机制 一般用<span class="keyword">if</span>判断用<span class="keyword">throw</span>抛出错误</span><br><span class="line">列:</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="keyword">throw</span> err</span><br><span class="line">&#125;</span><br><span class="line">ps:<span class="built_in">console</span>.error()抛出错误,不影响程序执行</span><br><span class="line"></span><br><span class="line">data:成功读取的数据,是以buffer数据二进制存储格式存在</span><br><span class="line">ps:data.toString()可以转成UTF<span class="number">-8</span>格式,等价于可选项中的encoding:<span class="string">"utf-8"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">写入文件:</span><br><span class="line">fs.writeFile(<span class="string">"写入路径"</span>,<span class="string">"内容数据"</span>,&#123;opt&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line">追加内容:</span><br><span class="line">fs.appendFile(<span class="string">"追加文件路径"</span>,<span class="string">"内容数据"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line">读取文件夹:</span><br><span class="line">fs.readdir(<span class="string">"文件夹路径"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,paths</span>)</span>&#123;</span><br><span class="line">ps:readdir是directory的缩写</span><br><span class="line">paths:成功读取文件夹 用数组存储文件内容</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">创建文件夹:</span><br><span class="line">fs.mkdir(<span class="string">"文件夹路径,同时也是文件夹名称"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><h6 id="3）path-模块"><a href="#3）path-模块" class="headerlink" title="3）path 模块"></a>3）path 模块</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">拼接路径:</span><br><span class="line">join(xx,xx,xxx,.）使用平台特定的分隔符,将所有给定的段连接在一起</span><br><span class="line">ps:常用到的路径</span><br><span class="line">__dirname当前执行文件所在的绝对路径</span><br></pre></td></tr></table></figure><h6 id="4）querystring-模块"><a href="#4）querystring-模块" class="headerlink" title="4）querystring 模块"></a>4）querystring 模块</h6><p>querystring模块一般是对 http 请求的 URL 所带的数据进行解析处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 格式数据格式化为字符串:stringify </span><br><span class="line">    <span class="keyword">let</span> objData = &#123;</span><br><span class="line">        name:<span class="string">"skye"</span>,</span><br><span class="line">        url:<span class="string">"http://skyelovedj.com"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> querystring = <span class="built_in">require</span>(<span class="string">"querystring"</span>);</span><br><span class="line">    querystring.stringify(objData,<span class="string">"分隔符"</span>,<span class="string">"分配符"</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>) 将参数字符格式为对象:</span><br><span class="line">    <span class="keyword">let</span> strData = <span class="string">"name:skye&amp;age=18"</span></span><br><span class="line">    <span class="keyword">let</span> querystring = <span class="built_in">require</span>(<span class="string">"querystring"</span>);</span><br><span class="line">    querystring.parse(strData,<span class="string">"分隔符"</span>,<span class="string">"分配符"</span>)</span><br><span class="line">    ps:分隔符和分配符是可选项</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) 编码:</span><br><span class="line">    querystring.escape(<span class="string">"data"</span>)只对符号与中文编码</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>) 解码:</span><br><span class="line">    querystring.Unescape(<span class="string">"data"</span>)只对符号与中文解码</span><br></pre></td></tr></table></figure><h6 id="5-zlib"><a href="#5-zlib" class="headerlink" title="5) zlib"></a>5) zlib</h6><p>制作压缩包的模块</p><p>流</p><p> *     可读的流： 可以通过文件系统读取的流 （ 数据流 ）</p><p> *     可写的流： 可以通过文件系统写入的流</p><p> *   管道流 ： 连通两个文件的通道 pipe</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>( <span class="string">'fs'</span> );</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>( <span class="string">'zlib'</span>); <span class="comment">//制作压缩包的模块</span></span><br><span class="line"><span class="comment">//创建可读的流</span></span><br><span class="line"><span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">'./a.txt'</span> );</span><br><span class="line"><span class="comment">//创建空压缩包</span></span><br><span class="line"><span class="keyword">const</span> gzib = zlib.createGzip();</span><br><span class="line"><span class="comment">//创建可写的流</span></span><br><span class="line"><span class="keyword">const</span> writeStream  = fs.createWriteStream(<span class="string">'./b.text.gz'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建流程</span></span><br><span class="line">readStream</span><br><span class="line">  .pipe( gzib )</span><br><span class="line">  .pipe( writeStream );</span><br></pre></td></tr></table></figure><h4 id="2-第三方模块"><a href="#2-第三方模块" class="headerlink" title="2. 第三方模块"></a>2. 第三方模块</h4><h4 id="3-自定义模块"><a href="#3-自定义模块" class="headerlink" title="3. 自定义模块"></a>3. 自定义模块</h4><h2 id="6-发送数据请求："><a href="#6-发送数据请求：" class="headerlink" title="6. 发送数据请求："></a>6. 发送数据请求：</h2><ol><li>http.request</li><li>request(封装 http-request 的第三方包)</li><li>http.get(options, (res) =&gt;{ })</li></ol><h2 id="7-前端模块化"><a href="#7-前端模块化" class="headerlink" title="7.   前端模块化"></a>7.   前端模块化</h2><p>为什么前端要使用模块化：</p><p>模块化：具有特定功能的一个对象(广义理解)</p><p>模块定义的流程：</p><pre><code>1. 定义模块2.  导出模块3.  应用模块</code></pre><p>好处： </p><pre><code>1. 可以存储多个独立的功能块2.  复用性高</code></pre><p>种类：</p><pre><code>1.  ADM （ require.js )</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(&#123;</span><br><span class="line">     a:<span class="number">1</span>,</span><br><span class="line">     b:<span class="number">2</span></span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="built_in">require</span>([./a.js], <span class="function"><span class="keyword">function</span>(<span class="params"> moduleA </span>) </span>&#123;</span><br><span class="line"> <span class="comment">//moduleA指的是</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>CMD ( sea.js )</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module </span>)</span>&#123;</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="built_in">require</span>(<span class="string">'./b.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> moduleB </span>)</span>&#123;</span><br><span class="line">     <span class="comment">//moduleB就是b模块中导出的内容</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>Common.js （ require.js ）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node 使用了 Common.js 的规范</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*目录结构： name.js index.js */</span></span><br><span class="line"><span class="comment">//模块定义 name.js</span></span><br><span class="line"><span class="keyword">const</span> nameObj = &#123;</span><br><span class="line">    name: <span class="string">'MeiJuna'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模块导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = nameObj;</span><br><span class="line"><span class="comment">//模块引用</span></span><br><span class="line"><span class="keyword">const</span> nameObj = <span class="built_in">require</span>(<span class="string">'./nameObj)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Node中Common.规范使用的三种类型：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> 1. 内置模块 (指的是挂载在Node全局对象身上的 api )</span></span><br><span class="line"><span class="string"> 2. 自定义模块</span></span><br><span class="line"><span class="string"> 3. 第三方模块</span></span><br></pre></td></tr></table></figure><h2 id="7-跨域问题"><a href="#7-跨域问题" class="headerlink" title="7. 跨域问题"></a>7. 跨域问题</h2><h4 id="前端跨域"><a href="#前端跨域" class="headerlink" title="前端跨域"></a>前端跨域</h4><h5 id="1-jsonp"><a href="#1-jsonp" class="headerlink" title="1. jsonp"></a>1. jsonp</h5><h5 id="2-反向代理"><a href="#2-反向代理" class="headerlink" title="2. 反向代理"></a>2. 反向代理</h5><p>（前端创建一个虚拟后端服务器，后台服务器帮助我们跨域）</p><h4 id="后端跨域"><a href="#后端跨域" class="headerlink" title="后端跨域"></a>后端跨域</h4><h5 id="1-设置响应头"><a href="#1-设置响应头" class="headerlink" title="1. 设置响应头"></a>1. 设置响应头</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&apos;Access-Control-Allow-Origin&apos;, req.headers.origin);</span><br><span class="line">// req.headers.origin = http://127.0.0.1:5500/</span><br></pre></td></tr></table></figure><h5 id="2-使用第三方中间件-cors"><a href="#2-使用第三方中间件-cors" class="headerlink" title="2. 使用第三方中间件 (cors)"></a>2. 使用第三方中间件 (cors)</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.use( cors(&#123;</span><br><span class="line"> <span class="string">"origin"</span>: <span class="string">"*"</span>,</span><br><span class="line"> <span class="string">"methods"</span>: <span class="string">"GET,HEAD,PUT,PATCH,POST,DELETE"</span>,</span><br><span class="line"> <span class="string">"preflightContinue"</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="string">"optionsSuccessStatus"</span>: <span class="number">200</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><ul><li>中间件: 就是具有一定功能的函数</li></ul><h2 id="8-前端的异步流程"><a href="#8-前端的异步流程" class="headerlink" title="8. 前端的异步流程"></a>8. 前端的异步流程</h2><p>异步流程的任务是放在异步队列中的，</p><ol><li><p>传统的原始异步</p><ul><li>异步函数</li><li>事件</li></ul></li><li><p>使用异步流程工具 （ 别人封装好的东西 )</p><p>es6 Promise 对象  </p><p>all :依次执行完再执行</p><p>race: 谁快谁执行</p><p>es6 generator 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在function 关键字后加一个 * </span><br><span class="line"> * 通过 yield关键字定义任务</span><br><span class="line"> * fn().next() 来执行任务</span><br><span class="line"> 结果返回一个对象 &#123;value: &apos;任务结果&apos;, done: false &#125;</span><br><span class="line">   value表示 yield关键字有任务执行的结果</span><br><span class="line">   done 表示当前定义的所有的任务十分执行完整的一种状态</span><br><span class="line"> * 理解：</span><br><span class="line">   -多任务的定义，多任务执行</span><br><span class="line">   -让自己定义的多个任务一次执行，上一个任务如果没有完成，下一个任务就不会开始</span><br><span class="line"></span><br><span class="line"> function* fn() &#123;</span><br><span class="line">   yield &apos;任务1&apos;</span><br><span class="line">   yield &apos;任务2&apos;</span><br><span class="line">   return &apos;任务&apos;</span><br><span class="line"> &#125;</span><br><span class="line"> console.log( a.next())</span><br><span class="line"> console.log( a.next());</span><br></pre></td></tr></table></figure><p>es6(7) async 函数  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">es6,7</span><br><span class="line"> * 配合关键字 await表示等待，await 任务1 执行结束才会 执行任务2</span><br><span class="line"> * 使用场景： 数据先请求，然后把结果赋值到变量</span><br><span class="line"> async function fn() &#123;</span><br><span class="line"> const result = await &apos;任务1&apos;;</span><br><span class="line"> console.log( &apos;任务二&apos; );</span><br><span class="line">&#125;</span><br><span class="line">2. 箭头函数的写法</span><br><span class="line">const fn1 = async () =&gt; &#123;</span><br><span class="line">const res = await &apos;任务3&apos;;</span><br><span class="line">console.log( res );</span><br><span class="line">cosnole.log( &apos;任务4&apos; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   node中的 nextTick() 和 setImmediate()</p></li></ol><p>​<br>​        nextTIck<br>​        <em> setImmediate<br>​        </em><br>​        <em> 轮询： 一个事件往复执行，那么每一次执行完成，我们就认为是个轮询<br>​        </em> 事件轮询前， 使用nextTick<br>​        <em> 事件轮询后， 使用setImmediate<br>​        </em><br>​        * nextTick &gt; () =&gt;  &gt; setImmediate </p><p>​     </p><p> 第三方的 async.js 库</p><p>文档： <a href="http://caolan.github.io/async/v3/index.html" target="_blank" rel="noopener">async</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   cnpm i  yarn -g</span><br><span class="line">   yarn add <span class="keyword">async</span> -D</span><br><span class="line"></span><br><span class="line">- parallel: 并行</span><br><span class="line">- series ：串行,<span class="keyword">return</span> 数组，任务都是完整正确的，如果一个任务失败，后面的任务也会失败</span><br><span class="line"></span><br><span class="line">   主线程</span><br><span class="line">   并行 parallel &#123; <span class="attr">two</span>: <span class="number">2</span>, <span class="attr">one</span>: <span class="number">1</span> &#125;</span><br><span class="line">   串行 series &#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span> &#125;</span><br><span class="line">   结论： 主线程先执行，然后 parallel (谁快谁先走),最后 series 并行 (上个运行完，在运行下一个)</span><br></pre></td></tr></table></figure><h2 id="9-socket-通信"><a href="#9-socket-通信" class="headerlink" title="9.  socket 通信"></a>9.  socket 通信</h2><h4 id="1-基于后端的通信-pc"><a href="#1-基于后端的通信-pc" class="headerlink" title="1. 基于后端的通信  ( pc )"></a>1. 基于后端的通信  ( pc )</h4><ul><li>node 中的 net 模块</li></ul><p>服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>( <span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">"localhost"</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">9000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clients = &#123;&#125;; <span class="comment">//存储每一个客户端</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;      <span class="comment">//给客户端编号</span></span><br><span class="line"><span class="comment">//1. 创建服务器</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> net.createServer()</span><br><span class="line"><span class="comment">//2. 连接客户端</span></span><br><span class="line">server.on( <span class="string">'connection'</span>, client =&gt; &#123;</span><br><span class="line">  client.name = ++count; <span class="comment">///每个客户端起个名字</span></span><br><span class="line">  clients[ client.name ] = client; <span class="comment">//将每一个客户端 都存储在 clients 中，key:client.name</span></span><br><span class="line">  <span class="comment">//3. 获取客户端发来的数据</span></span><br><span class="line">  client.on( <span class="string">'data'</span>, msg =&gt; &#123;</span><br><span class="line">    boardcast( client, msg.toString() );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">`用户 <span class="subst">$&#123; client.name &#125;</span> 说: <span class="subst">$&#123; msg.toString()&#125;</span>`</span> )</span><br><span class="line"> </span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//监听客户端的异常</span></span><br><span class="line">  client.on( <span class="string">'error'</span>, error =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`error is <span class="subst">$&#123; error &#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//监听客户端的下线行为</span></span><br><span class="line">  client.on( <span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">//将下线的客户端清除 --清除 clents 对象</span></span><br><span class="line">    <span class="keyword">delete</span> clients[ client.name ]</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`客户端<span class="subst">$&#123; client.name &#125;</span> closed~~`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//4. 将客户端发来的信息展示到自己终端上( 广播 )  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boardcast</span>(<span class="params"> client, msg</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 客户端  客户端发来的消息</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> clients) &#123;</span><br><span class="line">    clients[ key ].write( msg );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 监听服务器</span></span><br><span class="line">server.listen( port, hostname, () =&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`The srerver is ruuing at:http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  客户端：</span></span><br><span class="line"><span class="comment">    1. 创建socket</span></span><br><span class="line"><span class="comment">    2. socket连接服务器</span></span><br><span class="line"><span class="comment">    3. 给服务器发送信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建socket</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> net = <span class="built_in">require</span>( <span class="string">'net'</span> );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> socket = <span class="keyword">new</span> net.Socket();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> port = <span class="number">9000</span>;</span><br><span class="line">  <span class="keyword">const</span> hostname = <span class="string">'localhost'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> readline = <span class="built_in">require</span>( <span class="string">'readline'</span> );<span class="comment">//这是用来做命令行读取</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rl = readline.createInterface(&#123;</span><br><span class="line">    input: process.stdin,</span><br><span class="line">    output: process.stdout</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2. socket连接服务器</span></span><br><span class="line"></span><br><span class="line">  socket.connect( port,hostname, () =&gt; &#123;</span><br><span class="line">    <span class="comment">//当我第一次连接好服务器之后，我给服务器发送一个我连接好的信息</span></span><br><span class="line">    socket.write( <span class="string">'欢迎xxx来到xxx的直播间'</span> )</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//客户端监听自己的异常</span></span><br><span class="line"></span><br><span class="line">  socket.on( <span class="string">'error'</span>, error =&gt;  &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">`socket error is <span class="subst">$&#123; error &#125;</span>`</span> )</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  socket.on( <span class="string">'close'</span> , () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">`socket connection closed ~~~`</span> )</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 给服务器发送信息</span></span><br><span class="line"></span><br><span class="line">  socket.on( <span class="string">'data'</span>, msg =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( msg.toString() )<span class="comment">//客户端自己显示写的内容</span></span><br><span class="line">    say()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">say</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    rl.question(<span class="string">'请输入: '</span>, ( answer ) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>( answer === <span class="string">'bye'</span> )&#123;</span><br><span class="line">        <span class="comment">//要进行命令行的结束</span></span><br><span class="line">        socket.destroy() <span class="comment">//清除连接</span></span><br><span class="line">        rl.close()<span class="comment">// 关闭命令行读取</span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        socket.write( answer )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-基于H5的-webSocket-来完成-应用于移动端"><a href="#2-基于H5的-webSocket-来完成-应用于移动端" class="headerlink" title="2. 基于H5的 webSocket 来完成  ( 应用于移动端 )"></a>2. 基于H5的 webSocket 来完成  ( 应用于移动端 )</h4><p>服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  主服务器</span></span><br><span class="line"><span class="comment">    1. 通过ws模块来创建服务器</span></span><br><span class="line"><span class="comment">    2. 服务器连接客户端</span></span><br><span class="line"><span class="comment">      - 给客户端编号</span></span><br><span class="line"><span class="comment">    3. 接收客户端发来的信息</span></span><br><span class="line"><span class="comment">    4. 监听客户端下线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 通过 ws模块 来创建服务器</span></span><br><span class="line">  <span class="keyword">const</span> webSocket = <span class="built_in">require</span>( <span class="string">'ws'</span> );</span><br><span class="line">  <span class="keyword">const</span> ws = <span class="keyword">new</span> webSocket.Server(&#123;</span><br><span class="line">    port: <span class="number">8000</span>,</span><br><span class="line">    host: <span class="string">'10.31.161.48'</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 服务器连接客户端</span></span><br><span class="line">  <span class="keyword">const</span> clients = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ws.on( <span class="string">'connection'</span>, client =&gt; &#123;</span><br><span class="line">    <span class="comment">//   - 给客户端编号</span></span><br><span class="line">    client.name = ++count;</span><br><span class="line">    clients[ client.name ] = client </span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端发来的数据</span></span><br><span class="line"></span><br><span class="line">    client.on( <span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">`客户端 <span class="subst">$&#123; client.name &#125;</span>说：<span class="subst">$&#123; msg &#125;</span>`</span>)</span><br><span class="line">      boardcast( client,msg )</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 监听客户端下线</span></span><br><span class="line">    client.on( <span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">delete</span> clients[ client.name ]</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">`客户端 <span class="subst">$&#123; client.name &#125;</span> closed~~`</span> )</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">boardcast</span> (<span class="params"> client,msg </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> key <span class="keyword">in</span> clients )&#123;</span><br><span class="line">      clients[ key ].send( msg )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  客户端连接服务器文件</span></span><br><span class="line"><span class="comment">    \(^o^)/~          h5 提供了一个 Socket  的全局对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket( <span class="string">'ws://10.31.161.48:8000'</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ws.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ws.send( <span class="string">'欢迎来到xxx的直播间'</span> )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ws.onmessage = <span class="function">(<span class="params"> msg </span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> content = <span class="built_in">document</span>.querySelector( <span class="string">'#content'</span> );</span><br><span class="line">    content.innerHTML += msg.data + <span class="string">'&lt;br/&gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ws.onerror = <span class="function">(<span class="params"> error </span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( error )&#123;</span><br><span class="line">      <span class="built_in">console</span>.log( error )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ws.onclose = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">`xxx下线了`</span> )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="3-低版本浏览器使用的-socket-io"><a href="#3-低版本浏览器使用的-socket-io" class="headerlink" title="3. 低版本浏览器使用的 socket.io"></a>3. 低版本浏览器使用的 socket.io</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Node-基础语法&quot;&gt;&lt;a href=&quot;#Node-基础语法&quot; class=&quot;headerlink&quot; title=&quot;Node 基础语法&quot;&gt;&lt;/a&gt;Node 基础语法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;浏览器Javascript 不能做什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li
      
    
    </summary>
    
      <category term="Node" scheme="http://yoursite.com/categories/Node/"/>
    
    
      <category term="Node" scheme="http://yoursite.com/tags/Node/"/>
    
      <category term="语法" scheme="http://yoursite.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>面试</title>
    <link href="http://yoursite.com/2019/04/14/%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2019/04/14/面试/</id>
    <published>2019-04-14T08:30:09.000Z</published>
    <updated>2019-06-17T14:15:58.113Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-工作技能要求"><a href="#1-工作技能要求" class="headerlink" title="1.工作技能要求"></a>1.工作技能要求</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">招聘岗位：高级前端开发工程师</span><br><span class="line">薪资：12k - 20k</span><br><span class="line">职位描述：</span><br><span class="line">根据产品需求和设计完成前端页面代码，实现交互效果</span><br><span class="line">与后台工程师协作，完成数据交互、动态信息展现</span><br><span class="line">维护及优化网站前端页面执行性能和加载性能，优化前端代码规范</span><br><span class="line">能够有效地解决实际开发问题，与后台技术开发保持良好沟通，快速理解、消化各方需求，并落实为具体的开发工作</span><br><span class="line">职位要求：</span><br><span class="line">熟练运用 html5/css3 布局，具备一定的审美能力和观察能力，能快速精确的还原设计稿(PS/Sketch)，有移动端项目开发经验</span><br><span class="line">代码结构清晰，javascript 基础扎实，熟悉掌握任意一门前端 MV*框架，如 vueJS、reactJS 等</span><br><span class="line">对前端组件化、模块化、工程化有深入的见解和实践</span><br><span class="line">熟悉前端构建工具基本用法（ webpack、gulp、grunt ）</span><br><span class="line">熟悉 CSS 预处理 LESS/SASS 等</span><br><span class="line">有 github 项目经验者优先，请附上 github 或个人博客地址</span><br></pre></td></tr></table></figure><h4 id="2-题目"><a href="#2-题目" class="headerlink" title="2.题目"></a>2.题目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">网络通信协议有哪些？</span><br><span class="line"></span><br><span class="line">TCP三次握手说的越详细越好。</span><br><span class="line"></span><br><span class="line">服务器代理为啥能实现跨域？</span><br><span class="line"></span><br><span class="line">src为啥不受同源策略影响？</span><br><span class="line"></span><br><span class="line">301和303有啥区别？</span><br><span class="line"></span><br><span class="line">304是怎么产生的？</span><br><span class="line">我就缓存和几个状态码</span><br><span class="line">第三次握手的必要性</span><br><span class="line"></span><br><span class="line">delete. Post. Trace. Head. 这些请求</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问vue和jq你了解过吗</span><br><span class="line">问我期望薪资的时候，</span><br><span class="line">vue让你封装一个表格组件</span><br><span class="line">什么场景？有什么功能，需求是什么</span><br><span class="line">以前的技术栈?</span><br><span class="line">react15和ng2</span><br><span class="line"></span><br><span class="line">vue框架中你能一般使用什么ui</span><br><span class="line"></span><br><span class="line">element-ui iview vant</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-工作技能要求&quot;&gt;&lt;a href=&quot;#1-工作技能要求&quot; class=&quot;headerlink&quot; title=&quot;1.工作技能要求&quot;&gt;&lt;/a&gt;1.工作技能要求&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Git 使用</title>
    <link href="http://yoursite.com/2019/01/03/Git-%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/01/03/Git-使用/</id>
    <published>2019-01-03T00:53:13.558Z</published>
    <updated>2019-06-17T14:13:44.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-操作"><a href="#git-操作" class="headerlink" title="git 操作"></a>git 操作</h2><p><code>git checkout -- file</code>可以丢弃工作区的修改</p><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p><code>git status</code>命令看看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p><p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用<code>git diff</code>这个命令看看：</p><p>git diff 比较的是工作区文件与暂存区文件的区别（上次git add 的内容）<br>git diff –cached 比较的是暂存区的文件与仓库分支里（上次git commit 后的内容）的区别</p><p>———————–版本库——————————————–<br>|                           |<br>​        git diff –cached    （是只比较暂存区和版本库的区别）             |<br>|                           |<br>————-暂存区———————-       git diff HEAD   （只比较工作区和版本库（最后一次commit）的区别）<br>|<br>​            git diff  （工作区和暂存区（最后一次add））                             |<br>|                                                        |<br>—–工作区————————————————————–</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure><p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p><p>知道了对<code>readme.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>在Git中，我们用<code>git log</code>命令显示从最近到最远的提交日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure><p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure><p>还可以继续回退到上一个版本<code>wrote a readme file</code>，不过且慢，然我们用<code>git log</code>再看看现在版本库的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p> 最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p><p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 1094a</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><hr><p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>然后尝试提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m &quot;append GPL&quot;</span><br><span class="line">[master 1094adb] append GPL</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p><p>现在，我们回顾一下<code>readme.txt</code>文件一共有几个版本被提交到Git仓库里了：</p><p>版本1：wrote a readme file</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>版本2：add distributed</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>版本3：append GPL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure><p>需要友情提示的是，你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907545599be4a60a0b5044447b47c8d8b805a25d2000/0" alt="git-log-timeline"></p><p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure><p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p><p>看看<code>readme.txt</code>的内容是不是版本<code>add distributed</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>果然被还原了。</p><p>还可以继续回退到上一个版本<code>wrote a readme file</code>，不过且慢，然我们用<code>git log</code>再看看现在版本库的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p>最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p><p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 1094a</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure><p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p><p>再小心翼翼地看看<code>readme.txt</code>的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>果然，我胡汉三又回来了。</p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907584977fc9d4b96c99f4b5f8e448fbd8589d0b2000/0" alt="git-head"></p><p>改为指向<code>add distributed</code>：</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907594057a873c79f14184b45a1a66b1509f90b7a000/0" alt="git-head-move"></p><p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><p>终于舒了口气，从输出可知，<code>append GPL</code>的commit id是<code>1094adb</code>，现在，你又可以乘坐时光机回到未来了。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>现在总结一下：</p><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><h4 id="撤销修改-git-checkout-–-file-可以丢弃工作区的修改："><a href="#撤销修改-git-checkout-–-file-可以丢弃工作区的修改：" class="headerlink" title="撤销修改 git checkout – file 可以丢弃工作区的修改："></a>撤销修改 git checkout – file 可以丢弃工作区的修改：</h4><hr><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在<code>readme.txt</code>中添加了一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure><p>在你准备提交前，一杯咖啡起了作用，你猛然发现了<code>stupid boss</code>可能会让你丢掉这个月的奖金！</p><p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>现在，看看<code>readme.txt</code>的文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure><p>文件内容果然复原了。</p><p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p><p>现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   readme.txt</span><br></pre></td></tr></table></figure><p><strong>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M    readme.txt</span><br></pre></td></tr></table></figure><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   readme.txt</span><br></pre></td></tr></table></figure><p>还记得如何丢弃工作区的修改吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>又到了小结时间。</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000" target="_blank" rel="noopener">版本回退</a>一节，不过前提是没有推送到远程库。</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><hr><p>当你要删除文件的时候，可以采用命令：rm test.txt</p><p>这个时候有两种情况</p><p>第一种情况:的确要把test.txt删掉，</p><p>那么可以执行                    git rm test.txt               </p><p>​                       git commit -m “remove test.txt”                   </p><pre><code>文件被删除，且删除记录上传本地库</code></pre><p>第二种情况:误删文件，想恢复，这时候还没有commit -m “remove test.txt”，</p><p>执行git checkout test.txt将文件恢复。</p><p>如果执行完git commit -m “remove test.txt”后就不能用checkout恢复了，得用git reset –hard HEAD^</p><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong></p><h4 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:meijuna/learngit.git</span><br></pre></td></tr></table></figure><p>请千万注意，把上面的<code>meijuna</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.</span><br><span class="line">Total 20 (delta 5), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (5/5), done.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;.</span><br></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>从现在起，只要本地作了提交，就可以通过命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p><h5 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h5><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href="https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/" target="_blank" rel="noopener">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p><h2 id="初次安装git配置用户名和邮箱"><a href="#初次安装git配置用户名和邮箱" class="headerlink" title="初次安装git配置用户名和邮箱"></a>初次安装git配置用户名和邮箱</h2><p>查看邮箱 和shh key是否设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name   //查看用户名&amp;邮箱</span><br><span class="line"></span><br><span class="line">$ git config user.email</span><br><span class="line"></span><br><span class="line">$ ssh -T git@github.com  //ssh</span><br></pre></td></tr></table></figure><p>用户名和邮箱的作用：</p><p>　　用户名和邮箱地址相当于你的身份标识，是本地Git客户端的一个变量，不会随着Git库而改变。</p><p>　　每次commit都会用用户名和邮箱纪录。</p><p>　　github的contributions跟你的邮箱是有关联的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;meijuna&quot;</span><br><span class="line"></span><br><span class="line">$ git config --global user.email &quot;1914623558@qq.com&quot;</span><br><span class="line"></span><br><span class="line">$ git config user.name   //查看用户名&amp;邮箱</span><br><span class="line"></span><br><span class="line">$ git config user.email</span><br><span class="line"></span><br><span class="line">$ git config --global user.name &quot;xxx&quot; //修改用户名邮箱</span><br><span class="line"></span><br><span class="line">$ git config --global user.email &quot;xxx&quot;</span><br></pre></td></tr></table></figure><h2 id="git使用ssh密钥"><a href="#git使用ssh密钥" class="headerlink" title="git使用ssh密钥"></a>git使用ssh密钥</h2><p>git支持https和git两种传输协议，github分享链接时会有两种协议可选：</p><p>1.git使用https协议，每次pull, push都会提示要输入密码</p><p>2.使用git协议，然后使用ssh密钥，这样免去每次都输密码的麻烦</p><hr><p><strong>初次使用git的用户要使用git协议大概需要三个步骤：</strong></p><p><strong>一、生成密钥对</strong></p><p><strong>二、设置远程仓库（本文以github为例）上的公钥</strong></p><p><strong>三、把git的 remote url 修改为git协议</strong>（以上两个步骤初次设置过以后，以后使用都不需要再次设置，此步骤视以后项目的remote url而定，如果以后其他项目的协议为https则需要此步骤）</p><hr><h3 id="一、生成密钥对"><a href="#一、生成密钥对" class="headerlink" title="一、生成密钥对"></a>一、生成密钥对</h3><p>大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥。</p><p>SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。进去看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">id_rsa  id_rsa.pub  key_backup/  known_hosts</span><br></pre></td></tr></table></figure><p>看一下有没有id_rsa和id_rsa.pub(或者是id_dsa和id_dsa.pub之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。</p><p>假如没有这些文件，甚至连 .ssh 目录都没有，可以用 ssh-keygen 来创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-keygen -t rsa-C "your_email@youremail.com" //你的github绑定的邮箱</span><br></pre></td></tr></table></figure><p>直接按Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)<br><img src="/2019/01/03/Git-使用/1.png" alt=""></p><p>如果之后你出现了这个界面之后，就说明你的密匙已经成功创建了。现在你就需要去他刚刚显示的存储位置打开它，把其中的内容复制出来。</p><p><strong>到此为止，你本地的密钥对就生成了。</strong></p><h3 id="二、添加公钥到你的远程仓库（github）"><a href="#二、添加公钥到你的远程仓库（github）" class="headerlink" title="二、添加公钥到你的远程仓库（github）"></a>二、添加公钥到你的远程仓库（github）</h3><hr><ol><li><p>查看你的公匙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0X6L1zLL4VHuvGb8aJH3ippTozmReSUzgntvk434aJ/v7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8vR3c8E7CjZN733f5AL8uEYJA+YZevY5UCvEg+umT7PHghKYaJwaCxV7sjYP7Z6V79OMCEAGDNXC26IBMdMgOluQjp6o6j2KAdtRBdCDS/QIU5THQDxJ9lBXjk1fiq9tITo/aXBvjZeD+gH/Apkh/0GbO8VQLiYYmNfqqAHHeXdltORn8N7C9lOa/UW3KM7QdXo6J0GFlBVQeTE/IGqhMS5PMln3 admin@admin-PC</span><br></pre></td></tr></table></figure></li><li><p>登陆你的github帐户。点击你的头像，然后 <code>Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key</code></p></li><li><p>然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，自己随便起个名字。</p></li><li>点击 Add key</li></ol><p><strong>完成以后，验证下这个key是不是正常工作：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果出现 HI XXX 说明设置成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi meijuna! You&apos;ve successfully authenticated, but GitHub does not provide shell access</span><br></pre></td></tr></table></figure></p><h3 id="三、修改git的remote-url"><a href="#三、修改git的remote-url" class="headerlink" title="三、修改git的remote url"></a>三、修改git的remote url</h3><hr><p>使用命令 git remote -v 查看你当前的 remote url (远程仓库)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin https://github.com/someaccount/someproject.git (fetch)</span><br><span class="line">origin https://github.com/someaccount/someproject.git (push)</span><br></pre></td></tr></table></figure><p>如果是以上的结果那么说明此项目是使用https协议进行访问的（如果地址是git开头则表示是git协议）</p><p>你可以登陆你的github，就像本文开头的图例，你在上面可以看到你的ssh协议相应的url</p><p>复制此ssh链接，然后使用命令 git remote set-url 来调整你的url。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:someaccount/someproject.git</span><br></pre></td></tr></table></figure><p>然后你可以再用命令 <code>git remote -v</code>查看一下，url是否已经变成了ssh地址。</p><p>然后你就可以愉快的使用git fetch, git pull , git push，再也不用输入烦人的密码了</p><h2 id="git-操作-1"><a href="#git-操作-1" class="headerlink" title="git 操作"></a>git 操作</h2><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add pb https://github.com/zhousg/letao.git</span><br></pre></td></tr></table></figure><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">pb      https://github.com/zhousg/letao.git (fetch)</span><br><span class="line">pb      https://github.com/zhousg/letao.git (push)</span><br></pre></td></tr></table></figure><p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git fetch pb</span><br><span class="line">remote: Counting objects: 43, done.</span><br><span class="line">remote: Compressing objects: 100% (36/36), done.</span><br><span class="line">remote: Total 43 (delta 10), reused 31 (delta 5)</span><br><span class="line">Unpacking objects: 100% (43/43), done.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure><p>现在 Paul 的 master 分支可以在本地通过 <code>pb/master</code> 访问到 - 你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching" target="_blank" rel="noopener">Git 分支</a> 中详细介绍什么是分支以及如何使用分支。）</p><h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 <code>git fetch</code> 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作</p><p>Git 分支</p><h3 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h3><p>当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p><p><strong>现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）</strong></p><p><img src="/2019/01/03/Git-使用/commit-and-tree.png" alt=""></p><p><strong>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针</strong>。</p><p><img src="https://git-scm.com/book/en/v2/images/commits-and-parents.png" alt="æäº¤å¯¹è±¡åå¶ç¶å¯¹è±¡ã"></p><p>Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 <code>git init</code> 命令默认创建它，并且大多数人都懒得去改动它。</p><h3 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查看分支：git branch</span><br><span class="line"></span><br><span class="line">创建分支：git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">切换分支：git checkout &lt;name&gt;</span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除分支：git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch testing  //创建testing分支</span><br></pre></td></tr></table></figure><p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 <code>HEAD</code> 想象为当前分支的别名）。 在本例中，你仍然在 <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 <em>创建</em> 一个新分支，并不会自动切换到新分支中去。</p><p><img src="https://git-scm.com/book/en/v2/images/head-to-master.png" alt="HEAD æåå½åæå¨çåæ¯ã"></p><h3 id="指向当前所在的分支"><a href="#指向当前所在的分支" class="headerlink" title="指向当前所在的分支"></a>指向当前所在的分支</h3><p>你可以简单地使用 <code>git log</code> 命令查看各个分支当前所指的对象。 提供这一功能的参数是 <code>--decorate</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --decorate</span><br><span class="line">f30ab (HEAD, master, testing) add feature #32 - ability to add new</span><br><span class="line">34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">98ca9 initial commit of my project</span><br></pre></td></tr></table></figure><p>正如你所见，当前 “master” 和 “testing” 分支均指向校验和以 <code>f30ab</code> 开头的提交对象。</p><h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout testing</span><br></pre></td></tr></table></figure><p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。</p><p><img src="https://git-scm.com/book/en/v2/images/head-to-testing.png" alt="HEAD æåå½åæå¨çåæ¯ã"></p><h3 id="HEAD-指向当前所在的分支"><a href="#HEAD-指向当前所在的分支" class="headerlink" title="HEAD 指向当前所在的分支"></a>HEAD 指向当前所在的分支</h3><p>那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vim test.rb</span><br><span class="line"><span class="meta">$</span> git commit -a -m 'made other changes'</span><br></pre></td></tr></table></figure><p>现在，这个项目的提交历史已经产生了分叉（参见 <a href="https://git-scm.com/book/zh/v2/ch00/rdivergent_history" target="_blank" rel="noopener">项目分叉历史</a>）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 <code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p><p><img src="https://git-scm.com/book/en/v2/images/advance-testing.png" alt="HEAD åæ¯éçæäº¤æä½èªå¨ååç§&quot;å¨ã"></p><h3 id="HEAD-分支随着提交操作自动向前移动"><a href="#HEAD-分支随着提交操作自动向前移动" class="headerlink" title="HEAD 分支随着提交操作自动向前移动"></a>HEAD 分支随着提交操作自动向前移动</h3><p>如图所示，你的 <code>testing</code> 分支向前移动了，但是 <code>master</code> 分支却没有，它仍然指向运行 <code>git checkout</code> 时所指的对象。 这就有意思了，现在我们切换回 <code>master</code> 分支看看：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/checkout-master.png" alt="æ£åºæ¶ HEAD éä¹ç§&quot;å¨ã"></p><p>这条命令做了两件事。 一是使 HEAD 指回 <code>master</code> 分支，二是将工作目录恢复成 <code>master</code> 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 <code>testing</code>分支所做的修改，以便于向另一个方向进行开发。</p><p>分支切换会改变你工作目录中的文件</p><p>在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</p><p>我们不妨再稍微做些修改并提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vim test.rb</span><br><span class="line"><span class="meta">$</span> git commit -a -m 'made other changes'</span><br></pre></td></tr></table></figure><p>现在，这个项目的提交历史已经产生了分叉（参见 <a href="https://git-scm.com/book/zh/v2/ch00/rdivergent_history" target="_blank" rel="noopener">项目分叉历史</a>）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 <code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p><p><img src="https://git-scm.com/book/en/v2/images/advance-master.png" alt="é¡¹ç®åååå²ã"></p><h3 id="项目分叉历史"><a href="#项目分叉历史" class="headerlink" title="项目分叉历史"></a>项目分叉历史</h3><p>可以简单地使用 <code>git log</code> 命令查看分叉历史。 运行 <code>git log --oneline --decorate --graph --all</code> ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git log --oneline --decorate --graph --all</span><br><span class="line">* c2b9e (HEAD, master) made other changes</span><br><span class="line">| * 87ab2 (testing) made a change</span><br><span class="line">|/</span><br><span class="line">* f30ab add feature #32 - ability to add new formats to the</span><br><span class="line">* 34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">* 98ca9 initial commit of my project</span><br></pre></td></tr></table></figure><h2 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h2><p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：</p><ol><li>开发某个网站。</li><li>为实现某个新的需求，创建一个分支。</li><li>在这个分支上开展工作。</li></ol><p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：</p><ol><li>切换到你的线上分支（production branch）。</li><li>为这个紧急任务新建一个分支，并在其中修复它。</li><li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li><li>切换回你最初工作的分支上，继续工作。</li></ol><h3 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h3><p>首先，我们假设你正在你的项目上工作，并且已经有一些提交。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-1.png" alt="ä¸ä¸ªç®åçæäº¤åå²ã"></p><p>一个简单提交历史</p><p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 <code>-b</code> 参数的 <code>git checkout</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout -b iss53</span><br><span class="line">Switched to a new branch "iss53"</span><br></pre></td></tr></table></figure><p>它是下面两条命令的简写：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch iss53</span><br><span class="line"><span class="meta">$</span> git checkout iss53</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-2.png" alt="åå&quot;ºä¸ä¸ªæ°åæ¯æéã"></p><h3 id="创建一个新分支指针"><a href="#创建一个新分支指针" class="headerlink" title="创建一个新分支指针"></a>创建一个新分支指针</h3><p>你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，<code>iss53</code> 分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的 <code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-3.png" alt="iss53 åæ¯éçå·¥ä½çè¿å±ååæ¨è¿ã"></p><p>现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 <code>iss53</code> 的修改混在一起，你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 <code>master</code> 分支。</p><p>但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit amending）），我们会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_stashing" target="_blank" rel="noopener">储藏与清理</a> 中看到关于这两个命令的介绍。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 <code>master</code> 分支了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout master</span><br></pre></td></tr></table></figure><p>这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p><p>接下来，你要修复这个紧急问题。 让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout -b hotfix</span><br><span class="line">Switched to a new branch 'hotfix'</span><br><span class="line"><span class="meta">$</span> vim index.html</span><br><span class="line"><span class="meta">$</span> git commit -a -m 'fixed the broken email address'</span><br><span class="line">[hotfix 1fb7853] fixed the broken email address</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://git-scm.com/book/en/v2/images/basic-branching-4.png" alt="åºäº `master` åæ¯çç´§æ¥é®é¢åæ¯ï¼hotfix branchï¼ã"></h3><h3 id="基于-master-分支的紧急问题分支-hotfix-branch"><a href="#基于-master-分支的紧急问题分支-hotfix-branch" class="headerlink" title="基于 master 分支的紧急问题分支 hotfix branch"></a>基于 <code>master</code> 分支的紧急问题分支 <code>hotfix branch</code></h3><p>你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的 <code>master</code> 分支来部署到线上。 你可以使用 <code>git merge</code> 命令来达到上述目的：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout master</span><br><span class="line"><span class="meta">$</span> git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><p>在合并的时候，你应该注意到了”快进（fast-forward）”这个词。 由于当前 <code>master</code> 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p><p>现在，最新的修改已经在 <code>master</code> 分支所指向的提交快照中，你可以着手发布该修复了。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-5.png" alt="`master` è¢&quot;å¿&quot;è¿å° `hotfix`ã"></p><p>关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 <code>hotfix</code>分支，因为你已经不再需要它了 —— <code>master</code> 分支已经指向了同一个位置。 你可以使用带 <code>-d</code> 选项的 <code>git branch</code> 命令来删除分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (3a0874c).</span><br></pre></td></tr></table></figure><p>现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout iss53</span><br><span class="line">Switched to branch "iss53"</span><br><span class="line"><span class="meta">$</span> vim index.html</span><br><span class="line"><span class="meta">$</span> git commit -a -m 'finished the new footer [issue 53]'</span><br><span class="line">[iss53 ad82d7a] finished the new footer [issue 53]</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-6.png" alt="ç&quot;§ç&quot;­å¨ `iss53` åæ¯ä¸çå·¥ä½ã"></p><p>你在 <code>hotfix</code> 分支上所做的工作并没有包含到 <code>iss53</code> 分支中。 如果你需要拉取 <code>hotfix</code> 所做的修改，你可以使用 <code>git merge master</code> 命令将 <code>master</code> 分支合并入 <code>iss53</code> 分支，或者你也可以等到 <code>iss53</code> 分支完成其使命，再将其合并回 <code>master</code> 分支。</p><h3 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h3><p>假设你已经修正了 #53 问题，并且打算将你的工作合并入 <code>master</code> 分支。 为此，你需要合并 <code>iss53</code> 分支到 <code>master</code> 分支，这和之前你合并 <code>hotfix</code> 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 <code>git merge</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout master</span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta">$</span> git merge iss53</span><br><span class="line">Merge made by the 'recursive' strategy.</span><br><span class="line">index.html |    1 +</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>这和你之前合并 <code>hotfix</code> 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，<code>master</code> 分支所在提交并不是 <code>iss53</code> 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的工作祖先（<code>C2</code>），做一个简单的三方合并。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-merging-1.png" alt="ä¸æ¬¡å¸ååå¹¶ä¸­æç¨å°çä¸ä¸ªå¿&quot;ç§ã"></p><p>​    和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-merging-2.png" alt="ä¸ä¸ªåå¹¶æäº¤ã"></p><p>需要指出的是，Git 会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础；这和更加古老的 CVS 系统或者 Subversion （1.5 版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。 Git 的这个优势使其在合并操作上比其他系统要简单很多。</p><p>既然你的修改已经合并进来了，你已经不再需要 <code>iss53</code> 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch -d iss53</span><br></pre></td></tr></table></figure><h3 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h3><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 <code>hotfix</code> 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git merge iss53</span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run "git commit")</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use "git add &lt;file&gt;..." to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span>contact : email.support@github.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">=======</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line"> please contact us at support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><p>上述的冲突解决方案仅保留了其中一个分支的修改，并且 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p><p>如果你想使用图形化工具来解决冲突，你可以运行 <code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git mergetool</span><br><span class="line"></span><br><span class="line">This message is displayed because 'merge.tool' is not configured.</span><br><span class="line">See 'git mergetool --tool-help' or 'git help config' for more details.</span><br><span class="line">'git mergetool' will now attempt to use one of the following tools:</span><br><span class="line">opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge</span><br><span class="line">Merging:</span><br><span class="line">index.html</span><br><span class="line"></span><br><span class="line">Normal merge conflict for 'index.html':</span><br><span class="line">  &#123;local&#125;: modified file</span><br><span class="line">  &#123;remote&#125;: modified file</span><br><span class="line">Hit return to start merge resolution tool (opendiff):</span><br></pre></td></tr></table></figure><p>等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 <code>git status</code> 来确认所有的合并冲突都已被解决：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git status</span><br><span class="line">On branch master</span><br><span class="line">All conflicts fixed but you are still merging.</span><br><span class="line">  (use "git commit" to conclude merge)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line"></span><br><span class="line">    modified:   index.html</span><br></pre></td></tr></table></figure><p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 <code>git commit</code> 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Merge branch 'iss53'</span><br><span class="line"></span><br><span class="line">Conflicts:</span><br><span class="line">    index.html</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> It looks like you may be committing a merge.</span><br><span class="line"><span class="meta">#</span> If this is not correct, please remove the file</span><br><span class="line"><span class="meta">#</span>.git/MERGE_HEAD</span><br><span class="line"><span class="meta">#</span> and try again.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Please enter the commit message for your changes. Lines starting</span><br><span class="line"><span class="meta">#</span> with '#' will be ignored, and an empty message aborts the commit.</span><br><span class="line"><span class="meta">#</span> On branch master</span><br><span class="line"><span class="meta">#</span> All conflicts fixed but you are still merging.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Changes to be committed:</span><br><span class="line"><span class="meta">#</span>modified:   index.html</span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><p>合并后，我们用<code>git log</code>看看分支历史：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384909222841acf964ec9e6a4629a35a7a30588281bb000/0" alt="git-no-ff-mode"></p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。</p><p><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>注意 <code>master</code> 分支前的 <code>*</code> 字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code> 指针所指向的分支）。 这意味着如果在这时候提交，<code>master</code> 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 <code>git branch -v</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch -v</span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch 'iss53'</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure><p><code>--merged</code> 与 <code>--no-merged</code> 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 <code>git branch --merged</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch --merged</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>因为之前已经合并了 <code>iss53</code> 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用 <code>git branch -d</code> 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p><p>查看所有包含未合并工作的分支，可以运行 <code>git branch --no-merged</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch --no-merged</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 <code>git branch -d</code> 命令删除它时会失败：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch -d testing</span><br><span class="line">error: The branch 'testing' is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run 'git branch -D testing'.</span><br></pre></td></tr></table></figure><p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 <code>-D</code> 选项强制删除它。</p><h4 id="git-stash保留现场"><a href="#git-stash保留现场" class="headerlink" title="git stash保留现场"></a>git stash保留现场</h4><p>git stash </p><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了</p><p>先说几个名词<br>未被追踪的文件:指的是新建的文件或文件夹且还没加入到暂存区(新建的还没有被git add 过得)<br>未加入到暂存区的文件:指的是已经被追踪过，但是没有加入到暂存区(已经执行过git add/commit的但是这次修改后还没有git add)<br>举例:<br>readme.md  已经被git add/git commit过，但是呢 我这次只是修改了，而且没有修改完，不能commit<br>test    新建的文件夹,没有被git add/git commit过<br>有个急事需要处理,这时候我需要切换分支，去处理紧急任务,比如文中的举例去修改bug，<br>正确的步骤:<br>git add test（让git去追踪这个新文件）<br>git stash保留现场<br>如果我不执行这两个命令，那么我在修改BUG完成之后<br>git status，就会发现readme.md 没有添加到暂存区，同时又多了个test文件,但是自己的readme.md没有完成，万万不可以提交，这样导致bug的修改代码也提交不了。所以你需要<br>git stash，这样你在提交修改bug代码的时候 ，就不会看见readme.md 和 test。可以安心提交修改bug的代码。</p><h4 id="Feature分支-没有被合并过的分支，可以通过git-branch-D-lt-name-gt-强行删除"><a href="#Feature分支-没有被合并过的分支，可以通过git-branch-D-lt-name-gt-强行删除" class="headerlink" title="Feature分支 没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除"></a>Feature分支 没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除</h4><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p><p>于是准备开发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature-vulcan</span><br><span class="line">Switched to a new branch &apos;feature-vulcan&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git add vulcan.py</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch feature-vulcan</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   vulcan.py</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add feature vulcan&quot;</span><br><span class="line">[feature-vulcan 287773e] add feature vulcan</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 vulcan.py</span><br></pre></td></tr></table></figure><p>切回<code>dev</code>，准备合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p><p><code>git branch -D feature-vulcan</code> 强制删除未合并的分支</p><h4 id="查看远程库的信息，用git-remote"><a href="#查看远程库的信息，用git-remote" class="headerlink" title="查看远程库的信息，用git remote"></a>查看远程库的信息，用<code>git remote</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p><h2 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h2><p><img src="http://s3.51cto.com/wyfs02/M02/12/44/wKiom1MA0v-horoSAAS4v41ef_U068.jpg" alt="img"></p><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。</p><p>许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 <code>master</code> 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 <code>develop</code> 或者 <code>next</code> 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 <code>master</code> 分支了。 这样，在确保这些已完成的特性分支（短期分支，比如之前的 <code>iss53</code> 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。</p><p>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。</p><p><img src="https://git-scm.com/book/en/v2/images/lr-branches-1.png" alt="æ¸è¿ç¨³å®åæ¯ççº¿æ§å¾ã"></p><p>通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。</p><p><img src="https://git-scm.com/book/en/v2/images/lr-branches-2.png" alt="æ¸è¿ç¨³å®åæ¯çå·¥ä½æµï¼âsiloâï¼è§å¾ã"></p><p>你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 <code>proposed</code>（建议） 或 <code>pu: proposed updates</code>（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 <code>next</code> 或者 <code>master</code> 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。</p><h3 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h3><p>你已经在上一节中你创建的 <code>iss53</code> 和 <code>hotfix</code> 特性分支中看到过这种用法。 你在上一节用到的特性分支（<code>iss53</code> 和 <code>hotfix</code> 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。</p><p>考虑这样一个例子，你在 <code>master</code> 分支上工作到 <code>C1</code>，这时为了解决一个问题而新建 <code>iss91</code> 分支，在 <code>iss91</code>分支上工作到 <code>C4</code>，然而对于那个问题你又有了新的想法，于是你再新建一个 <code>iss91v2</code> 分支试图用另一种方法解决那个问题，接着你回到 <code>master</code> 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 <code>C10</code>的时候新建一个 <code>dumbidea</code> 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：</p><p><img src="https://git-scm.com/book/en/v2/images/topic-branches-1.png" alt="æ¥æå¤ä¸ªç¹æ§åæ¯çæäº¤åå²ã"></p><p>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 <code>iss91v2</code> 分支中方案；另外，你将 <code>dumbidea</code> 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 <code>iss91</code> 分支（即丢弃 <code>C5</code> 和 <code>C6</code> 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：</p><p><img src="https://git-scm.com/book/en/v2/images/topic-branches-2.png" alt="åå¹¶äº `dumbidea` å `iss91v2` åæ¯ä¹åçæäº¤åå²ã"></p><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><ul><li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签。</li></ul><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure><p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure><p>可以用命令<code>git tag</code>查看所有标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 add merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line">5dc6824 &amp; simple</span><br><span class="line">14096d0 AND simple</span><br><span class="line">b17d20e branch test</span><br><span class="line">d46f35e remove test.txt</span><br><span class="line">b84166e add test.txt</span><br><span class="line">519219b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line">1094adb append GPL</span><br><span class="line">e475afc add distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 f52c633</span><br></pre></td></tr></table></figure><p>再用命令<code>git tag</code>查看标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure><p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.1</span><br><span class="line">tag v0.1</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 22:48:43 2018 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line"></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p> 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p><h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><p>如果标签打错了，也可以删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br><span class="line">Deleted tag &apos;v0.1&apos; (was f15b0dd)</span><br></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag &apos;v0.9&apos; (was f52c633)</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;git-操作&quot;&gt;&lt;a href=&quot;#git-操作&quot; class=&quot;headerlink&quot; title=&quot;git 操作&quot;&gt;&lt;/a&gt;git 操作&lt;/h2&gt;&lt;p&gt;&lt;code&gt;git checkout -- file&lt;/code&gt;可以丢弃工作区的修改&lt;/p&gt;
&lt;p&gt;命令&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>HTML基本语法</title>
    <link href="http://yoursite.com/2018/12/26/HTML%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/26/HTML笔记/</id>
    <published>2018-12-26T12:45:14.899Z</published>
    <updated>2019-06-17T14:13:53.261Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、HTML"><a href="#一、HTML" class="headerlink" title="一、HTML"></a>一、HTML</h3><p><strong>什是么网站？</strong>     </p><p>​      网站(Website)开始是指在因特网上根据一定的规则，使用HTML等工具制作的用于展示特定内容相关网页的集合</p><p><strong>什么是网页？</strong></p><p>​       网页是一个包含HTML标签的纯文本文件，它可以存放在世界某个角落的某一台计算机中，是超文本标记语言格式文件扩展名为.html。</p><p>文字与图片是构成一个网页的两个最基本的元素。</p><h4 id="1-WEB标准的概念及组成"><a href="#1-WEB标准的概念及组成" class="headerlink" title="1. WEB标准的概念及组成"></a>1. <strong>WEB</strong>标准的概念及组成</h4><p><img src="/2018/12/26/HTML笔记/01.jpg" alt="组成"></p><p><strong>结构：</strong></p><p>HTML- 超文本标记语言 (Hyper Text Markup Language)  </p><p>XHTML-可扩展超文本标记语言(EXtensible HyperText Markup Language)</p><p><strong>表现：</strong></p><p>CSS-层叠样式表（Cascading Style Sheets）</p><p><strong>行为：</strong></p><p>JavaScript-是轻量级的脚本语言</p><h4 id="2-XHTM基本语法"><a href="#2-XHTM基本语法" class="headerlink" title="2. XHTM基本语法"></a>2. XHTM基本语法</h4><h5 id="1、常规标记-双标记"><a href="#1、常规标记-双标记" class="headerlink" title="1、常规标记/双标记"></a>1、常规标记/双标记</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标记</span> 属性=<span class="string">“属性值”</span>  属性=<span class="string">“属性值”</span>&gt;</span><span class="tag">&lt;/<span class="name">标记</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2、空标记-单标记"><a href="#2、空标记-单标记" class="headerlink" title="2、空标记/单标记"></a>2、空标记/单标记</h5><p>&lt;标记 属性=“属性值” /&gt;</p><p><strong>说明：</strong></p><p>​      写在&lt;&gt;中的第一个单词叫做标记、标签、元素名。</p><p>​      标记和属性用空格隔开，属性和属性值用等号连接，属性值必须放在“”号内。</p><p>​      一个标记可以没有属性也可以有多个属性，属性和属性之间不分先后顺序。</p><p>​      空标记没有单独的结束标签，用“/”代替。</p><h4 id="3-HTML5-基本结构"><a href="#3-HTML5-基本结构" class="headerlink" title="3. HTML5 基本结构"></a>3. <strong>HTML5</strong> <strong>基本结构</strong></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span>文档类型声明</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span>说明文档写的是标记语言 ，根标签</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span>文件头部</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span>文件标题（显示在状态栏上的内容）</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span>['metə]</span><br><span class="line">编码格式--meta标记用于定义文件信息，对网页文件进行说明，便于搜索引擎查找设置关键字等  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span>文件主体(所有要写的内容)</span><br></pre></td></tr></table></figure><h4 id="4-标签-lt-gt"><a href="#4-标签-lt-gt" class="headerlink" title="4. 标签(&lt;&gt;)"></a>4. 标签(&lt;&gt;)</h4><h4 id="（1）标签单双分类（根据有无单独的结束标签）："><a href="#（1）标签单双分类（根据有无单独的结束标签）：" class="headerlink" title="（1）标签单双分类（根据有无单独的结束标签）："></a>（1）标签单双分类（根据有无单独的结束标签）：</h4><p>​          <strong>1. 双标签（常规标签）：有单独的结束标签</strong></p><p>​               h1~h6  p b strong i em del sup sub s strike ul ol dl dt dd li a table tr td</p><p>​               div span</p><p>​          <strong>2. 单标签（空标签）：没有单独结束标签</strong></p><p>​               br  hr img ​          </p><h4 id="（2）元素行块分类（根据有没有自占一行进行分类的）："><a href="#（2）元素行块分类（根据有没有自占一行进行分类的）：" class="headerlink" title="（2）元素行块分类（根据有没有自占一行进行分类的）："></a>（2）元素行块分类（根据有没有自占一行进行分类的）：</h4><p>​         <strong>1. 块状元素：自占一行：</strong></p><p>​                h1~h6  p  hr ul ol  dl  dt  dd   li   table div del</p><p>​          <strong>2.行内元素：</strong>宽度跟内容大小一致，并且可以跟其他的行内元素在一行内并列显示的：</p><p>​                 b  strong i em del s strike sup sub br  img a imput buttom span</p><h4 id="（3）标签作用"><a href="#（3）标签作用" class="headerlink" title="（3）标签作用"></a>（3）标签作用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">加粗：</span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>定义粗体的文本<span class="tag">&lt;/<span class="name">b</span>&gt;</span>     //没有语义强调的意思，一般称为物理字体格式化标签</span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>把文本定义为语气更强的强调的内容<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> //有语意 强调</span><br><span class="line">倾斜：</span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>显示斜体文本效果<span class="tag">&lt;/<span class="name">i</span>&gt;</span> //没有语义强调的意思，一般称为物理字体格式化标签</span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>把文本定义为强调的内容<span class="tag">&lt;/<span class="name">em</span>&gt;</span>  //有语意 强调</span><br><span class="line">删除标记：</span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">s</span>&gt;</span>元素，已废弃，用来给文本加删除线(在HTML 4.01中废除)</span><br><span class="line">HTML5 重定义了 <span class="tag">&lt;<span class="name">s</span>&gt;</span> 元素，现在是被用来定义那些不正确的文本。</span><br><span class="line"><span class="tag">&lt;<span class="name">strike</span>&gt;</span> 定义加删除线文本(html5不推荐使用)</span><br><span class="line">sup ：上标文本    sub：下标文本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**注：**语义强调作用的```<span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>```比```<span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>```更容易引起搜索引擎的注意，但是如果只是为了加粗样式，建议在css样式表里面实现  </span><br><span class="line"></span><br><span class="line">**div标记** (division-部分)</span><br><span class="line"></span><br><span class="line">可定义文档中的分区或节,可以把文档分割为独立的、不同的部分</span><br><span class="line"></span><br><span class="line">作用：文档区域，文档布局对象</span><br><span class="line"></span><br><span class="line">**span标记**</span><br><span class="line"></span><br><span class="line">文本结点：用来组合文档中的行内元素</span><br></pre></td></tr></table></figure><h4 id="5-列表（ul-ol-dl）"><a href="#5-列表（ul-ol-dl）" class="headerlink" title="5. 列表（ul, ol,  dl）"></a>5. 列表（ul, ol,  dl）</h4><p>HTML中有<strong>三种列表</strong>，分别是：<strong>无序列表(ul)，有序列表(ol)，自定义列表(dl)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">无序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>--unordered List</span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    … …</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">有序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span>-ordered List</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        … …</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">自定义列表 </span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span>Definition List</span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词<span class="tag">&lt;/<span class="name">dt</span>&gt;</span>Definition term</span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>解释<span class="tag">&lt;/<span class="name">dd</span>&gt;</span>Definition Description</span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6-图片-img"><a href="#6-图片-img" class="headerlink" title="6. 图片(img)"></a>6. <strong>图片</strong>(img)</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"目标文件路径及全称"</span> <span class="attr">alt</span>=<span class="string">"图片替换文本"</span> <span class="attr">title</span>=<span class="string">"图片标题"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>1. src属性：</strong>规定显示图像的 URL</p><p><strong>2. title属性:</strong>  在你鼠标悬停在该图片上时显示一个小提示，鼠标离开就没有了，HTML的绝大多数标签都支持title属性，title属性就是专门做提示信息的;</p><p><strong>3. alt属性:</strong> 规定图像的替代文本。[ælt] olt</p><p>注:所要插入的的图片必须放在站点下</p><p>src==source所用图片的来源(路径)</p><h4 id="7-超链接-a"><a href="#7-超链接-a" class="headerlink" title="7. 超链接(a)"></a>7. <strong>超链接(a)</strong></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">title</span>=<span class="string">""</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span> 链接文本/图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>1. href属性</strong>：设置目标文件路径</p><p><strong>2. title属性</strong>：超链接标题</p><p><strong>3. target属性</strong>：设置超链接的打开方式  [‘tɑrɡɪt]</p><p>   属性值：_blank-新窗口打开    [blæŋk]</p><p>​                 _self-默认的打开方式（本窗口打开） </p><p>​                 _top 在顶层WINDOW对象中打开,一般用于多层框架嵌套的情况<br>​                 _parent 在父窗口打开,一般用于框架内的窗口改变父窗口页面 [‘peər(ə)nt]</p><p>Href== Hypertext Reference的缩写，意思是超文本引用</p><h4 id="8-表单-from"><a href="#8-表单-from" class="headerlink" title="8. 表单(from)"></a>8. 表单(from)</h4><p> 作用：用来收集用户信息的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"test.html"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">name</span>=<span class="string">"myFomr"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">maxlength</span>=<span class="string">"50"</span> <span class="attr">placeholder</span>=<span class="string">"邮箱账号或手机账号"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"userPassword"</span>  <span class="attr">placeholder</span>=<span class="string">"密码"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"reset"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><strong>action属性：</strong>规定当提交表单时，向何处发送表单数据。’ækʃ(ə)n] </li><li><strong>method属性：</strong>规定如何发送表单数据（表单数据发送到 action 属性所规定的页面）浏览器使用method属性设置的方法将表单中的数据传送给服务器进行处理。共有两种方法：POST 方法和 GET 方法。[‘meθəd] </li></ol><h5 id="1-文本框-input"><a href="#1-文本框-input" class="headerlink" title="1.文本框(input)"></a>1.文本框(input)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"uername"</span> <span class="attr">value</span>=<span class="string">"内容"</span> <span class="attr">placeholder</span>=<span class="string">"提示"</span> <span class="attr">maxlength</span>=<span class="string">"20"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol><li><strong>type属性：</strong> 规定 input 元素的类型；（password，email，button）。</li><li><strong>value属性:</strong>  为 input 元素设定值；</li><li><strong>name属性：</strong>规定 input 元素的名称。name 属性用于对提交到服务器后的表单数据进行标识，或者在客户端通过 JavaScript 引用表单数据，只有设置了name属性的表单元素才能在提交表单时传递它们的值。</li><li><p><strong>placeholder属性：</strong>规定帮助用户填写输入字段的提示</p></li><li><p><strong>maxlength属性：</strong>规定输入字段中的字符的最大长度</p></li></ol><h5 id="2-按钮-button"><a href="#2-按钮-button" class="headerlink" title="2. 按钮(button)"></a>2. 按钮(button)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; name=&quot;&quot;  value=&quot;按钮内容&quot; /&gt;</span><br></pre></td></tr></table></figure><p><strong>button和submit的区别：</strong></p><p>submit是提交按钮起到提交信息的作用，button只是一个按钮</p><p>3.</p><h4 id="9-表格-table"><a href="#9-表格-table" class="headerlink" title="9. 表格(table)"></a>9. 表格(table)</h4><p><strong>作用</strong>：显示数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"600px"</span> <span class="attr">height</span>=<span class="string">"400px"</span> <span class="attr">border</span>=<span class="string">"3"</span> <span class="attr">cellspacing</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"4"</span>&gt;</span>第一个单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">rowspan</span>=<span class="string">"4"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"4"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"4"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p><strong>table:</strong>  标签定义HTML表格</p></li><li><p><strong>tr:</strong>  元素定义表格行(table row)</p></li><li><p><strong>td:</strong>  元素定义表格单元(table data数据)</p></li><li><p><strong>border:</strong>  “表格的边框”</p></li><li><p><strong>bordercolor:</strong>“表格边框颜色”</p></li><li><p><strong>cellspacing=0</strong>:  单元格与单元格之间的间距</p></li><li><p><strong>cellpadding:</strong>  单元格与内容之间的空隙</p><p>​     水平对齐方式：align=”left/center/right”;</p><p>​     垂直对齐方式： vertical-align=”top/middle/bottom”;</p><p>​     注：对其方式在td,tr上使用</p></li><li><p><strong>colspan:</strong>  所要合并的单元格的列数” 横向合并;</p></li><li><p><strong>rowspan:</strong>  所要合并单元格的行数” 纵向合并;</p></li></ol><h4 id="10-HTML和XHTML的语法区别"><a href="#10-HTML和XHTML的语法区别" class="headerlink" title="10. HTML和XHTML的语法区别"></a>10. HTML和XHTML的语法区别</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XHTML 要求标签正确嵌套</span><br><span class="line">XHTML 所有标签必须关闭   /</span><br><span class="line">XHTML 区分大小写            </span><br><span class="line">XHTML 属性值要用双引号</span><br><span class="line">XHTML 用 id 属性代替 name 属性</span><br><span class="line">XHTML 特殊字符的处理 &amp;nbsp; &amp;lt; &amp;gt;</span><br></pre></td></tr></table></figure><h3 id="二、CSS基础"><a href="#二、CSS基础" class="headerlink" title="二、CSS基础"></a>二、CSS基础</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">white-space:pre</span><br><span class="line">   nowrap //文本不进行换行知道</span><br><span class="line">text-overflow:  //设置单行文本溢出是否显示省略号</span><br><span class="line">clip 修剪文本</span><br></pre></td></tr></table></figure><p><strong>CSS (cascading style sheets)</strong>WEB标准中的表现标准语言,表现标准语言在网页中主要对网页信息的显示进行控制，简单说就是如何修饰网页的显示样式。<strong>—级联样式表、层叠样式表</strong></p><p><strong>语法：</strong>选择符 { 属性：属性值；属性：属性值 }</p><h4 id="1-样式表分类-内部、外部、内嵌"><a href="#1-样式表分类-内部、外部、内嵌" class="headerlink" title="1.样式表分类(内部、外部、内嵌)"></a>1.样式表分类(内部、外部、内嵌)</h4><h5 id="1-内部样式-style"><a href="#1-内部样式-style" class="headerlink" title="1. 内部样式(style)"></a>1. 内部样式(style)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined">选择符 &#123; 属性：属性值；属性：属性值 &#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-外部样式-link"><a href="#2-外部样式-link" class="headerlink" title="2. 外部样式(link)"></a>2. 外部样式(link)</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel="stylesheet" type="text/css" href="目标文件路径" /&gt;</span><br></pre></td></tr></table></figure><ol><li><p><strong>rel:</strong>   规定当前文档与被连接文档之间的关系 stylesheet: 样式表</p></li><li><p><strong>type: </strong> 规定被链接文档的类型</p></li><li><p><strong>href:</strong>  规定被链接文档的位置</p></li></ol><h5 id="3-外部样式表的导入-2-import"><a href="#3-外部样式表的导入-2-import" class="headerlink" title="3.外部样式表的导入-2(@import)"></a>3.外部样式表的导入-2(@import)</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">@<span class="keyword">import</span> url(目标文件的路径就文件全称);</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>@和import之间没有空格 url和小括号之间也没有空格；必须结尾以分号结束</p><h5 id="3-外部样式对比"><a href="#3-外部样式对比" class="headerlink" title="3.外部样式对比"></a>3.外部样式对比</h5><p>两种导入样式表的方法比较：</p><ul><li>link 属于 HTML 标签，而 @import 是 CSS 提供的。</li><li>页面被加载时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载。</li><li>@import 只在 IE 5 以上才能识别，而 link 是 HTML 标签，无兼容问题。</li><li>link 方式的样式的权重高于 @import 权重。</li></ul><p>一般推荐使用 link 导入样式表的方法，@import 可以作为补充方法使用。</p><h4 id="2-选择器（选择符）"><a href="#2-选择器（选择符）" class="headerlink" title="2. 选择器（选择符）"></a>2. <strong>选择器（选择符）</strong></h4><h5 id="1-元素选择器-类型选择器（标签"><a href="#1-元素选择器-类型选择器（标签" class="headerlink" title="1.  元素选择器/类型选择器（标签 )"></a><strong>1.  元素选择器/类型选择器（标签 )</strong></h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：元素名称&#123;属性：属性值；&#125;</span><br><span class="line">说明：</span><br><span class="line">元素选择符就是以文档语言对象类型作为选择符，即使用结构中元素名称作为选择符。例如body、div、p,img,em,strong,span等。</span><br></pre></td></tr></table></figure><h5 id="2-id选择器"><a href="#2-id选择器" class="headerlink" title="2. id选择器 (#)"></a><strong>2. id选择器</strong> (#)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：#id名&#123; &#125;&#123;属性：属性值;&#125;</span><br><span class="line"> <span class="tag">&lt;<span class="name">标记</span> <span class="attr">id</span>=<span class="string">"名称1   名称2"</span> &gt;</span><span class="tag">&lt;/<span class="name">标记</span>&gt;</span></span><br><span class="line">说明：</span><br><span class="line">1） id属性值，在一个html文档中，必须是唯一的，不可重复，不能用关键字(所有的标记和属性都是关键字)</span><br><span class="line">2）一个id名称只能对应文档中一个具体的元素对象，因为id只能定义页面中某一个唯一的元素对象。</span><br><span class="line">3) 最大的用处：创建网页的外围结构</span><br></pre></td></tr></table></figure><h5 id="3-css选择器"><a href="#3-css选择器" class="headerlink" title="3. css选择器(.)"></a><strong>3. css选择器</strong>(.)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：.class名&#123;属性：属性值;&#125;</span><br><span class="line"> <span class="tag">&lt;<span class="name">标记</span> <span class="attr">class</span>=<span class="string">"名称1   名称2"</span> &gt;</span><span class="tag">&lt;/<span class="name">标记</span>&gt;</span></span><br><span class="line">说明：</span><br><span class="line">1）class选择符更适合定义一类样式； </span><br><span class="line">2） 一个标记可以设置多个class名</span><br><span class="line">3）class名可以重复</span><br><span class="line">4）限定标签类型</span><br></pre></td></tr></table></figure><h5 id="4-群组选择器"><a href="#4-群组选择器" class="headerlink" title="4. 群组选择器(,)"></a>4. 群组选择器(,)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：选择器1，选择器2，选择器3&#123;属性：属性值;&#125;</span><br><span class="line"></span><br><span class="line">说明：当有多个选择符应用相同的样式时，可以将选择符用“，”分隔的方式，合并为一组</span><br></pre></td></tr></table></figure><h5 id="5-后代选择器-包含选择器"><a href="#5-后代选择器-包含选择器" class="headerlink" title="5. 后代选择器/包含选择器"></a><strong>5. 后代选择器/包含选择器</strong></h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：选择器1 选择器2&#123;属性：属性值;&#125;</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">包含选择器选择器1和选择器2用空格隔开，含义就是选择符1中包含的所有选择器2;</span><br></pre></td></tr></table></figure><h5 id="6-子选择器-gt"><a href="#6-子选择器-gt" class="headerlink" title="6. 子选择器(&gt;)"></a><strong>6. 子选择器</strong>(&gt;)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法： 选择器1&gt;选择器2&#123;属性：属性值;&#125;</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">选择符1和选择符2用&gt;链接，选择符2必须是选择符1的子类</span><br></pre></td></tr></table></figure><h5 id="7-伪类选择器-hover"><a href="#7-伪类选择器-hover" class="headerlink" title="7. 伪类选择器(:hover)"></a>7. 伪类选择器(:hover)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法 ：</span><br><span class="line">       :link&#123;属性：属性值;&#125; //超链接的初始状态;</span><br><span class="line">       :visited&#123;属性：属性值;&#125; //超链接被访问后的状态;   ['vɪzɪtɪd] </span><br><span class="line">       :hover&#123;属性：属性值;&#125; //鼠标悬停，即鼠标划过超链接时的状态;</span><br><span class="line">       :active&#123;属性：属性值;&#125; //超链接被激活时的状态，即鼠标按下时超链接的状态; ['æktɪv]</span><br><span class="line">       :focus //元素获得焦点的样式   ['fəʊkəs] </span><br><span class="line">说明：</span><br><span class="line">1）当这4个超链接伪类选择符联合使用时，应注意他们的顺序，正常顺序为：a:link,a:visited,a:hover,a:active,错误的顺序有时会使超链接的样式失效； </span><br><span class="line">2）使用与超链接相关的伪类选择符时，应为a元素定义href属性;</span><br></pre></td></tr></table></figure><h5 id="8-通配符"><a href="#8-通配符" class="headerlink" title="8. 通配符(*)"></a>8. 通配符(*)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：*&#123;属性：属性值；&#125;</span><br><span class="line"></span><br><span class="line">说明：通配选择符的写法是“*”，其含义就是所有元素。</span><br><span class="line">用法：常用来重置样式</span><br><span class="line">全局样式</span><br><span class="line">*&#123;margin:0;padding:0;&#125;</span><br><span class="line">margin:0 auto; 让子元素相对父元素水平居中显示</span><br></pre></td></tr></table></figure><h4 id="3-选择器的权重"><a href="#3-选择器的权重" class="headerlink" title="3. 选择器的权重"></a><strong>3. 选择器的权重</strong></h4><p><img src="/2018/12/26/HTML笔记/1553140597918.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">内联  id  class 标签</span><br><span class="line"> 1    0   0     0</span><br><span class="line"># css中用四位数字表示权重，权重的表达方式如：0，0，0，0</span><br><span class="line"># id 0100</span><br><span class="line"># class选择器  （伪类选择符 :focus,:hover以及&lt;a&gt;:link） 0010 </span><br><span class="line"># 属性选择符的权重为     0010</span><br><span class="line"># 元素a 伪元素 :before、:after  0001</span><br><span class="line"># 后代选择符：1 2 =  1 + 2 </span><br><span class="line"># 子选择器 1 &gt; 2 = 1 + 2</span><br><span class="line"># 群组看选择符类型</span><br><span class="line"># *&#123;&#125;(通配符) 0 </span><br><span class="line"># 继承 0</span><br><span class="line"># 权重相同时，根据书写顺序而定，后书写的会把县书写的覆盖掉，会显示后书写的代码效果</span><br></pre></td></tr></table></figure><h4 id="4-CSS特性：-层叠性和继承性"><a href="#4-CSS特性：-层叠性和继承性" class="headerlink" title="4. CSS特性：(层叠性和继承性)"></a>4. CSS特性：(<strong>层叠性</strong>和<strong>继承性</strong>)</h4><p><strong>层叠性：</strong>一个元素可能同时被多个css选择器选中，每个选择器都有一些css规则，这就是层叠。</p><p>CSS的处理原则是：</p><p>1）如果多个选择器定义的规则不发生冲突，则元素将应用所有选择器定义的样式。</p><p>2）如果多个选择器定义的规则发生了冲突，则CSS按选择器的特殊性(权重)让元素应用特殊性(权重)高的选择器定义的样式。</p><p><strong>继承</strong>：所谓继承，就是父元素的规则也会适用于子元素。比如给body设置为color:Red;那么他内部的元素如果没有其他的规则设置，也都会变成红色。继承得来的规则没有特殊性。</p><p>多数边框类属性，比如Padding（补白），Margin（边界），背景和边框的属性都是不能继承的。(border属性是用来设置元素的边框的，它没有继承性)</p><p>块状、内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font-family、font-size、font-style、font-weight、text-decoration、text-transform.</p><p>块状元素可继承：text-indent和text-align。</p><p>列表元素可继承： list-style、list-style-type、list-style-position、list-style-image。</p><p>表格元素可继承：border-collapse。</p><p>css层叠性：<br>​       使用不同的选择符作用于同一个对象，每个选择符都有一些css声明/规则<br>​       如果规则没有发生冲突，这些样式都可以被执行<br>​       如果规则发生了冲突，根据选择符的权重/特殊性而定，执行权重高的选择符设置的样式<br>​       权重：<br>​          内联：1000<br>​          id：100<br>​          class 伪类：10<br>​          类型：1<br>​          群组：根据具体对象而定<br>​          包含：将使用的选择符相加=和<br>​          子：子结合符&gt; = 0  其他选择符相加=和<br>​          通配父，继承的样式 子结合符：权重为0<br>​           </p><p>   css继承性： 子类可以继承父类的css样式<br>​          可以利用css继承，节省代码量，提高代码的可读性</p><h4 id="5-颜色-color"><a href="#5-颜色-color" class="headerlink" title="5. 颜色(color)"></a>5. 颜色(color)</h4><p>可以用以下方法来规定 CSS 中的颜色：</p><ul><li><p>十六进制色 ：十六进制颜色是这样规定的：#RRGGBB，其中的 RR（红色）、GG（绿色）、BB（蓝色）十六进制整数规定了颜色的成分。所有值必须介于 0 与 FF 之间。举例说，#0000ff 值显示为蓝色，这是因为蓝色成分被设置为最高值（ff），而其他成分被设置为 0。</p></li><li><p>RGB 颜色：RGB 颜色值是这样规定的：rgb(red, green, blue)。每个参数 (red、green 以及 blue) 定义颜色的强度，可以是介于 0 与 255 之间的整数，或者是百分比值（从 0% 到 100%）。举例说，rgb(0,0,255) 值显示为蓝色，这是因为 blue 参数被设置为最高值（255），而其他被设置为 0。</p></li><li><p>RGBA 颜色：颜色值是 RGB 颜色值的扩展，带有一个 alpha 通道 - 它规定了对象的不透明度。</p><p>RGBA 颜色值是这样规定的：rgba(red, green, blue, alpha)。alpha 参数是介于 0.0（完全透明）与 1.0（完全不透明）的数字。</p></li><li><p>HSL 颜色：颜色值是这样规定的：hsl(hue, saturation, lightness)。</p><p>Hue 是色盘上的度数（从 0 到 360） - 0 (或 360) 是红色，120 是绿色，240 是蓝色。Saturation 是百分比值；0% 意味着灰色，而 100% 是全彩。Lightness 同样是百分比值；0% 是黑色，100% 是白色。</p></li><li><p>HSLA 颜色 ：颜色值是这样规定的：hsla(hue, saturation, lightness, alpha)，其中的 alpha 参数定义不透明度。alpha 参数是介于 0.0（完全透明）与 1.0（完全不透明）的数字。</p></li><li><p>预定义/跨浏览器颜色名</p></li></ul><h4 id="6-浮动-float"><a href="#6-浮动-float" class="headerlink" title="6. 浮动(float)"></a>6. 浮动(float)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">margin:0 auto/margin:auto;放置在一个标签上，可以使此标签在父元素中水平居中</span><br><span class="line">float:left/right/none</span><br><span class="line">   A. 给元素添加浮动之后，会脱离正常文档流</span><br><span class="line">   B. 子元素浮动了，父元素在没有设置高度的情况下，会高度塌陷</span><br><span class="line">   C. 给元素添加浮动之后，元素会产生块级框，而不论本身是什么元素类型</span><br><span class="line">块状元素：</span><br><span class="line">         默认：</span><br><span class="line">             width:auto  -  与父元素同宽</span><br><span class="line">             height:auto -  与内容的高度相同</span><br><span class="line">         加浮动之后：</span><br><span class="line">             width:auto  -  与内容同宽</span><br><span class="line">             height:auto -  与内容的高度相同  </span><br><span class="line">         设置具体的宽度和高度,设置的属性为多少，显示的大小就是多少</span><br><span class="line">             width:300px;height:300px    </span><br><span class="line">    行内元素：</span><br><span class="line">         默认：不能设置宽度和高度，设置了显示无效</span><br><span class="line">               所以行内元素的显示大小，根据内容多少而定</span><br><span class="line">         加浮动之后：变成块状元素；    </span><br><span class="line">width:auto; =不设宽度</span><br><span class="line">  A. 对于块状元素而言,浏览器自动计算，，会与父元素同宽，</span><br><span class="line">  B.  对于块状元素而言，如果盒子浮动了，宽度与内容同宽</span><br><span class="line">  C. 如果给盒子设置具体的width:value，设置的多少，显示多宽</span><br><span class="line">2. 浮动对盒子宽度的影响：     </span><br><span class="line">          </span><br><span class="line">          标签的宽度为：width:auto; </span><br><span class="line">  A. 对于块状元素而言,浏览器自动计算，，会与父元素同宽，</span><br><span class="line">  B.  对于块状元素而言，如果盒子浮动了，宽度与内容同宽</span><br><span class="line">   </span><br><span class="line">          盒子的宽度为：width:value；</span><br><span class="line">          如果给盒子设置具体的width:value，设置的多少，显示多宽           </span><br><span class="line">         3. 浮动对盒子文档流的影响</span><br><span class="line">          添加了浮动的盒子，会脱离正常文档流；</span><br><span class="line">        </span><br><span class="line">         4. 父元素的高度塌陷</span><br><span class="line">         父元素在没有设置具体高度的情况下，子元素全部浮动了，父元素的高度为0；</span><br><span class="line">         </span><br><span class="line">        5. 浮动的图片应用：以往这个属性总应用于图像，使文本围绕在图像周围</span><br><span class="line">        </span><br><span class="line">        6. 浮动元素会生成一个块级框，而不论它本身是何种元素。</span><br><span class="line">   width:height固定宽度时，除了padding 不管里面有多少内容 width height不变 </span><br><span class="line">   解决flaot父元素高度塌陷</span><br><span class="line">   1.overflow:</span><br></pre></td></tr></table></figure><p> 块状元素，当width的属性值为auto/没写时，浏览器自动计算宽度，宽度是与父元素同宽</p><p>​           宽度：width:auto;</p><p>​           高度：400px</p><p>​           行内元素：不能设置宽度和高度，设置无效</p><h4 id="7-background"><a href="#7-background" class="headerlink" title="7. background"></a>7. background</h4><p>background-image:url(../img/mao.gif);<br>background-repeat:no-repeat;<br>background-position:100px 100px;  起始点时左上角   [pəˈzɪʃn]</p><p>background-position:100% 100%     起始点时中心<br>background-position:center;<br>background-position:227px 99px;</p><p> 背景颜色：background-color<br>​       背景图片：background-image<br>​       背景重复：background-repeat [rɪ’piːt] 重复<br>​       背景定位：background-position  [pəˈzɪʃən] 位置<br>​       背景状态：background-attachment  [ə’tætʃm(ə)nt] e ta xu ment<br>​       background：color url repeat position attachment; [‘kʌlə(r)]</p><p>单位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">绝对长度单位、相对长度单位</span><br><span class="line">   绝对：cm mm in 等等</span><br><span class="line">   相对：</span><br><span class="line">        ex - 字符x的高度   1ex=x的高度 </span><br><span class="line">        em - 当前元素/父元素的文本大小  1em=font-size </span><br><span class="line">        px - 设备上能显示的最小单位 css相对长度单位</span><br></pre></td></tr></table></figure><h4 id="8-文本-font-fɒnt"><a href="#8-文本-font-fɒnt" class="headerlink" title="8. 文本(font)[fɒnt]"></a>8. 文本(font)[fɒnt]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">font-size: &#123;      none:[nʌn]  norm:[nɔːm] </span><br><span class="line">    px：设定固定值 </span><br><span class="line">    %:基于父元素的一个百分比值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">font-family: &#123;//规定元素的字体系列</span><br><span class="line">    (1)此属性设置几个字体名称作为一种&quot;后备&quot;机制，如果浏览器不支持第一种字体，将尝试下一种字体。</span><br><span class="line">    (2) 如果字体系列的名称超过一个字，它必须用引号，如Font Family：&quot;宋体&quot;&quot;Times New Roman&quot;。</span><br><span class="line">    (3) 多个字体系列是用一个逗号分隔指明;</span><br><span class="line">&#125;</span><br><span class="line">font-weight:设置显示元素的文本中所用的字体加粗 &#123;  [weɪt]</span><br><span class="line">    1-500=normal ,600-900=bold [bəʊld] </span><br><span class="line">    bolder 更粗</span><br><span class="line">&#125;</span><br><span class="line">font-style: //设置文本倾斜&#123;</span><br><span class="line">italic [ɪ&apos;tælɪk] </span><br><span class="line">oblique  [ə&apos;bliːk]</span><br><span class="line">&#125;</span><br><span class="line">text-indent&#123;</span><br><span class="line">%</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">text-align:设置文本水平对齐&#123;  [ə&apos;laɪn] </span><br><span class="line">    left right center [ˈsentə(r)] justify </span><br><span class="line">    行内元素和文本是一样的   文本和行内元素都有作用对 块元素水平居中(0 auto)</span><br><span class="line">&#125;</span><br><span class="line">text-decoration: 文本修饰 [dekə&apos;reɪʃ(ə)n]&#123; // [dekə&apos;reɪʃ(ə)n] </span><br><span class="line">underline:文本下一条线 [ʌndə&apos;laɪn] </span><br><span class="line">overline: 文本上一条线</span><br><span class="line">line-through: 穿过文本一条线 [θruː]</span><br><span class="line">&#125;</span><br><span class="line">text-transform：&#123;  //设置文本大小写  [træns&apos;fɔrm] </span><br><span class="line"> capitalize: [&apos;kæpɪtəlaɪz] 文本单词开头大写</span><br><span class="line">     uppercase: [&apos;ʌpə&apos;keɪs]  文本定义大小</span><br><span class="line">     lowercase: [ləʊə&apos;keɪs] 文本定义小写</span><br><span class="line">&#125;</span><br><span class="line">letter-spacing: &#123; //定义字符之间的间隔</span><br><span class="line">+ -  </span><br><span class="line">对汉字起作用</span><br><span class="line">&#125;</span><br><span class="line">word-spacing: &#123; //定义单词与单词之间的间隔z</span><br><span class="line">只对单词有作用（字母和汉字无效）</span><br><span class="line">&#125;</span><br><span class="line">顺序: font-style | font-variant(小体大写字母) | font-weight | font-size / line-height | font-family </span><br><span class="line">font:[italic] [bold] 20px/&#123;100px] &apos;楷体&apos;;</span><br></pre></td></tr></table></figure><h4 id="9-行高-line-hight"><a href="#9-行高-line-hight" class="headerlink" title="9. 行高(line-hight)"></a>9. 行高(line-hight)</h4><p>文本行的基线间的距离</p><p><img src="/2018/12/26/HTML笔记/1553307042913.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">默认字体16px =&gt; lin-hight=21px;</span><br><span class="line">line-lenght:number 此数字会与当前字体尺寸相乘来设置行间距(2=2em,1em=元素文本大小)</span><br><span class="line">%：基于当前字体尺寸的百分比(100%=当前尺寸)</span><br><span class="line">10px</span><br><span class="line">16px</span><br><span class="line">10px</span><br><span class="line"></span><br><span class="line">10px</span><br><span class="line">16px</span><br><span class="line">10px</span><br><span class="line">文本在行高内垂直居中</span><br><span class="line">应用户单行文本 控制文本的垂直居中 应用于多行文本控制多行文本的间距</span><br></pre></td></tr></table></figure><p><img src="/2018/12/26/HTML笔记/1553306925881.png" alt=""></p><h4 id="10-边框-border"><a href="#10-边框-border" class="headerlink" title="10. 边框(border)"></a>10. 边框(border)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border-color:设置边框颜色 red green blue;上  左右 下</span><br><span class="line">border-weight: </span><br><span class="line">bordrer-style: 设置边框类型 dotted(点状) dashed(虚线) solid(实线) double(双线)</span><br><span class="line">border- : 元素的所有边框设置宽度，或者单独地为各边边框设置宽度。</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">outline****：（轮廓）**是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用，轮廓线不会占据空间，也不一定是矩形。</span><br><span class="line"></span><br><span class="line">outline-width</span><br><span class="line"></span><br><span class="line">outline-style</span><br><span class="line"></span><br><span class="line">outline-color</span><br><span class="line"></span><br><span class="line">outline:简写</span><br><span class="line"></span><br><span class="line">border跟outline的区别：</span><br><span class="line"></span><br><span class="line">1. border可应用于几乎所有有形的html元素，而outline是针对链接、表单控件和ImageMap等元素设计</span><br><span class="line">2. border占据空间，outline不占据空间</span><br></pre></td></tr></table></figure><h4 id="11-列表-list"><a href="#11-列表-list" class="headerlink" title="11. 列表(list)"></a>11. 列表(list)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list-style：none;去掉列表符号</span><br><span class="line">//定义列表符号的位置 [pəˈzɪʃən]</span><br><span class="line">list-style-position:inside（列表项目放置在文本以内，且环绕文本根据标记对齐） outside(默认)</span><br><span class="line">list-style-image: 设置图片作为列表符号</span><br><span class="line">list-type: 设置列表项标记的类型</span><br><span class="line">disc(实心圆)square(实心方块)decimal(数字)</span><br><span class="line">[dɪsk]    [skweə]          [&apos;desɪm(ə)l]</span><br></pre></td></tr></table></figure><h4 id="12-盒模型"><a href="#12-盒模型" class="headerlink" title="12.盒模型"></a>12.盒模型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 占据的宽度：width+左右padding+左右border+左右margin</span><br><span class="line"> 占据的高度：height+上下padding+上下border+上下margin</span><br><span class="line"> 1.     盒模型的四个组成部分：</span><br><span class="line">   content[kən&apos;tent] padding border margin</span><br><span class="line"></span><br><span class="line">padding: 调整内容在盒子中的位置关系</span><br><span class="line">1. 需要添加到父元素上</span><br><span class="line">2. 不允许是负边距值</span><br><span class="line">3. 可以把内容撑大 </span><br><span class="line">4. 行内可以设置padding,但是显示有问题(上下显示有问题，左右没问题)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1）. 将图片放在超链接中，在ie的低版本浏览器中，会自动解释出边框；</span><br><span class="line">    解决方法:img&#123;border:0/none&#125;</span><br><span class="line">2）. 将图片放在行内元素中，在行内元素没有设置高度的基础上，会将行内元素在图片自身高度的基础上，撑大3~5px</span><br><span class="line">        A. img&#123;display:block&#125;</span><br><span class="line">        B.  div&#123;font-size:0</span><br><span class="line">        c. overflow:hidden;</span><br><span class="line">        d.float:left;&#125;”。如果要实现图文混排，这种方法是很好的选择</span><br><span class="line">5. display:设置元素的显示类型</span><br><span class="line">        block：将元素设置为块状元素 </span><br><span class="line">        图片将盒子撑大3~5px的原因：、</span><br><span class="line">        因为图片是行内元素，跟匿名文本之间的对齐方式是基线对齐，在文本基线的下行距</span><br><span class="line">        会</span><br></pre></td></tr></table></figure><h5 id="外边距-margin"><a href="#外边距-margin" class="headerlink" title="外边距(margin)"></a>外边距(margin)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% 属性总结</span><br><span class="line">text-indent:参照父元素的宽度计算</span><br><span class="line">padding margin :基于父元素的宽度计算</span><br><span class="line">width height: 父元素的width,height</span><br><span class="line">line-height：参照元素的font-size</span><br><span class="line">background-size: 参照父元素 你   </span><br><span class="line">absolut:left/right/top/bottom</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">负值属性</span><br><span class="line">text-indent -负值</span><br><span class="line">background-postion: 负值</span><br><span class="line">margin</span><br><span class="line">absolut:left/right/top/bottom</span><br><span class="line">z-index: 0=auto</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">简写属性</span><br><span class="line">background:</span><br><span class="line">border:</span><br><span class="line">font:</span><br><span class="line">list-style: type position</span><br><span class="line">list-style: url position</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">margin：auto - 浏览器计算  --具体valuepx/em/cm/mm  %</span><br><span class="line">padding：不能为auto ，---具体valuepx/em/cm/mm  %</span><br><span class="line">  1. 给子元素设置margin-top时，会影响到父元素一起向下移动；</span><br><span class="line">      A. 给父元素后者子元素添加浮动</span><br><span class="line">      B. 给父元素加边框</span><br><span class="line">      C. overflow:hidden;</span><br><span class="line">   2. 两个盒子之间的margin区域是可以重叠的（没有浮动的情况下）；</span><br><span class="line">   3. 两个浮动盒子之间的margin区域是不重叠的；</span><br><span class="line">   4. margin可以设置负值，显示方向和正值完全相反；</span><br><span class="line">   5. 行内元素可以执行margin，但是上下显示  不正确，左右显示正确(padding一样)</span><br></pre></td></tr></table></figure><h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">overflow: //主要应用 设置溢出盒子的显示方式</span><br><span class="line">visible:默认溢出，正常显示  [ˈvɪzəbl]</span><br><span class="line">hidden:溢出以后，隐藏 [&apos;hɪdn]</span><br><span class="line">scroll: 显示滚动条 [skrəʊl] </span><br><span class="line">auto: 如果溢出显示滚动条，如果不溢出就不显示滚动条</span><br><span class="line">其他应用：</span><br><span class="line">A，给父元素添加overflow:hidden 可以解决高度塌陷</span><br><span class="line">B. 给父元素添加overflow:hidden  解决给子元素设置maring-top 影响父元素一起向上移动</span><br><span class="line">overflow-x</span><br><span class="line">overflow-y</span><br><span class="line">省略</span><br><span class="line">text-overflow: clip //直接裁剪</span><br><span class="line">ellipsis //显示省略号</span><br><span class="line">string  新增的，浏览器不支持</span><br><span class="line">width:设置官渡</span><br><span class="line">overflow: hidden </span><br><span class="line">white-space:nowrap //强制让文本在一行内显示</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">块级格式化上下文 BFC</span><br><span class="line">其实归根结底，这里的浮动没有清除，只是因为overflow属性的值是hidden的时候会形成一个BFC，而BFC就是一个隔离的渲染区域，因此浮动造成的高崩塌会导致对外部布局的影响，为了消除这种不益的表现，计算高度的时候浮动元素也计算进去了。</span><br><span class="line"></span><br><span class="line">需要保证满足下面至少一条就会触发BFC：</span><br><span class="line"></span><br><span class="line">根元素body；</span><br><span class="line">设置了float值不为none的元素；</span><br><span class="line">设置了overflow属性不为visible的元素；</span><br><span class="line">设置了属性position不为relative和static的元素；</span><br><span class="line">设置了display的值为flex、table-cell、table-caption和inline-block中的任何一个的元素。</span><br><span class="line">可以看出来，就是一个比较独立的块，因为是一个独立的环境，在开发时候适度使用会有效降低开发和维护难度。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">大致可以归纳为三个方面：独立性、垂直分布规则和水平分布规则。</span><br><span class="line"></span><br><span class="line">独立性：BFC是页面上一个隔离的容器，和外面的关系是不会互相影响，对浮动而言也是，不会和浮动元素发生重叠，高也和上面提到的一样不会崩塌；</span><br><span class="line">垂直分布规则：BFC的内部里面的一个个盒子在垂直方向一个接着一个排放，位置由margin决定，两个相邻的盒子margin会发生重叠；</span><br><span class="line">水平分布规则：BFC里面的盒子的左外边缘和包含块的左边相接触，简单的理解就是水平方向不会发生margin重叠。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">要实现溢出时产生省略号的效果还需定义：</span><br><span class="line"> </span><br><span class="line">1）、容器宽度：width：value；</span><br><span class="line">2）、强制文本在一行内显示:white-space：nowrap;</span><br><span class="line">3）、溢出内容为隐藏：overflow：hidden；</span><br><span class="line">4）、溢出文本显示省略号：text-overflow：ellipsis; [ɪ&apos;lɪpsɪs]</span><br></pre></td></tr></table></figure><h4 id="元素类型"><a href="#元素类型" class="headerlink" title="元素类型"></a>元素类型</h4><ol><li>块状元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 1. display: //设置盒子的显示类型</span><br><span class="line">          none:此标签在浏览器中不显示</span><br><span class="line">          block：此标签显示为块状元素-div p ul ol dl dt dd h1 form h1~h6</span><br><span class="line">          inline:此标签显示为行内元素-a span b strong i em img br sup sub</span><br><span class="line">          inline-block:此标签显示为行内块元素 - input; 行内</span><br><span class="line">          list-item:此标签显示为列表项标签 - li</span><br><span class="line">          table:此标签显示为块级表格标签 - table</span><br><span class="line"></span><br><span class="line">        元素类型：</span><br><span class="line">         块状级元素：display:block list-item table</span><br><span class="line">         行内级元素：display:inline inline-block inline-table;</span><br><span class="line"></span><br><span class="line">2. 块状元素的特征：  </span><br><span class="line">   (1) 可以设置宽度和高度</span><br><span class="line">   (2) 自占一行</span><br><span class="line">   (3) 作为容器使用，作为盒子使用，可以正确解释4盒模型中的属性；</span><br><span class="line">   (4) 给盒子添加浮动之后，盒子在没有设置宽度和高度的情况下，在没有内容的情况下，宽度，高度为0；</span><br><span class="line"></span><br><span class="line">行内设置 a img span i em b strong br sub sup del s</span><br><span class="line">3. 行内元素的特征：</span><br><span class="line">   A。不能设置宽度和高度</span><br><span class="line">   B。可以和其他行内元素在一行内显示</span><br><span class="line">   C。行内元素也符合盒模型的特征，也能执行盒模型中的规则，但是margin，padding，border的上下显示不正确，左右显示正常；</span><br><span class="line">   D。盒子的大小有内容而定，如果给行内元素添加浮动之后，会生成块级框，变成块状元素</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.行内元素</span><br><span class="line">2.行内元素1</span><br><span class="line">ver-align练习</span><br><span class="line">置换元素和飞置换元素</span><br><span class="line">小米商城</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">行内元素垂直方向的对齐方式：默认基线对齐</span><br><span class="line">1.给元素添加float 摆脱基线对齐 基线(小写字母x ,s,a 的下断沿的先)</span><br><span class="line">2.行内元素在开发工具书写时，如果进行换行和空格</span><br><span class="line">解决：A. 写在一行，不进行换行</span><br><span class="line"> B. 给所有的行内元素添加float</span><br><span class="line"> c. 给行内元素的父元素设置 font-size: 0; 当时行内元素有继承 font-size:0; 影响元素内的文本大小为0； 解决：给行内元素再设置font-size</span><br></pre></td></tr></table></figure><h5 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vertical-align  设置元素的垂直的对齐方式</span><br><span class="line">baseline: 默认 元素放在父元素的基线上(父元素的基线就是文本内容的基线)</span><br><span class="line">top</span><br><span class="line">bottom</span><br><span class="line">middle 垂直居中对齐</span><br><span class="line">sub: 垂直对齐文本的下标</span><br><span class="line">super:</span><br><span class="line">在没有边距没区别</span><br><span class="line">%：当前line-hight(开发不推荐) 允许负值 正值：向上移动当前行高的大小</span><br><span class="line">       负值：向下移动当前行高的大小</span><br></pre></td></tr></table></figure><h4 id="置换元素"><a href="#置换元素" class="headerlink" title="置换元素"></a>置换元素</h4><p><img src="/2018/12/26/HTML笔记/1553755206346.png" alt=""></p><p><img src="/2018/12/26/HTML笔记/1553755238537.png" alt=""></p><h5 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postion: </span><br><span class="line">absolute 绝对定位 相当于static 定位以为的第一个父元素定位</span><br><span class="line">body--position:static div没设就是static</span><br><span class="line">hmlt---是绝对定为诶元素最大的参照物-默认</span><br><span class="line">fixed</span><br></pre></td></tr></table></figure><h5 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">1. 行内元素在垂直方向的对其方式：默认是基线对其</span><br><span class="line">   基线：参照css核心属性的笔记-line-height</span><br><span class="line">         小写的英文字母x,s,a的下断沿的线</span><br><span class="line"></span><br><span class="line">2. 行内元素在开发工具中书写时，如果进行换行或者空格，在浏览器中，两个标签之间有一个空格；</span><br><span class="line"></span><br><span class="line">3. 去掉空格：</span><br><span class="line">  A. 写在一行中，不进行换行；</span><br><span class="line">  B. 给所有的行内元素添加浮动；</span><br><span class="line">  C. 给行内元素的父元素设置font-size：0；可以解决这个问题，但是行内元素会继承font-size:0;造成元素内的文本大小为0；</span><br><span class="line">       解决：给行内元素单独再设置文本大小</span><br><span class="line">  D. 都都转为inline-block</span><br><span class="line"></span><br><span class="line">4. vertical-align： 设置元素的垂直对齐方式</span><br><span class="line">   注意：用在行内元素上面才有效</span><br><span class="line"></span><br><span class="line">5. 图片将盒子撑大3~5px的原因</span><br><span class="line">   因为图片是行内元素，跟空白字节之间的对其方式是基线对其，在文本基线的下面有下行间距，下行间距会将盒子撑大3~5px； </span><br><span class="line">   方法：img&#123;display：block&#125;</span><br><span class="line">         div&#123;font-size:0;&#125;</span><br><span class="line">         img&#123;vertical-align:只要不是baseline ，推荐使用top，middle，bottom&#125;  </span><br><span class="line"></span><br><span class="line">6. </span><br><span class="line">    静态定位的特点：</span><br><span class="line">    position:static; 静态定位-没有特殊的定位效果，正常在文档流中显示</span><br><span class="line">  </span><br><span class="line">    绝对定位的使用和特点：</span><br><span class="line">        (1) : position:absolute-绝对定位;</span><br><span class="line">        (2) : 根据参照物进行定位（参照物==包含块：有除了static以外的定位设置，并且是定位元素的父元素）</span><br><span class="line">        (3) : left right top bottom 确定元素坐标的位置</span><br><span class="line">        (4) : left right top bottom:属性值可以是正值也可以是负值,属性值可以为%，px</span><br><span class="line">        (5) 我们可以改变包含块的对象，不一定非是html</span><br><span class="line">              只要是父元素，只要设置了其他的定位设置（除static以为），都可以作为定位元素的参照物</span><br><span class="line">        (6) 绝对定位会使元素脱离正常文档流；            </span><br><span class="line"></span><br><span class="line">   body: ----默认是position:static;</span><br><span class="line">   html:----是绝对定位元素最大的参照物，具有除静态定位以外的其他定位设置；</span><br><span class="line"></span><br><span class="line">    相对定位的使用和特点：</span><br><span class="line">        （1）相对定位不会使元素脱离正常文档流；   </span><br><span class="line"></span><br><span class="line">7. 元素在垂直方向上的层叠顺序</span><br><span class="line">    (1) 如果元素没有设置css表现，按正常的书写，后书写的显示在上面</span><br><span class="line">    (2) 如果元素设置定位（除static之外），层叠顺序比没有设置定位的元素高；</span><br><span class="line">    (3) 如果两个盒子都设置了定位，后书写的比较高</span><br><span class="line">    (4) 可以设置z-index属性，来提高元素的层叠顺序；</span><br><span class="line">      z-index: auto/number;</span><br><span class="line">      值越大，层叠顺序越高</span><br><span class="line">      值越小，层叠顺序越低</span><br><span class="line">      z-index属性必须结合position属性使用才有效（属性值除static以外）；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">重点：       给盒子添加浮动，会脱离文档流</span><br><span class="line">            给行内元素添加浮动，产生块级框，变成块状元素</span><br><span class="line">            给盒子添加绝对定位，会脱离文档流</span><br><span class="line">            给行内元素添加绝对定位，产生块级框，变成块状元素</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">百度二级菜单</span><br><span class="line">相对定位</span><br><span class="line">相框练习 ？</span><br><span class="line">包含快</span><br><span class="line">相对定位练习</span><br><span class="line">固定定位√</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">锚点-透明度</span><br><span class="line">fash -</span><br><span class="line"></span><br><span class="line">千峰2二级菜单</span><br><span class="line">高宽自适应</span><br><span class="line">伪元素类型</span><br><span class="line">图片</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p 标签不能 嵌套div</span><br><span class="line">a 标签不能嵌套 a标签</span><br><span class="line">h1 标题不能嵌套 标题</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSS设置行内元素和块级元素的水平居中、垂直居中</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">根据自身在浏览器中的正常位置进行坐标偏移</span><br><span class="line">相对定位不会让元素脱离正常文档流</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visibility: hidden 当前</span><br></pre></td></tr></table></figure><p>伪元素选择符</p><p><img src="/2018/12/26/HTML笔记/TIM截图20190330151005.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div:after&#123; //在被选元素的内容后面插入内容</span><br><span class="line">content:&quot;xxxs&quot;</span><br><span class="line">&#125;</span><br><span class="line">::before //在内容的前面插入内容</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">清除浮动带来的影响</span><br><span class="line">clear:lefr/right/both/none</span><br><span class="line">1.给浮动元素的下方添加空的div，并且</span><br><span class="line">2.伪元素清除浮动 div:after&#123;</span><br><span class="line">content:&quot;&quot;;</span><br><span class="line">display: block;</span><br><span class="line">height:0;</span><br><span class="line">clear:both;</span><br><span class="line">overflow:hidden;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">3.给父元素的</span><br><span class="line">overflwo</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">width:auto/100%</span><br><span class="line">height:auto/高度不写</span><br><span class="line">div&#123;height:100%&#125; html,body&#123;height:100&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4.1</span><br><span class="line">回顾</span><br><span class="line">百度新闻</span><br><span class="line">ie6!</span><br><span class="line">属性选择器</span><br><span class="line">精灵图 减少对服务器的请求次数，提高页面的加载速度</span><br><span class="line">整合图片来减少图片的体积</span><br><span class="line">精灵图的应用</span><br><span class="line">精灵图应用3</span><br><span class="line">浏览器兼容</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4.1</span><br><span class="line">_background :ie6</span><br><span class="line">*background: ie6 7</span><br></pre></td></tr></table></figure><p>兼容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ie6 height=min-height height</span><br><span class="line">widht=min-width width</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">图片热点链接</span><br><span class="line">img：usemap</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">  1. 盒模型</span><br><span class="line">  content(width,height) + border + padding + margin </span><br><span class="line">  </span><br><span class="line">  2. overflow使用-设置溢出容器的内容，如何显示</span><br><span class="line">         visible:表示溢出正常显示  [ˈvɪzəbl]</span><br><span class="line">         hidden：表示溢出容器的内容，被裁剪掉</span><br><span class="line">         scroll：让容器显示滚动条，查看其余的内容  [skrəʊl]</span><br><span class="line">         auto：如果溢出显示滚动条，不溢出就不显示</span><br><span class="line">     省略号的设置：</span><br><span class="line">        text-overflow：clip - 直接裁剪</span><br><span class="line">                       ellipsis- 显示省略号</span><br><span class="line">                       string - 新增的，浏览器不支持</span><br><span class="line">        width:设置宽度   overflow：hidden-溢出隐藏   white-space：nowrap 强制让文本在一行内显示；  </span><br><span class="line"> 3. 元素类型</span><br><span class="line">    类型分类： 块状元素  行内（内联）元素</span><br><span class="line">       块状元素：对应的标签：li ul ol dt dd form table h1~h6 div p </span><br><span class="line">                特征:(1) 能设置宽度和高度（2）自占一行 （3）作为容器使用，能正常解释盒模型的属性 （4）盒子在浏览器中以块的形式显示，宽度默认是auto与父元素同宽，高度根据内容而定，没有内容宽度为0</span><br><span class="line">       行内元素：对应标签： a img i em b strong span br sup sub del s input</span><br><span class="line">                特征：（1）不能设置宽度和高度  （2）在一行内显示（3）也可以遵循盒模型的规则，但是个别显示不正确，border，padding，margin上下显示不正确，左右显示正常 （4）盒子的大小有内容而定，如果添加了浮动，盒子变成块状元素</span><br><span class="line">    display：设置盒子的显示类型</span><br><span class="line">        none：让盒子消失不可见</span><br><span class="line">        block：快装</span><br><span class="line">        inline：行内</span><br><span class="line">        inline-block：行内块元素</span><br><span class="line">        list-item：显示列表项 -li</span><br><span class="line">        table：显示为块状表格</span><br><span class="line"> 4. 定位：</span><br><span class="line">    position：</span><br><span class="line">       absolute：绝对定位</span><br><span class="line">        （1） 会使元素脱离正常文档流</span><br><span class="line">        （2） 根据包含块进行定位</span><br><span class="line">             包含块：离绝对定位元素最近的并且有定位设置的父元素，定位设置不能是默认值-static</span><br><span class="line">        （3） 根据left right top bottom</span><br><span class="line">       相对定位：relative  [&apos;relətɪv] </span><br><span class="line">        （1） 不会使元素脱离正常文档流</span><br><span class="line">        （2） 根据自身在正常文档流中的位置进行坐标的偏移</span><br><span class="line">        （3） 根据left right top bottom    [&apos;bɒtəm]                             </span><br><span class="line">        fixed：固定定位   [fɪkst] </span><br><span class="line">        （1） 会使元素脱离正常文档流</span><br><span class="line">        （2） 根据窗口进行定位</span><br><span class="line">        （3） 根据left right top bottom</span><br><span class="line">        stiky：粘性定位</span><br><span class="line">         （1）在窗口范围内，定位效果像相对定位，当移动浏览器滚动条，盒子距离窗口的位置=设置的像素数时，盒子位置不发生改变，像固定定位 </span><br><span class="line">        static：默认的定位效果，没有任务特殊的定位，在正常文档流中显示</span><br><span class="line">    z-index：设置元素的堆叠顺序；</span><br><span class="line">        auto：跟父元素的堆叠顺序相同</span><br><span class="line">        number：数字越大，顺序越高，数字越小，顺序越低</span><br><span class="line">     注意：必须结合position：absolute，relative，fixed，不能是static</span><br><span class="line">    包含块的概念：为绝对定位的元素提供坐标偏移的参照物      </span><br><span class="line">    设置元素为包含块：给元素添加position：absolute，relative ，fixed 不能是static（推荐使用相对定位，因为不会使用元素脱离正常文档流）</span><br><span class="line"></span><br><span class="line">    锚点：（1）a href = “#锚点名”</span><br><span class="line">               在同一页面的不同位置进行跳转</span><br><span class="line">          （2） a href =“文件路径#锚点名”</span><br><span class="line">               跳转到另外一个页面的锚点元素所在的位置</span><br><span class="line">    overflow-x，y：设置某个方向上内容溢出如何显示，属性值跟overflow相同</span><br><span class="line"></span><br><span class="line">5. 宽高自适应：</span><br><span class="line">      概念，优势</span><br><span class="line">      伪元素选择符：5个 after[&apos;ɑːftə]</span><br><span class="line">      元素的高度如何自适应窗口的高度</span><br><span class="line">      清除浮动的三种方式：3种 overflow:hidden </span><br><span class="line">         [ə(ʊ)&apos;pæsɪtɪ]</span><br><span class="line">      隐藏元素：display：none    opacity：0-1     visibility：visible hidden</span><br><span class="line">      一组属性；min/max-width/height ming max</span><br><span class="line"></span><br><span class="line">6. 属性选择符：权重是10；      </span><br><span class="line"></span><br><span class="line">7. 图片整合的概念（精灵图 图片精灵）</span><br><span class="line">8. 图片整合的优势（1）减少请求次数，提高加载速度  （2）减小图片的体积</span><br><span class="line">9. 兼容</span><br><span class="line">   </span><br><span class="line">   五大浏览器采用的都是单内核，而随着浏览器的发展现在也出现了双内核。360浏览器、QQ浏览器都是采用双内核。 </span><br><span class="line"></span><br><span class="line">      1、IE浏览器内核：Trident内核，也是俗称的IE内核； </span><br><span class="line">      2、Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核； </span><br><span class="line">      3、Firefox浏览器内核：Gecko内核，俗称Firefox内核； </span><br><span class="line">      4、Safari浏览器内核：Webkit内核； </span><br><span class="line">      5、Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是Blink内核； </span><br><span class="line">      6、360浏览器、猎豹浏览器内核：IE+Chrome双内核； </span><br><span class="line">      7、搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）； </span><br><span class="line">      8、百度浏览器、世界之窗内核：IE内核； </span><br><span class="line">      9、2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核；</span><br><span class="line"> </span><br><span class="line"> 常见的兼容问题：</span><br><span class="line">    双倍边界</span><br><span class="line">    默认高度</span><br><span class="line">    图片间隙</span><br><span class="line">    cursor属性：设置鼠标指针的形状；</span><br><span class="line">    png：ie支持png8位图片的背景透明，不支持其他的位数；</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> &lt;table&gt;</span><br><span class="line">        &lt;caption&gt;定义表格的标题&lt;/caption&gt;</span><br><span class="line">        &lt;!-- &lt;col span=&quot;1&quot; class=&quot;col1&quot;&gt;</span><br><span class="line">        &lt;col span=&quot;2&quot; class=&quot;col2&quot;&gt; --&gt;</span><br><span class="line">        &lt;colgroup span=&quot;2&quot; class=&quot;col1&quot;&gt;&lt;/colgroup&gt;</span><br><span class="line">        &lt;colgroup span=&quot;1&quot; class=&quot;col2&quot;&gt;&lt;/colgroup&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">                &lt;th&gt;年龄&lt;/th&gt;</span><br><span class="line">                &lt;th&gt;性别&lt;/th&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">   </span><br><span class="line">        &lt;/tbody&gt;</span><br><span class="line">        &lt;tfoot&gt;</span><br><span class="line">            &lt;tr&gt;</span><br><span class="line">                &lt;td&gt;1&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;2&lt;/td&gt;</span><br><span class="line">                &lt;td&gt;3&lt;/td&gt;</span><br><span class="line">            &lt;/tr&gt;</span><br><span class="line">        &lt;/tfoot&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h3><p>特点：<br>添加 语意标签   canvas画布 多媒体交互标签 (video src )  mack(高亮显示文字)</p><ul><li>骨架更简单</li></ul><p><img src="/2018/12/26/HTML笔记/TIM截图20190403093923.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header nav section aside(侧边栏) footer figcaption</span><br></pre></td></tr></table></figure><h5 id="1-解构标签"><a href="#1-解构标签" class="headerlink" title="1. 解构标签"></a>1. 解构标签</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. header 某个区块的头部信息</span><br><span class="line">2.</span><br></pre></td></tr></table></figure><p><img src="/2018/12/26/HTML笔记/ie条件注释.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2018/12/26/HTML笔记/h5提升.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2018/12/26/HTML笔记/vido属性.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2018/12/26/HTML笔记/媒体标签.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2018/12/26/HTML笔记/type.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mack(高亮显示文字)</p><p>menu</p><p>表单标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">email  </span><br><span class="line">url 检测地址</span><br><span class="line">number 专门用来输入数字</span><br><span class="line">max min </span><br><span class="line">step:默认1</span><br><span class="line">range: </span><br><span class="line">max min step </span><br><span class="line">search: 比文本框多了x</span><br><span class="line">color: 调色板</span><br><span class="line">tel: 和文本框没区别 兼容性很大  </span><br><span class="line"></span><br><span class="line">date：</span><br><span class="line">month  年月</span><br><span class="line">week  年周</span><br><span class="line">time 小时分钟</span><br><span class="line">datetime 没显示 世界统一时</span><br><span class="line">datetime-local   北京时间</span><br><span class="line">output：输出框</span><br><span class="line"></span><br><span class="line">属性</span><br><span class="line">required:内容空白不能提交</span><br><span class="line">placeholder:</span><br><span class="line">pattern:正则表达式</span><br><span class="line">autofocus: 页面刚加载自动获得焦点</span><br><span class="line">list:（datalistId）与datalist标签&gt;option 配合使用 类似select</span><br><span class="line">autocomplete:自动完成功能-name历史记录</span><br><span class="line">min max step</span><br><span class="line">novalidate: 规定在提交表单，取消验证内容</span><br><span class="line">multiple: 输入可以输入多个内容，用 ， 分开</span><br><span class="line">form(fomrId值):控件链接idfrom</span><br></pre></td></tr></table></figure><p>浏览器模式</p><p>标准模式：ie高版本浏览器 chrome safari </p><p>怪异模式：ie6 ie7</p><p>什么情况下会在怪异模式下解析：</p><p>​    - 文档声明不正确，或者不存在</p><p>​        -h5中只有一种文档声明 &lt;!DOCTYPE html&gt;</p><p>​    html4中文不能中</p><ol><li><p>过渡版本</p><p>标签的使用：不能使用框架标签</p><ol start="2"><li><p>严格版本</p><p>不能使用弃用标签，不能使用表现性标签，不能使用框架标签</p></li></ol></li></ol><p>盒模型在不同浏览器中的解释</p><h4 id="css3"><a href="#css3" class="headerlink" title="css3"></a>css3</h4><p>渐进增强</p><p>优雅降级</p><p><img src="/2018/12/26/HTML笔记/css3.png" alt=""></p><p>基本选选择符</p><p>层级选择符</p><p>属性选择符：</p><p>​    input[type=”e”]//e开头</p><p>​    input[type=”$e”]//以e结尾的input标签</p><p>​    input[ytpe=”*=e”] //包含e的input标签</p><p>伪元素选择器</p><p>::first-letter</p><p>::firset-line</p><p>::before</p><p>::after<br>::selection </p><p>伪类选择器</p><p>:target  //目标伪类选择器：某个目标元素被触发的时候</p><p>​    锚点</p><p>e:not(f) 否定伪类选择器</p><p>结构伪类选择器</p><p>e:mpty  // ：当元素内容为空时</p><p>结构</p><p>:root  // 给根元素(html)添加有</p><p>:nth-child(n)  匹配父元素中的第n个子元素</p><p>​    n:表达式：2n+1=odd, 2n=even</p><p>​    数字 表达式 关键字  n</p><p>:nth-last(n) </p><p>:nth-of-type(n)://先看类型在看个数</p><p>:only-child :看个数再看来下</p><p>:only-of-type //来类型再看数字</p><p>:first-child </p><p>:last-child </p><p>:first-of-type</p><p>:last-of-type</p><p>UI元素状态伪类选择器</p><p>:hover</p><p>:active</p><p>:focus</p><p>E:disabled //设置该元素处于不可用状态的样式</p><p>E:enabled //设置元素处于可用状态的样式</p><p>E:read-only //元素处于只读状态</p><p>E:read-write //</p><p>E:checked  //表单中radio or checkbox 处于选中状态</p><p>E:default  //页面打开时 默认处于选中状态 （一直执行）</p><p>E:selection //指定当元素处于选中状态时的样式</p><p>E:indeterminate //当页面打开时，如果一组单选框都没有选中才执行，如果用户选中了一个，则样式取消</p><p>valid</p><p>invalid</p><h6 id="内核前缀"><a href="#内核前缀" class="headerlink" title="内核前缀"></a>内核前缀</h6><p>Trident内核    -ms -ms-border-radius</p><p>Gecko内核： -moz (火狐)</p><p>Presto内核     -o</p><p>Webkit内核:    -webkit</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">作业</span><br><span class="line">css3文本属性</span><br><span class="line">边框属性</span><br><span class="line">练习</span><br><span class="line">背景</span><br><span class="line">背景</span><br></pre></td></tr></table></figure><h6 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h6><p>中文默认自动换行，字母</p><p>word-break: </p><p>​    norm:默认</p><p>​    break-all：允许单词内换行</p><p>​    keep-all: - 字符才换行</p><p>word-wrap: 允许长单词 or url 内部进行换行</p><p>text-shadow: 向文本添加应用</p><p>​               3px 3px  模糊 color,-3px -5px 模糊 color</p><h6 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h6><p>border-radius: 20px 30px;  //对角线角   圆角边框</p><p>border-image: //边框图片 </p><p>border-top-left-radius:40px 90px 水平半径 垂直半径</p><p>border-image-source    </p><p>&amp;&amp;  border-image-slice: //裁剪</p><p>border-image-repeat: 图片平铺</p><p>border-image-width: 图片边框宽度</p><p>border-image-outset</p><p>brder-colors  //设置边框颜色</p><p>box-shadow:  //设置盒子的阴影</p><p>​    h-shadow: 0 </p><p>​    v-shadow ：0</p><p>​    blur： 模糊距离</p><p>​    []: 阴影大小 默认和盒子一样大</p><p>​    color</p><p>​    inset: 内阴影</p><p>指定元素的的宽度与高度的计算方法</p><p>box-sizing: content-box //width =盒子内容区域大小  =标准模式</p><p>​            border-box // 边框盒子大小 （content+padding+border) =怪异模式</p><p><img src="/2018/12/26/HTML笔记/微信图片_20190405175634.png" alt=""></p><h5 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h5><p>background 属性提升</p><p>background-size: width height </p><p>​    %：盒子宽度的%  盒子的%</p><p>​    number:   会改变比例</p><p>​    cover:  等比例改变宽高，能覆盖 可能超出盒子</p><p>​    contain: 等比例改变宽高，按最小的放大</p><p>默认情况下：</p><p>如果盒子有内边距，背景图从内边距的padding开始显示</p><p>如果没有padding,背景图从内容盒子的</p><p>background-origin  // 规定图片的显示区域</p><p>​    border-box //背景图从边框盒子开始显示</p><p>​    padding-box //默认效果</p><p>​    conente-box //从内容位置开始显示 没有padding</p><p>background-clip //背景图片的裁剪区域</p><p>​    border-box 背景裁剪到边框盒</p><p>​    padding-box  //</p><p>​    content-box  背景图裁剪到内容区可见</p><p>​    text</p><p>-webkit-text-fill-color: //文本填充颜色</p><p>​    </p><p>颜色</p><p>rgba()</p><p>hsl(色调，饱和度，亮度) {0,360} {0,100%} {0,100%}</p><p>hsal</p><p>transparent</p><h5 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h5><p>.ttf  eot woff otf svg </p><p>定义字体 </p><p>font-face规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字体定义规则</span><br><span class="line">@font-face&#123;</span><br><span class="line">定义字体名称</span><br><span class="line">font-family: &quot;myfont&quot;</span><br><span class="line">字体路径</span><br><span class="line">src:url(../font)</span><br><span class="line">&#125;</span><br><span class="line">font-family: &quot;myfont&quot;</span><br></pre></td></tr></table></figure><p>作业 名鞋侧边栏</p><p>​    淘宝工具栏</p><h5 id="css3弹性盒"><a href="#css3弹性盒" class="headerlink" title="css3弹性盒"></a>css3弹性盒</h5><p>新的布局模式-flexible box布局，即收缩布局盒模型(弹性盒布局)</p><p><img src="/2018/12/26/HTML笔记/css3弹性.jpg" alt=""></p><p>​    <img src="/2018/12/26/HTML笔记/css3啊.jpg" alt=""></p><p>​    3个版本 旧版本 混合版本 新版本</p><p>容器上：</p><p>display   //设置元素为弹性盒</p><p>​    flex/line-flex  //块状弹性盒</p><p>​        使内部元素获得弹性布局效果 ，原本垂直</p><p>  块级弹性盒：</p><p>​      父元素如果是弹性盒子，子元素作为弹性项目，在没有设置width 的情况下，width 与内容铜矿，</p><p>​     子元素作为弹性项目，在主轴方向方向从主轴起点上一次排序</p><p>  子元素在没有设置height的情况下，height会拉伸与父元素同高 ，如果设置了多高就多高</p><p>行内弹性盒：</p><p>​    </p><p>flex-direction  //规定灵活项目的方向</p><p>​    row:默认值，灵活的项目水平显示</p><p>​    row-reverse: 与fow相同，但是以相反的顺序排列</p><p>​    column: 灵活项目将垂直显示</p><p>​        column-reverse: 主轴方向垂直，但是以相反的顺序排列</p><p>flex-wrap  // 用于设置</p><p>​    nowrap: 默认 不换行不换列 改变width height</p><p>​    wrap :  规定灵活项目必要时换行，换列</p><p>​    wrap-reverse </p><p>简写：</p><p>flex-flow：flex-flow: column-reverse wrap-reverse </p><p>justify-content  //设置子元素在主轴(水平方向的/垂直方向)上的对齐方式</p><p>​    flex-start //项目位于主轴的开头、</p><p>​    flex-end   //项目位于主轴的结尾</p><p>​    enter  //位于主轴的中心</p><p>​    space-between // 如果父元素的width大于子元素，留下的空白平均分给两个子元素之间</p><p>​    space-around: //平均分别分给每个元素的两边</p><p>align-items //设置子元素在侧轴方向的对齐方式<br>​    stretch ： 拉伸到适应容器 父元素没有height </p><p>​    center: 元素位于容器中心</p><p>​    flex-start : 侧轴的起点开始</p><p>​    flex-end: </p><p>​    baseline </p><p><img src="/2018/12/26/HTML笔记/111.jpg" alt=""></p><p>align-content // 设置多行子元素在侧轴上的对齐方式（多行时，属性才生效)</p><p>​     stretch:   //元素拉伸以适应容器</p><p>​    center //元素位于容器的中心</p><p>​     flex-start: //侧轴起点位置</p><p>​    flex-end //侧轴重点</p><p>​    space-between: //</p><p>​    space-around:</p><p><img src="/2018/12/26/HTML笔记/222.jpg" alt=""></p><h5 id="设置子元素"><a href="#设置子元素" class="headerlink" title="设置子元素"></a>设置子元素</h5><p>align-self: 属性定位</p><p>​    auto</p><p>​    center //</p><p><img src="/2018/12/26/HTML笔记/333.jpg" alt=""></p><p>弹性盒1</p><p>弹性盒练习</p><p>flex-grow: 用于每个收缩项目的增长比率</p><p>​      默认0  </p><p>​    1： </p><p>flex-shrink 设置每个伸缩项目的收缩比率</p><p>​    子元素width相同时 才</p><p><img src="/2018/12/26/HTML笔记/444.jpg" alt=""></p><p>flex-basis 伸缩的基准值</p><p><img src="/2018/12/26/HTML笔记/5551.jpg" alt=""></p><p>有width  产考width 没有  </p><p>order  </p><p><img src="/2018/12/26/HTML笔记/666.jpg" alt=""></p><p>order: 0 (默认) 越大越靠前</p><p>flex:  0 1 200px </p><p>增长   伸缩1=等比伸缩  初始大小=基准值</p><p>第二种应</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用于对</p><p><img src="/2018/12/26/HTML笔记/888.jpg" alt=""></p><p>扩展应用</p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1554522573513.png" alt="1554522573513"></p><h5 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h5><p>rem: 永远相对于根元素(html)的文本大小单位</p><h5 id="视口（viewport）"><a href="#视口（viewport）" class="headerlink" title="视口（viewport）"></a>视口（viewport）</h5><p>视口：初始视口980  考虑移动端访问pc端 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-diwh，initial=scale=&quot;1.0&gt; </span><br><span class="line">      视口的width=设备屏幕的width  （1 = 按页面实际尺寸显示 无缩放）</span><br><span class="line"> 2. minimum-scale 设定最小做小比例</span><br><span class="line">  (0-10，1=禁止用户缩小至实际尺寸之下)</span><br><span class="line"> 3. maximum-scale 这顶最大缩放比例</span><br><span class="line">  (0-10，1=禁止用户放大至实际尺寸之上)</span><br><span class="line"> 4. user-scalable=&quot;no/yes&quot; </span><br><span class="line"> (在实际尺寸之上用户是否可也缩放)</span><br></pre></td></tr></table></figure><h5 id="Meta"><a href="#Meta" class="headerlink" title="Meta"></a>Meta</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&gt;</span><br></pre></td></tr></table></figure><p>ch 数字0 的宽度</p><p>rem : thml</p><p>vw </p><p>vh</p><p>%</p><p>pt </p><p>绝对单位</p><p>ios开发基本党委</p><p>dp 安装开发的基准单温</p><p>sp 文字</p><h4 id="css3媒体查询"><a href="#css3媒体查询" class="headerlink" title="css3媒体查询"></a>css3媒体查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@media meatype and|not|only ((条件表达式)&#123;</span><br><span class="line"></span><br><span class="line">screen</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">css3添加媒体属性</span><br><span class="line">only： 限定某种设备执行媒体查询 </span><br><span class="line">ccs2：媒体只能查询设备，没有条件</span><br></pre></td></tr></table></figure><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555054616210.png" alt="1555054616210"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555054647288.png" alt="1555054647288"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">移动端适配 改变html-font-size</span><br><span class="line">vw</span><br><span class="line">js </span><br><span class="line">@media 不精细,避免</span><br></pre></td></tr></table></figure><h4 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h4><p><strong>常见布局方案</strong></p><p><strong>固定布局</strong>：以像素作为页面的基本单位，不管设备屏幕及浏览器宽度，只设计一套尺寸；</p><p><strong>可切换的固定布局：</strong>同样以像素作为页面单位，参考主流设备尺寸，设计几套不同宽度的布局。通过识别的屏幕尺寸或浏览器宽度，选择最合适的那套宽度布局；</p><p><strong>弹性布局：</strong>以百分比作为页面的基本单位，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果；</p><p><strong>混合布局</strong>：同弹性布局类似，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果；只是混合像素、和百分比两种单位作为页面单位。</p><p><strong>布局响应</strong>：对页面进行响应式的设计实现，需要对相同内容进行不同宽度的布局设计，有两种方式：pc优先（从pc端开始向下设计）；<br>​                      移动优先（从移动端向上设计）；</p><p>无论基于那种模式的设计，要兼容所有设备，布局响应时不可避免地需要对模块布局做一些变化（发生布局改变的临界点称之为断点），</p><p>概念：更具</p><h4 id="背景渐变"><a href="#背景渐变" class="headerlink" title="背景渐变"></a>背景渐变</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: linear-gradient(direction, color-stop1,color-stop2,)</span><br></pre></td></tr></table></figure><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555126218097.png" alt="1555126218097"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555126652880.png" alt="1555126652880"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555126744875.png" alt="1555126744875"></p><p>镜像渐变</p><p>​     <img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555126909155.png" alt="1555126909155"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background: radial-gradient(position, shape sie, start-color,last-color)</span><br></pre></td></tr></table></figure><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555127185237.png" alt="1555127185237"></p><p>css </p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555137448187.png" alt="1555137448187"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555138414306.png" alt="1555138414306"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555138702195.png" alt="1555138702195"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555138985633.png" alt="1555138985633"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555139267804.png" alt="1555139267804"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555139712078.png" alt="1555139712078"></p><h5 id="css过度"><a href="#css过度" class="headerlink" title="css过度"></a>css过度</h5><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555139779249.png" alt="1555139779249"></p><p>transition-du</p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555139860281.png" alt="1555139860281"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555140390518.png" alt="1555140390518"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555140491367.png" alt="1555140491367"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555143236841.png" alt="1555143236841"></p><p>3d</p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555207405767.png" alt="1555207405767"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555207416547.png" alt="1555207416547"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555207697670.png" alt="1555207697670"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555209247178.png" alt="1555209247178"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zuoye</span><br><span class="line">3d2</span><br><span class="line">动画</span><br><span class="line">运动</span><br><span class="line">运动练习</span><br><span class="line">bfc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@keyframes 定义动画规则</span><br><span class="line">from to</span><br><span class="line">@keyframes animationname&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555222060912.png" alt="1555222060912"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555222221819.png" alt="1555222221819"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555222584362.png" alt="1555222584362"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555223068351.png" alt="1555223068351"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animation： move 4s linear 00是2 both</span><br></pre></td></tr></table></figure><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555227118740.png" alt="1555227118740"></p><p><img src="/2018/12/26/HTML笔记/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555229342189.png" alt="1555229342189"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、HTML&quot;&gt;&lt;a href=&quot;#一、HTML&quot; class=&quot;headerlink&quot; title=&quot;一、HTML&quot;&gt;&lt;/a&gt;一、HTML&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;什是么网站？&lt;/strong&gt;     &lt;/p&gt;
&lt;p&gt;​      网站(Website)
      
    
    </summary>
    
      <category term="HTML" scheme="http://yoursite.com/categories/HTML/"/>
    
    
      <category term="语法" scheme="http://yoursite.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>优雅的使用 Subline Text3</title>
    <link href="http://yoursite.com/2018/12/25/sbulime/"/>
    <id>http://yoursite.com/2018/12/25/sbulime/</id>
    <published>2018-12-25T11:44:56.643Z</published>
    <updated>2019-06-17T14:14:28.814Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-插件下载安装方法"><a href="#1-插件下载安装方法" class="headerlink" title="1.插件下载安装方法"></a>1.插件下载安装方法</h3><p>快捷键<code>ctrl + shift + p</code>, 打开sublime命令工具，输入 <code>Install Package</code></p><h3 id="2-插件"><a href="#2-插件" class="headerlink" title="2.插件"></a>2.插件</h3><h5 id="1-格式化代码：html-css-js-Prettify"><a href="#1-格式化代码：html-css-js-Prettify" class="headerlink" title="1.格式化代码：html/css/js Prettify"></a>1.格式化代码：html/css/js Prettify</h5><p> 格式化代码快捷键   <code>Ctrl + Shift + H</code></p><h5 id="2-vue语法高亮：-vue-syntax-highlight"><a href="#2-vue语法高亮：-vue-syntax-highlight" class="headerlink" title="2.vue语法高亮： vue-syntax-highlight"></a>2.vue语法高亮： <strong>vue-syntax-highlight</strong></h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-插件下载安装方法&quot;&gt;&lt;a href=&quot;#1-插件下载安装方法&quot; class=&quot;headerlink&quot; title=&quot;1.插件下载安装方法&quot;&gt;&lt;/a&gt;1.插件下载安装方法&lt;/h3&gt;&lt;p&gt;快捷键&lt;code&gt;ctrl + shift + p&lt;/code&gt;, 打开su
      
    
    </summary>
    
      <category term="IDE工具" scheme="http://yoursite.com/categories/IDE%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="sublime，快捷键" scheme="http://yoursite.com/tags/sublime%EF%BC%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + github 搭建个人博客</title>
    <link href="http://yoursite.com/2018/12/25/Hexo%20+%20github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/12/25/Hexo + github 搭建个人博客/</id>
    <published>2018-12-25T07:56:57.878Z</published>
    <updated>2019-03-19T05:53:38.873Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-博客维护"><a href="#1-博客维护" class="headerlink" title="1.博客维护"></a>1.博客维护</h3><h5 id="1-发布文章"><a href="#1-发布文章" class="headerlink" title="1.发布文章"></a>1.发布文章</h5><p>在站点文件夹中打开 git bash，输入如下命令部署和发布文章:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><p><strong>建议</strong>：在使用 <code>hexo g</code> 部署之后，可以先使用 <code>hexo s</code> 运行本地站点，然后在浏览器输入地址 <a href="http://lacolhost:4000/" target="_blank" rel="noopener">http://lacolhost:4000/</a> 查看运行结果，检查无误后再使用 <code>hexo d</code> 发布</p><h5 id="2-新建博客时添加对应的图片文件夹"><a href="#2-新建博客时添加对应的图片文件夹" class="headerlink" title="2.新建博客时添加对应的图片文件夹"></a>2.新建博客时添加对应的图片文件夹</h5><p>将 站点配置文件 中的 post_asset_folde 选项的值设置为 true</p><p>在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件</p><p>这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p><p>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <img src="/2018/12/25/Hexo + github 搭建个人博客/title/example.PNG" alt="示例图片" title="示例图片"> 添加图片</p><h5 id="3-模板设置"><a href="#3-模板设置" class="headerlink" title="3.模板设置"></a>3.模板设置</h5><p>当我们使用命令 <code>hexo new &quot;title&quot;</code> 创建文章时，Hexo 会根据 <code>/scaffolds/post.md</code> 对新文章进行初始化</p><p>换言之，<code>/scaffolds/post.md</code> 就是新文章的 <strong>模板</strong>，所以我们可以修改它来适应自己的写作习惯</p><p>在每篇利用 Hexo 创建的文章的开头，都会有对文章进行说明的文字，叫做 <strong>文章头部</strong></p><p>文章的头部除了可以设置文章标题、发布日期等基础信息外，还可以为文章添加标签、分类等</p><p>一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: Title</span><br><span class="line">date: YYYY-MM-DD HH:MM:SS</span><br><span class="line">tags: [tag1, tag2, ...]</span><br><span class="line">categories: category</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：属性和属性值之间必须有一个空格，否则会解析错误</p><h3 id="2-搭建博客"><a href="#2-搭建博客" class="headerlink" title="2.搭建博客"></a>2.搭建博客</h3><h4 id="1-搭建github博客"><a href="#1-搭建github博客" class="headerlink" title="1.搭建github博客"></a>1.搭建github博客</h4><p>1.github新建博客文件，库名要所有者名字一样，如：<strong>meijuna.github.io</strong> 的格式</p><p>2.Settings =&gt; 选择一个主题保存 就可以访问 meijuna.github.io 了 </p><h4 id="2-Hexo搭建本地博客"><a href="#2-Hexo搭建本地博客" class="headerlink" title="2.Hexo搭建本地博客"></a>2.Hexo搭建本地博客</h4><p><strong>hexo命令</strong></p><p>hexo s(server)  –&gt; 启动本地服务</p><p>hexo  clean –&gt; 清除缓存</p><p>hexo g (generate) –&gt; 创建网页</p><p>hexo d (deploy) –&gt; 同步到github</p><p>1.安装node.js + git </p><p>以Windows环境安装node.js为例，首先登录<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js官网</a>，选择适合自己的版本进行下载，然后进行安装。</p><p>登录<a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a>选择版本进行下载，基本一路<strong>next</strong>下去即可轻松完成安装。</p><p>2.首先在本地磁盘中建立一个Hexo文件夹用于存储本地文件(做本地文件保存以及测试使用)</p><p>3.下载Hexo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>4.初始化博客空间，生成博客运作所需要的文件，接下来安装依赖包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>5.同步Github,允许公共访问</p><p>1.首先找到我们的博客仓库，并拷贝仓库地址：git clone 主题仓库地址 放到 <strong>themes</strong> 文件夹下</p><p>2.打开_config.yml 文件配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">    type: git</span><br><span class="line">    repo: https://github.com/meijuna/meijuna.github.io</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><p>3.最后执行控制台命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git —save //安装部署插件</span><br><span class="line"></span><br><span class="line">hexo d //部署到github</span><br></pre></td></tr></table></figure><p>就用 meijuna.github.io 访问博客了</p><h4 id="2-Hexo-的主题美化"><a href="#2-Hexo-的主题美化" class="headerlink" title="2.Hexo 的主题美化"></a>2.Hexo 的主题美化</h4><p>1.到 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo主题官网</a> 下载主题放到 <strong>themes</strong> 文件夹</p><p>2.配置根目录的 _config.yml 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: pure //选择下载主体文件的名字</span><br></pre></td></tr></table></figure><p>3.hexo clean -&gt; hexo g -d 看效果</p><p>4.具体主题美化看下载的主题文档</p><h4 id="3-在Hexo博客上添加可爱的Live-2D模型"><a href="#3-在Hexo博客上添加可爱的Live-2D模型" class="headerlink" title="3.在Hexo博客上添加可爱的Live 2D模型"></a>3.在Hexo博客上添加可爱的Live 2D模型</h4><p>首先，安装npm包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>然后在hexo的根目录配置文件<code>_config.yml</code>中添加如下配置，详细配置可以参考<a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">文档</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-koharu</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br></pre></td></tr></table></figure><p>然后下载模型，模型名称可以到<a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">这里</a>参考，一些模型的预览可以在<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install live2d-widget-model-koharu</span><br></pre></td></tr></table></figure><p>下载完之后，在 Hexo 根目录中新建文件夹 live2d_models，然后在node_modules文件夹中找到刚刚下载的live2d模型，将其复制到 live2d_models 中，然后编辑<code>_config.ym</code>l配置文件中的model.use项，将其修改为live2d_models文件夹中的模型文件夹名称。</p><p>一切就绪之后，用<code>hexo server</code>命令启动服务器，大功告成！</p><h4 id="4-阿里云解析域名"><a href="#4-阿里云解析域名" class="headerlink" title="4.阿里云解析域名"></a>4.阿里云解析域名</h4><p>1.<a href="https://dns.console.aliyun.com/?spm=5176.100251.111252.14.7e144f15jRG8mz&amp;accounttraceid=9e23cc47-c762-4c2b-af1a-0eac8eaaed46#/dns/domainList" target="_blank" rel="noopener">阿里云</a>购买域名  解析 -&gt; 添加记录  -&gt; A 类型  -&gt; www -&gt; 默认 -&gt; ping  meijuna.github.io 地址的值 -&gt;ttl 10</p><p>3.在根目录下的 source 文件夹 创建 CNAME 文件 ，内容为 <a href="http://www.meijuna.top" target="_blank" rel="noopener">www.meijuna.top</a> </p><h4 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h4><h5 id="1-hexo中添加图片的方法"><a href="#1-hexo中添加图片的方法" class="headerlink" title="1.hexo中添加图片的方法"></a>1.hexo中添加图片的方法</h5><p>1.下载插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save // hexo n &quot;文件&quot; 自动生成相同文件名的文件夹存放图片</span><br></pre></td></tr></table></figure><p>2.设置站点配置_config.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-博客维护&quot;&gt;&lt;a href=&quot;#1-博客维护&quot; class=&quot;headerlink&quot; title=&quot;1.博客维护&quot;&gt;&lt;/a&gt;1.博客维护&lt;/h3&gt;&lt;h5 id=&quot;1-发布文章&quot;&gt;&lt;a href=&quot;#1-发布文章&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Live 2D模型" scheme="http://yoursite.com/tags/Live-2D%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="博客，阿里云" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%EF%BC%8C%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Mackdown 基本语法</title>
    <link href="http://yoursite.com/2018/12/24/Mackdown%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2018/12/24/Mackdown语法/</id>
    <published>2018-12-24T01:35:48.462Z</published>
    <updated>2019-06-17T14:14:12.790Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Markdown-简介"><a href="#1、Markdown-简介" class="headerlink" title="1、Markdown 简介"></a>1、Markdown 简介</h3><p>但是，在我们正式写下第一个文字前，我们需要了解一下究竟什么是 Markdown？</p><blockquote><p>Markdown 是一种可以使用普通文本编辑器编写的 标记语言，通过简单的 标记语法，它可以使普通文本内容具有一定的格式</p></blockquote><p>基于 Markdown 语法的简洁性，它已经成为目前世界上最流行的用于书写博客的语言</p><h3 id="2、Markdown-语法"><a href="#2、Markdown-语法" class="headerlink" title="2、Markdown 语法"></a>2、Markdown 语法</h3><p>2、Markdown 语法<br>在编写 Markdown 时，博主强烈的推荐给大家一款简洁易用的 Markdown 编辑器 —— Typora</p><p>按照官方的说法就是 简单而强大，它不仅支持原生的语法，也支持对应的快捷键，更重要的是它还可以 实时预览</p><p>这里附上 Typora 的下载地址：<a href="https://www.typora.io/，有兴趣的朋友可以下载来试试" target="_blank" rel="noopener">https://www.typora.io/，有兴趣的朋友可以下载来试试</a></p><p>好，下面开始进入正题，介绍一些常用的 Markdown 语法</p><h4 id="（1）标题"><a href="#（1）标题" class="headerlink" title="（1）标题"></a>（1）标题</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line"></span><br><span class="line">## 二级标题</span><br><span class="line"></span><br><span class="line">### 三级标题</span><br><span class="line"></span><br><span class="line">#### 四级标题</span><br><span class="line"></span><br><span class="line">##### 五级标题</span><br><span class="line"></span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>Typora 快捷键：</p><p>Ctrl+1：一级标题</p><p>Ctrl+2：二级标题</p><p>Ctrl+3：三级标题</p><p>Ctrl+4：四级标题</p><p>Ctrl+5：五级标题</p><p>Ctrl+6 ：六级标题</p><p>Ctrl+0：段落</p><h4 id="（2）粗体、斜体、删除线和下划线"><a href="#（2）粗体、斜体、删除线和下划线" class="headerlink" title="（2）粗体、斜体、删除线和下划线"></a>（2）粗体、斜体、删除线和下划线</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>Typora 快捷键：</p><p>Ctrl+I：斜体</p><p>Ctrl+B：粗体</p><p>Ctrl+U：下划线</p><p>Alt+Shift+5：删除线</p><h4 id="（3）引用块"><a href="#（3）引用块" class="headerlink" title="（3）引用块"></a>（3）引用块</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文字引用：</span><br><span class="line">&gt;Typora 快捷键： Ctrl+Shift+Q</span><br></pre></td></tr></table></figure><h4 id="（4）代块"><a href="#（4）代块" class="headerlink" title="（4）代块"></a>（4）代块</h4><p>Markdown 语法：</p><p>行内代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">行内代码</span><br><span class="line"></span><br><span class="line">多行代码：</span><br><span class="line"></span><br><span class="line">多行代码</span><br><span class="line">多行代码</span><br><span class="line">多行代码</span><br></pre></td></tr></table></figure><p>Typora 快捷键：</p><p>行内代码：Ctrl+Shift+`</p><p>多行代码：Ctrl+Shift+K</p><h4 id="（5）公式块"><a href="#（5）公式块" class="headerlink" title="（5）公式块"></a>（5）公式块</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">数学公式</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>Typora 快捷键： Ctrl+Shift+M</p><h4 id="（6）分割线"><a href="#（6）分割线" class="headerlink" title="（6）分割线"></a>（6）分割线</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法一：---</span><br><span class="line"></span><br><span class="line">方法二：+++</span><br><span class="line"></span><br><span class="line">方法三：***</span><br></pre></td></tr></table></figure><h4 id="（7）列表"><a href="#（7）列表" class="headerlink" title="（7）列表"></a>（7）列表</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表项</span><br><span class="line"></span><br><span class="line">* 无序列表项</span><br><span class="line"></span><br><span class="line">+ 无序列表项</span><br><span class="line"></span><br><span class="line">- 无序列表项</span><br></pre></td></tr></table></figure><p>Typora 快捷键：</p><p>有序列表项：Ctrl+Shift+[</p><p>无序列表项：Ctrl+Shift+]</p><h4 id="（8）表格"><a href="#（8）表格" class="headerlink" title="（8）表格"></a>（8）表格</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表头1|表头2</span><br><span class="line">-|-|-</span><br><span class="line">内容11|内容12</span><br><span class="line">内容21|内容22</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头1</th><th>表头2</th></tr></thead><tbody><tr><td>内容11</td><td>内容12</td></tr><tr><td>内容21</td><td>内容22</td></tr></tbody></table><p>Typora 快捷键： <strong>Ctrl+T</strong></p><h4 id="（9）超链接"><a href="#（9）超链接" class="headerlink" title="（9）超链接"></a>（9）超链接</h4><p>Markdown语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法一：[链接文字](链接地址 &quot;链接描述&quot;)</span><br><span class="line">例如：[示例链接](https://www.example.com/ &quot;示例链接&quot;)</span><br><span class="line"></span><br><span class="line">方法二：&lt;链接地址&gt;</span><br><span class="line">例如：&lt;https://www.example.com/&gt;</span><br></pre></td></tr></table></figure><p>Typora快捷键： <strong>Ctrl+K</strong></p><h4 id="（10）图片"><a href="#（10）图片" class="headerlink" title="（10）图片"></a>（10）图片</h4><p>Markdown语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![图片文字](图片地址 &quot;图片描述&quot;)</span><br><span class="line">例如：![示例图片](https://www.example.com/example.PNG &quot;示例图片&quot;)</span><br></pre></td></tr></table></figure><p>Typora快捷键： <strong>Ctrl+Shift+I</strong></p><p><strong>说明</strong>：在 Hexo中 插入图片时，请按照以下的步骤进行设置</p><ol><li>将 站点配置文件 中的 post_asset_folde 选项的值设置为 true</li></ol><ol start="2"><li><p>在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件</p></li><li><p>这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p></li><li>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <code>![示例图片](title/example.PNG &quot;示例图片&quot;)</code> 添加图片</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Markdown-简介&quot;&gt;&lt;a href=&quot;#1、Markdown-简介&quot; class=&quot;headerlink&quot; title=&quot;1、Markdown 简介&quot;&gt;&lt;/a&gt;1、Markdown 简介&lt;/h3&gt;&lt;p&gt;但是，在我们正式写下第一个文字前，我们需要了解一下究
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Mackdown" scheme="http://yoursite.com/tags/Mackdown/"/>
    
  </entry>
  
</feed>
