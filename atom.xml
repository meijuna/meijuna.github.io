<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Meijuna</title>
  
  <subtitle>没有比脚更长的路，走过去，前面是个天！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-21T02:58:02.637Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>MeiJuna</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/03/21/%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2019/03/21/代码/</id>
    <published>2019-03-21T02:52:44.946Z</published>
    <updated>2019-03-21T02:58:02.637Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">web标准组成: </span><br><span class="line"></span><br><span class="line">style&#123;</span><br><span class="line">*&#123;</span><br><span class="line">        margin:0;</span><br><span class="line">        padding:0;</span><br><span class="line">&#125;</span><br><span class="line">p,h1,ul&#123;</span><br><span class="line">border: 1px solid #000;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;p&gt;p&lt;/p&gt;</span><br><span class="line">&lt;h1&gt;h1&lt;/h1&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;li&lt;/li&gt;</span><br><span class="line">&lt;ul&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git 使用</title>
    <link href="http://yoursite.com/2019/01/03/Git-%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/01/03/Git-使用/</id>
    <published>2019-01-03T00:53:13.558Z</published>
    <updated>2019-01-09T03:24:49.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-操作"><a href="#git-操作" class="headerlink" title="git 操作"></a>git 操作</h2><p><code>git checkout -- file</code>可以丢弃工作区的修改</p><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p><code>git status</code>命令看看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p><p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用<code>git diff</code>这个命令看看：</p><p>git diff 比较的是工作区文件与暂存区文件的区别（上次git add 的内容）<br>git diff –cached 比较的是暂存区的文件与仓库分支里（上次git commit 后的内容）的区别</p><p>———————–版本库——————————————–<br>|                           |<br>​        git diff –cached    （是只比较暂存区和版本库的区别）             |<br>|                           |<br>————-暂存区———————-       git diff HEAD   （只比较工作区和版本库（最后一次commit）的区别）<br>|<br>​            git diff  （工作区和暂存区（最后一次add））                             |<br>|                                                        |<br>—–工作区————————————————————–</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure><p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p><p>知道了对<code>readme.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>在Git中，我们用<code>git log</code>命令显示从最近到最远的提交日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure><p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure><p>还可以继续回退到上一个版本<code>wrote a readme file</code>，不过且慢，然我们用<code>git log</code>再看看现在版本库的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p> 最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p><p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 1094a</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><hr><p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>然后尝试提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m &quot;append GPL&quot;</span><br><span class="line">[master 1094adb] append GPL</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p><p>现在，我们回顾一下<code>readme.txt</code>文件一共有几个版本被提交到Git仓库里了：</p><p>版本1：wrote a readme file</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>版本2：add distributed</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>版本3：append GPL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure><p>需要友情提示的是，你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907545599be4a60a0b5044447b47c8d8b805a25d2000/0" alt="git-log-timeline"></p><p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure><p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p><p>看看<code>readme.txt</code>的内容是不是版本<code>add distributed</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>果然被还原了。</p><p>还可以继续回退到上一个版本<code>wrote a readme file</code>，不过且慢，然我们用<code>git log</code>再看看现在版本库的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p>最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p><p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 1094a</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure><p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p><p>再小心翼翼地看看<code>readme.txt</code>的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>果然，我胡汉三又回来了。</p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907584977fc9d4b96c99f4b5f8e448fbd8589d0b2000/0" alt="git-head"></p><p>改为指向<code>add distributed</code>：</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907594057a873c79f14184b45a1a66b1509f90b7a000/0" alt="git-head-move"></p><p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><p>终于舒了口气，从输出可知，<code>append GPL</code>的commit id是<code>1094adb</code>，现在，你又可以乘坐时光机回到未来了。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>现在总结一下：</p><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><h4 id="撤销修改-git-checkout-–-file-可以丢弃工作区的修改："><a href="#撤销修改-git-checkout-–-file-可以丢弃工作区的修改：" class="headerlink" title="撤销修改 git checkout – file 可以丢弃工作区的修改："></a>撤销修改 git checkout – file 可以丢弃工作区的修改：</h4><hr><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在<code>readme.txt</code>中添加了一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure><p>在你准备提交前，一杯咖啡起了作用，你猛然发现了<code>stupid boss</code>可能会让你丢掉这个月的奖金！</p><p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>现在，看看<code>readme.txt</code>的文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure><p>文件内容果然复原了。</p><p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p><p>现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   readme.txt</span><br></pre></td></tr></table></figure><p><strong>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M    readme.txt</span><br></pre></td></tr></table></figure><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   readme.txt</span><br></pre></td></tr></table></figure><p>还记得如何丢弃工作区的修改吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>又到了小结时间。</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000" target="_blank" rel="noopener">版本回退</a>一节，不过前提是没有推送到远程库。</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><hr><p>当你要删除文件的时候，可以采用命令：rm test.txt</p><p>这个时候有两种情况</p><p>第一种情况:的确要把test.txt删掉，</p><p>那么可以执行                    git rm test.txt               </p><p>​                       git commit -m “remove test.txt”                   </p><pre><code>文件被删除，且删除记录上传本地库</code></pre><p>第二种情况:误删文件，想恢复，这时候还没有commit -m “remove test.txt”，</p><p>执行git checkout test.txt将文件恢复。</p><p>如果执行完git commit -m “remove test.txt”后就不能用checkout恢复了，得用git reset –hard HEAD^</p><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong></p><h4 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:meijuna/learngit.git</span><br></pre></td></tr></table></figure><p>请千万注意，把上面的<code>meijuna</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.</span><br><span class="line">Total 20 (delta 5), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (5/5), done.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;.</span><br></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>从现在起，只要本地作了提交，就可以通过命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p><h5 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h5><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href="https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/" target="_blank" rel="noopener">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p><h2 id="初次安装git配置用户名和邮箱"><a href="#初次安装git配置用户名和邮箱" class="headerlink" title="初次安装git配置用户名和邮箱"></a>初次安装git配置用户名和邮箱</h2><p>查看邮箱 和shh key是否设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name   //查看用户名&amp;邮箱</span><br><span class="line"></span><br><span class="line">$ git config user.email</span><br><span class="line"></span><br><span class="line">$ ssh -T git@github.com  //ssh</span><br></pre></td></tr></table></figure><p>用户名和邮箱的作用：</p><p>　　用户名和邮箱地址相当于你的身份标识，是本地Git客户端的一个变量，不会随着Git库而改变。</p><p>　　每次commit都会用用户名和邮箱纪录。</p><p>　　github的contributions跟你的邮箱是有关联的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;meijuna&quot;</span><br><span class="line"></span><br><span class="line">$ git config --global user.email &quot;1914623558@qq.com&quot;</span><br><span class="line"></span><br><span class="line">$ git config user.name   //查看用户名&amp;邮箱</span><br><span class="line"></span><br><span class="line">$ git config user.email</span><br><span class="line"></span><br><span class="line">$ git config --global user.name &quot;xxx&quot; //修改用户名邮箱</span><br><span class="line"></span><br><span class="line">$ git config --global user.email &quot;xxx&quot;</span><br></pre></td></tr></table></figure><h2 id="git使用ssh密钥"><a href="#git使用ssh密钥" class="headerlink" title="git使用ssh密钥"></a>git使用ssh密钥</h2><p>git支持https和git两种传输协议，github分享链接时会有两种协议可选：</p><p>1.git使用https协议，每次pull, push都会提示要输入密码</p><p>2.使用git协议，然后使用ssh密钥，这样免去每次都输密码的麻烦</p><hr><p><strong>初次使用git的用户要使用git协议大概需要三个步骤：</strong></p><p><strong>一、生成密钥对</strong></p><p><strong>二、设置远程仓库（本文以github为例）上的公钥</strong></p><p><strong>三、把git的 remote url 修改为git协议</strong>（以上两个步骤初次设置过以后，以后使用都不需要再次设置，此步骤视以后项目的remote url而定，如果以后其他项目的协议为https则需要此步骤）</p><hr><h3 id="一、生成密钥对"><a href="#一、生成密钥对" class="headerlink" title="一、生成密钥对"></a>一、生成密钥对</h3><p>大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥。</p><p>SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。进去看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">id_rsa  id_rsa.pub  key_backup/  known_hosts</span><br></pre></td></tr></table></figure><p>看一下有没有id_rsa和id_rsa.pub(或者是id_dsa和id_dsa.pub之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。</p><p>假如没有这些文件，甚至连 .ssh 目录都没有，可以用 ssh-keygen 来创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-keygen -t rsa-C "your_email@youremail.com" //你的github绑定的邮箱</span><br></pre></td></tr></table></figure><p>直接按Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)<br><img src="/2019/01/03/Git-使用/G:/Hexo\source\_posts\Git-使用\1.png" alt="获取密匙"></p><p>如果之后你出现了这个界面之后，就说明你的密匙已经成功创建了。现在你就需要去他刚刚显示的存储位置打开它，把其中的内容复制出来。</p><p><strong>到此为止，你本地的密钥对就生成了。</strong></p><h3 id="二、添加公钥到你的远程仓库（github）"><a href="#二、添加公钥到你的远程仓库（github）" class="headerlink" title="二、添加公钥到你的远程仓库（github）"></a>二、添加公钥到你的远程仓库（github）</h3><hr><ol><li><p>查看你的公匙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0X6L1zLL4VHuvGb8aJH3ippTozmReSUzgntvk434aJ/v7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8vR3c8E7CjZN733f5AL8uEYJA+YZevY5UCvEg+umT7PHghKYaJwaCxV7sjYP7Z6V79OMCEAGDNXC26IBMdMgOluQjp6o6j2KAdtRBdCDS/QIU5THQDxJ9lBXjk1fiq9tITo/aXBvjZeD+gH/Apkh/0GbO8VQLiYYmNfqqAHHeXdltORn8N7C9lOa/UW3KM7QdXo6J0GFlBVQeTE/IGqhMS5PMln3 admin@admin-PC</span><br></pre></td></tr></table></figure></li><li><p>登陆你的github帐户。点击你的头像，然后 <code>Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key</code></p></li><li><p>然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，自己随便起个名字。</p></li><li>点击 Add key</li></ol><p><strong>完成以后，验证下这个key是不是正常工作：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果出现 HI XXX 说明设置成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi meijuna! You&apos;ve successfully authenticated, but GitHub does not provide shell access</span><br></pre></td></tr></table></figure></p><h3 id="三、修改git的remote-url"><a href="#三、修改git的remote-url" class="headerlink" title="三、修改git的remote url"></a>三、修改git的remote url</h3><hr><p>使用命令 git remote -v 查看你当前的 remote url (远程仓库)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin https://github.com/someaccount/someproject.git (fetch)</span><br><span class="line">origin https://github.com/someaccount/someproject.git (push)</span><br></pre></td></tr></table></figure><p>如果是以上的结果那么说明此项目是使用https协议进行访问的（如果地址是git开头则表示是git协议）</p><p>你可以登陆你的github，就像本文开头的图例，你在上面可以看到你的ssh协议相应的url</p><p>复制此ssh链接，然后使用命令 git remote set-url 来调整你的url。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:someaccount/someproject.git</span><br></pre></td></tr></table></figure><p>然后你可以再用命令 <code>git remote -v</code>查看一下，url是否已经变成了ssh地址。</p><p>然后你就可以愉快的使用git fetch, git pull , git push，再也不用输入烦人的密码了</p><h2 id="git-操作-1"><a href="#git-操作-1" class="headerlink" title="git 操作"></a>git 操作</h2><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add pb https://github.com/zhousg/letao.git</span><br></pre></td></tr></table></figure><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">pb      https://github.com/zhousg/letao.git (fetch)</span><br><span class="line">pb      https://github.com/zhousg/letao.git (push)</span><br></pre></td></tr></table></figure><p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git fetch pb</span><br><span class="line">remote: Counting objects: 43, done.</span><br><span class="line">remote: Compressing objects: 100% (36/36), done.</span><br><span class="line">remote: Total 43 (delta 10), reused 31 (delta 5)</span><br><span class="line">Unpacking objects: 100% (43/43), done.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure><p>现在 Paul 的 master 分支可以在本地通过 <code>pb/master</code> 访问到 - 你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching" target="_blank" rel="noopener">Git 分支</a> 中详细介绍什么是分支以及如何使用分支。）</p><h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 <code>git fetch</code> 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作</p><p>Git 分支</p><h3 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h3><p>当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p><p><strong>现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）</strong></p><p><img src="/2019/01/03/Git-使用/G:/Hexo\source\_posts\Git-使用\commit-and-tree.png" alt=""></p><p><strong>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针</strong>。</p><p><img src="https://git-scm.com/book/en/v2/images/commits-and-parents.png" alt="æäº¤å¯¹è±¡åå¶ç¶å¯¹è±¡ã"></p><p>Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 <code>git init</code> 命令默认创建它，并且大多数人都懒得去改动它。</p><h3 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查看分支：git branch</span><br><span class="line"></span><br><span class="line">创建分支：git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">切换分支：git checkout &lt;name&gt;</span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除分支：git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch testing  //创建testing分支</span><br></pre></td></tr></table></figure><p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 <code>HEAD</code> 想象为当前分支的别名）。 在本例中，你仍然在 <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 <em>创建</em> 一个新分支，并不会自动切换到新分支中去。</p><p><img src="https://git-scm.com/book/en/v2/images/head-to-master.png" alt="HEAD æåå½åæå¨çåæ¯ã"></p><h3 id="指向当前所在的分支"><a href="#指向当前所在的分支" class="headerlink" title="指向当前所在的分支"></a>指向当前所在的分支</h3><p>你可以简单地使用 <code>git log</code> 命令查看各个分支当前所指的对象。 提供这一功能的参数是 <code>--decorate</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --decorate</span><br><span class="line">f30ab (HEAD, master, testing) add feature #32 - ability to add new</span><br><span class="line">34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">98ca9 initial commit of my project</span><br></pre></td></tr></table></figure><p>正如你所见，当前 “master” 和 “testing” 分支均指向校验和以 <code>f30ab</code> 开头的提交对象。</p><h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout testing</span><br></pre></td></tr></table></figure><p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。</p><p><img src="https://git-scm.com/book/en/v2/images/head-to-testing.png" alt="HEAD æåå½åæå¨çåæ¯ã"></p><h3 id="HEAD-指向当前所在的分支"><a href="#HEAD-指向当前所在的分支" class="headerlink" title="HEAD 指向当前所在的分支"></a>HEAD 指向当前所在的分支</h3><p>那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vim test.rb</span><br><span class="line"><span class="meta">$</span> git commit -a -m 'made other changes'</span><br></pre></td></tr></table></figure><p>现在，这个项目的提交历史已经产生了分叉（参见 <a href="https://git-scm.com/book/zh/v2/ch00/rdivergent_history" target="_blank" rel="noopener">项目分叉历史</a>）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 <code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p><p><img src="https://git-scm.com/book/en/v2/images/advance-testing.png" alt="HEAD åæ¯éçæäº¤æä½èªå¨ååç§&quot;å¨ã"></p><h3 id="HEAD-分支随着提交操作自动向前移动"><a href="#HEAD-分支随着提交操作自动向前移动" class="headerlink" title="HEAD 分支随着提交操作自动向前移动"></a>HEAD 分支随着提交操作自动向前移动</h3><p>如图所示，你的 <code>testing</code> 分支向前移动了，但是 <code>master</code> 分支却没有，它仍然指向运行 <code>git checkout</code> 时所指的对象。 这就有意思了，现在我们切换回 <code>master</code> 分支看看：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/checkout-master.png" alt="æ£åºæ¶ HEAD éä¹ç§&quot;å¨ã"></p><p>这条命令做了两件事。 一是使 HEAD 指回 <code>master</code> 分支，二是将工作目录恢复成 <code>master</code> 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 <code>testing</code>分支所做的修改，以便于向另一个方向进行开发。</p><p>分支切换会改变你工作目录中的文件</p><p>在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</p><p>我们不妨再稍微做些修改并提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vim test.rb</span><br><span class="line"><span class="meta">$</span> git commit -a -m 'made other changes'</span><br></pre></td></tr></table></figure><p>现在，这个项目的提交历史已经产生了分叉（参见 <a href="https://git-scm.com/book/zh/v2/ch00/rdivergent_history" target="_blank" rel="noopener">项目分叉历史</a>）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 <code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p><p><img src="https://git-scm.com/book/en/v2/images/advance-master.png" alt="é¡¹ç®åååå²ã"></p><h3 id="项目分叉历史"><a href="#项目分叉历史" class="headerlink" title="项目分叉历史"></a>项目分叉历史</h3><p>可以简单地使用 <code>git log</code> 命令查看分叉历史。 运行 <code>git log --oneline --decorate --graph --all</code> ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git log --oneline --decorate --graph --all</span><br><span class="line">* c2b9e (HEAD, master) made other changes</span><br><span class="line">| * 87ab2 (testing) made a change</span><br><span class="line">|/</span><br><span class="line">* f30ab add feature #32 - ability to add new formats to the</span><br><span class="line">* 34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">* 98ca9 initial commit of my project</span><br></pre></td></tr></table></figure><h2 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h2><p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：</p><ol><li>开发某个网站。</li><li>为实现某个新的需求，创建一个分支。</li><li>在这个分支上开展工作。</li></ol><p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：</p><ol><li>切换到你的线上分支（production branch）。</li><li>为这个紧急任务新建一个分支，并在其中修复它。</li><li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li><li>切换回你最初工作的分支上，继续工作。</li></ol><h3 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h3><p>首先，我们假设你正在你的项目上工作，并且已经有一些提交。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-1.png" alt="ä¸ä¸ªç®åçæäº¤åå²ã"></p><p>一个简单提交历史</p><p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 <code>-b</code> 参数的 <code>git checkout</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout -b iss53</span><br><span class="line">Switched to a new branch "iss53"</span><br></pre></td></tr></table></figure><p>它是下面两条命令的简写：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch iss53</span><br><span class="line"><span class="meta">$</span> git checkout iss53</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-2.png" alt="åå&quot;ºä¸ä¸ªæ°åæ¯æéã"></p><h3 id="创建一个新分支指针"><a href="#创建一个新分支指针" class="headerlink" title="创建一个新分支指针"></a>创建一个新分支指针</h3><p>你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，<code>iss53</code> 分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的 <code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-3.png" alt="iss53 åæ¯éçå·¥ä½çè¿å±ååæ¨è¿ã"></p><p>现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 <code>iss53</code> 的修改混在一起，你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 <code>master</code> 分支。</p><p>但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit amending）），我们会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_stashing" target="_blank" rel="noopener">储藏与清理</a> 中看到关于这两个命令的介绍。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 <code>master</code> 分支了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout master</span><br></pre></td></tr></table></figure><p>这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p><p>接下来，你要修复这个紧急问题。 让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout -b hotfix</span><br><span class="line">Switched to a new branch 'hotfix'</span><br><span class="line"><span class="meta">$</span> vim index.html</span><br><span class="line"><span class="meta">$</span> git commit -a -m 'fixed the broken email address'</span><br><span class="line">[hotfix 1fb7853] fixed the broken email address</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://git-scm.com/book/en/v2/images/basic-branching-4.png" alt="åºäº `master` åæ¯çç´§æ¥é®é¢åæ¯ï¼hotfix branchï¼ã"></h3><h3 id="基于-master-分支的紧急问题分支-hotfix-branch"><a href="#基于-master-分支的紧急问题分支-hotfix-branch" class="headerlink" title="基于 master 分支的紧急问题分支 hotfix branch"></a>基于 <code>master</code> 分支的紧急问题分支 <code>hotfix branch</code></h3><p>你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的 <code>master</code> 分支来部署到线上。 你可以使用 <code>git merge</code> 命令来达到上述目的：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout master</span><br><span class="line"><span class="meta">$</span> git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><p>在合并的时候，你应该注意到了”快进（fast-forward）”这个词。 由于当前 <code>master</code> 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p><p>现在，最新的修改已经在 <code>master</code> 分支所指向的提交快照中，你可以着手发布该修复了。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-5.png" alt="`master` è¢&quot;å¿&quot;è¿å° `hotfix`ã"></p><p>关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 <code>hotfix</code>分支，因为你已经不再需要它了 —— <code>master</code> 分支已经指向了同一个位置。 你可以使用带 <code>-d</code> 选项的 <code>git branch</code> 命令来删除分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (3a0874c).</span><br></pre></td></tr></table></figure><p>现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout iss53</span><br><span class="line">Switched to branch "iss53"</span><br><span class="line"><span class="meta">$</span> vim index.html</span><br><span class="line"><span class="meta">$</span> git commit -a -m 'finished the new footer [issue 53]'</span><br><span class="line">[iss53 ad82d7a] finished the new footer [issue 53]</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-6.png" alt="ç&quot;§ç&quot;­å¨ `iss53` åæ¯ä¸çå·¥ä½ã"></p><p>你在 <code>hotfix</code> 分支上所做的工作并没有包含到 <code>iss53</code> 分支中。 如果你需要拉取 <code>hotfix</code> 所做的修改，你可以使用 <code>git merge master</code> 命令将 <code>master</code> 分支合并入 <code>iss53</code> 分支，或者你也可以等到 <code>iss53</code> 分支完成其使命，再将其合并回 <code>master</code> 分支。</p><h3 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h3><p>假设你已经修正了 #53 问题，并且打算将你的工作合并入 <code>master</code> 分支。 为此，你需要合并 <code>iss53</code> 分支到 <code>master</code> 分支，这和之前你合并 <code>hotfix</code> 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 <code>git merge</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout master</span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta">$</span> git merge iss53</span><br><span class="line">Merge made by the 'recursive' strategy.</span><br><span class="line">index.html |    1 +</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>这和你之前合并 <code>hotfix</code> 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，<code>master</code> 分支所在提交并不是 <code>iss53</code> 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的工作祖先（<code>C2</code>），做一个简单的三方合并。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-merging-1.png" alt="ä¸æ¬¡å¸ååå¹¶ä¸­æç¨å°çä¸ä¸ªå¿&quot;ç§ã"></p><p>​    和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-merging-2.png" alt="ä¸ä¸ªåå¹¶æäº¤ã"></p><p>需要指出的是，Git 会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础；这和更加古老的 CVS 系统或者 Subversion （1.5 版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。 Git 的这个优势使其在合并操作上比其他系统要简单很多。</p><p>既然你的修改已经合并进来了，你已经不再需要 <code>iss53</code> 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch -d iss53</span><br></pre></td></tr></table></figure><h3 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h3><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 <code>hotfix</code> 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git merge iss53</span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run "git commit")</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use "git add &lt;file&gt;..." to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span>contact : email.support@github.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">=======</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line"> please contact us at support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><p>上述的冲突解决方案仅保留了其中一个分支的修改，并且 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p><p>如果你想使用图形化工具来解决冲突，你可以运行 <code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git mergetool</span><br><span class="line"></span><br><span class="line">This message is displayed because 'merge.tool' is not configured.</span><br><span class="line">See 'git mergetool --tool-help' or 'git help config' for more details.</span><br><span class="line">'git mergetool' will now attempt to use one of the following tools:</span><br><span class="line">opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge</span><br><span class="line">Merging:</span><br><span class="line">index.html</span><br><span class="line"></span><br><span class="line">Normal merge conflict for 'index.html':</span><br><span class="line">  &#123;local&#125;: modified file</span><br><span class="line">  &#123;remote&#125;: modified file</span><br><span class="line">Hit return to start merge resolution tool (opendiff):</span><br></pre></td></tr></table></figure><p>等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 <code>git status</code> 来确认所有的合并冲突都已被解决：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git status</span><br><span class="line">On branch master</span><br><span class="line">All conflicts fixed but you are still merging.</span><br><span class="line">  (use "git commit" to conclude merge)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line"></span><br><span class="line">    modified:   index.html</span><br></pre></td></tr></table></figure><p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 <code>git commit</code> 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Merge branch 'iss53'</span><br><span class="line"></span><br><span class="line">Conflicts:</span><br><span class="line">    index.html</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> It looks like you may be committing a merge.</span><br><span class="line"><span class="meta">#</span> If this is not correct, please remove the file</span><br><span class="line"><span class="meta">#</span>.git/MERGE_HEAD</span><br><span class="line"><span class="meta">#</span> and try again.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Please enter the commit message for your changes. Lines starting</span><br><span class="line"><span class="meta">#</span> with '#' will be ignored, and an empty message aborts the commit.</span><br><span class="line"><span class="meta">#</span> On branch master</span><br><span class="line"><span class="meta">#</span> All conflicts fixed but you are still merging.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Changes to be committed:</span><br><span class="line"><span class="meta">#</span>modified:   index.html</span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><p>合并后，我们用<code>git log</code>看看分支历史：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384909222841acf964ec9e6a4629a35a7a30588281bb000/0" alt="git-no-ff-mode"></p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。</p><p><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>注意 <code>master</code> 分支前的 <code>*</code> 字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code> 指针所指向的分支）。 这意味着如果在这时候提交，<code>master</code> 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 <code>git branch -v</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch -v</span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch 'iss53'</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure><p><code>--merged</code> 与 <code>--no-merged</code> 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 <code>git branch --merged</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch --merged</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>因为之前已经合并了 <code>iss53</code> 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用 <code>git branch -d</code> 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p><p>查看所有包含未合并工作的分支，可以运行 <code>git branch --no-merged</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch --no-merged</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 <code>git branch -d</code> 命令删除它时会失败：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch -d testing</span><br><span class="line">error: The branch 'testing' is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run 'git branch -D testing'.</span><br></pre></td></tr></table></figure><p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 <code>-D</code> 选项强制删除它。</p><h4 id="git-stash保留现场"><a href="#git-stash保留现场" class="headerlink" title="git stash保留现场"></a>git stash保留现场</h4><p>git stash </p><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了</p><p>先说几个名词<br>未被追踪的文件:指的是新建的文件或文件夹且还没加入到暂存区(新建的还没有被git add 过得)<br>未加入到暂存区的文件:指的是已经被追踪过，但是没有加入到暂存区(已经执行过git add/commit的但是这次修改后还没有git add)<br>举例:<br>readme.md  已经被git add/git commit过，但是呢 我这次只是修改了，而且没有修改完，不能commit<br>test    新建的文件夹,没有被git add/git commit过<br>有个急事需要处理,这时候我需要切换分支，去处理紧急任务,比如文中的举例去修改bug，<br>正确的步骤:<br>git add test（让git去追踪这个新文件）<br>git stash保留现场<br>如果我不执行这两个命令，那么我在修改BUG完成之后<br>git status，就会发现readme.md 没有添加到暂存区，同时又多了个test文件,但是自己的readme.md没有完成，万万不可以提交，这样导致bug的修改代码也提交不了。所以你需要<br>git stash，这样你在提交修改bug代码的时候 ，就不会看见readme.md 和 test。可以安心提交修改bug的代码。</p><h4 id="Feature分支-没有被合并过的分支，可以通过git-branch-D-lt-name-gt-强行删除"><a href="#Feature分支-没有被合并过的分支，可以通过git-branch-D-lt-name-gt-强行删除" class="headerlink" title="Feature分支 没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除"></a>Feature分支 没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除</h4><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p><p>于是准备开发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature-vulcan</span><br><span class="line">Switched to a new branch &apos;feature-vulcan&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git add vulcan.py</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch feature-vulcan</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   vulcan.py</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add feature vulcan&quot;</span><br><span class="line">[feature-vulcan 287773e] add feature vulcan</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 vulcan.py</span><br></pre></td></tr></table></figure><p>切回<code>dev</code>，准备合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p><p><code>git branch -D feature-vulcan</code> 强制删除未合并的分支</p><h4 id="查看远程库的信息，用git-remote"><a href="#查看远程库的信息，用git-remote" class="headerlink" title="查看远程库的信息，用git remote"></a>查看远程库的信息，用<code>git remote</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p><h2 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h2><p><img src="http://s3.51cto.com/wyfs02/M02/12/44/wKiom1MA0v-horoSAAS4v41ef_U068.jpg" alt="img"></p><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。</p><p>许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 <code>master</code> 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 <code>develop</code> 或者 <code>next</code> 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 <code>master</code> 分支了。 这样，在确保这些已完成的特性分支（短期分支，比如之前的 <code>iss53</code> 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。</p><p>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。</p><p><img src="https://git-scm.com/book/en/v2/images/lr-branches-1.png" alt="æ¸è¿ç¨³å®åæ¯ççº¿æ§å¾ã"></p><p>通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。</p><p><img src="https://git-scm.com/book/en/v2/images/lr-branches-2.png" alt="æ¸è¿ç¨³å®åæ¯çå·¥ä½æµï¼âsiloâï¼è§å¾ã"></p><p>你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 <code>proposed</code>（建议） 或 <code>pu: proposed updates</code>（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 <code>next</code> 或者 <code>master</code> 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。</p><h3 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h3><p>你已经在上一节中你创建的 <code>iss53</code> 和 <code>hotfix</code> 特性分支中看到过这种用法。 你在上一节用到的特性分支（<code>iss53</code> 和 <code>hotfix</code> 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。</p><p>考虑这样一个例子，你在 <code>master</code> 分支上工作到 <code>C1</code>，这时为了解决一个问题而新建 <code>iss91</code> 分支，在 <code>iss91</code>分支上工作到 <code>C4</code>，然而对于那个问题你又有了新的想法，于是你再新建一个 <code>iss91v2</code> 分支试图用另一种方法解决那个问题，接着你回到 <code>master</code> 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 <code>C10</code>的时候新建一个 <code>dumbidea</code> 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：</p><p><img src="https://git-scm.com/book/en/v2/images/topic-branches-1.png" alt="æ¥æå¤ä¸ªç¹æ§åæ¯çæäº¤åå²ã"></p><p>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 <code>iss91v2</code> 分支中方案；另外，你将 <code>dumbidea</code> 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 <code>iss91</code> 分支（即丢弃 <code>C5</code> 和 <code>C6</code> 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：</p><p><img src="https://git-scm.com/book/en/v2/images/topic-branches-2.png" alt="åå¹¶äº `dumbidea` å `iss91v2` åæ¯ä¹åçæäº¤åå²ã"></p><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><ul><li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签。</li></ul><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure><p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure><p>可以用命令<code>git tag</code>查看所有标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 add merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line">5dc6824 &amp; simple</span><br><span class="line">14096d0 AND simple</span><br><span class="line">b17d20e branch test</span><br><span class="line">d46f35e remove test.txt</span><br><span class="line">b84166e add test.txt</span><br><span class="line">519219b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line">1094adb append GPL</span><br><span class="line">e475afc add distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 f52c633</span><br></pre></td></tr></table></figure><p>再用命令<code>git tag</code>查看标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure><p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.1</span><br><span class="line">tag v0.1</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 22:48:43 2018 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line"></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p> 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p><h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><p>如果标签打错了，也可以删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br><span class="line">Deleted tag &apos;v0.1&apos; (was f15b0dd)</span><br></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag &apos;v0.9&apos; (was f52c633)</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;git-操作&quot;&gt;&lt;a href=&quot;#git-操作&quot; class=&quot;headerlink&quot; title=&quot;git 操作&quot;&gt;&lt;/a&gt;git 操作&lt;/h2&gt;&lt;p&gt;&lt;code&gt;git checkout -- file&lt;/code&gt;可以丢弃工作区的修改&lt;/p&gt;
&lt;p&gt;命令&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>前端笔记</title>
    <link href="http://yoursite.com/2018/12/26/HTML%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/12/26/HTML笔记/</id>
    <published>2018-12-26T12:45:14.899Z</published>
    <updated>2019-03-25T03:23:05.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、HTML"><a href="#一、HTML" class="headerlink" title="一、HTML"></a>一、HTML</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">背景不能继承</span><br><span class="line">background-image: url(&apos;&apos;);</span><br><span class="line">background-color: #000;</span><br><span class="line">background-position: top/bottom/left/right/center %  px</span><br><span class="line">background-repeat: no-repeat;</span><br><span class="line">background-attachment: fixed;</span><br></pre></td></tr></table></figure><p><strong>什是么网站？</strong>     </p><p>​      网站(Website)开始是指在因特网上根据一定的规则，使用HTML等工具制作的用于展示特定内容相关网页的集合</p><p><strong>什么是网页？</strong></p><p>​       网页是一个包含HTML标签的纯文本文件，它可以存放在世界某个角落的某一台计算机中，是超文本标记语言格式文件扩展名为.html。</p><p>文字与图片是构成一个网页的两个最基本的元素。</p><h4 id="1-WEB标准的概念及组成"><a href="#1-WEB标准的概念及组成" class="headerlink" title="1. WEB标准的概念及组成"></a>1. <strong>WEB</strong>标准的概念及组成</h4><p><img src="/2018/12/26/HTML笔记/G:/Hexo\source\_posts\HTML笔记\01.jpg" alt="组成"></p><p><strong>结构：</strong></p><p>HTML- 超文本标记语言 (Hyper Text Markup Language)  </p><p>XHTML-可扩展超文本标记语言(EXtensible HyperText Markup Language)</p><p><strong>表现：</strong></p><p>CSS-层叠样式表（Cascading Style Sheets）</p><p><strong>行为：</strong></p><p>JavaScript-是轻量级的脚本语言</p><h4 id="2-XHTM基本语法"><a href="#2-XHTM基本语法" class="headerlink" title="2. XHTM基本语法"></a>2. XHTM基本语法</h4><h5 id="1、常规标记-双标记"><a href="#1、常规标记-双标记" class="headerlink" title="1、常规标记/双标记"></a>1、常规标记/双标记</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标记</span> 属性=<span class="string">“属性值”</span>  属性=<span class="string">“属性值”</span>&gt;</span><span class="tag">&lt;/<span class="name">标记</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2、空标记-单标记"><a href="#2、空标记-单标记" class="headerlink" title="2、空标记/单标记"></a>2、空标记/单标记</h5><p>&lt;标记 属性=“属性值” /&gt;</p><p><strong>说明：</strong></p><p>​      写在&lt;&gt;中的第一个单词叫做标记、标签、元素名。</p><p>​      标记和属性用空格隔开，属性和属性值用等号连接，属性值必须放在“”号内。</p><p>​      一个标记可以没有属性也可以有多个属性，属性和属性之间不分先后顺序。</p><p>​      空标记没有单独的结束标签，用“/”代替。</p><h4 id="3-HTML5-基本结构"><a href="#3-HTML5-基本结构" class="headerlink" title="3. HTML5 基本结构"></a>3. <strong>HTML5</strong> <strong>基本结构</strong></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span>文档类型声明</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span>说明文档写的是标记语言 ，根标签</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span>文件头部</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span>文件标题（显示在状态栏上的内容）</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span>['metə]</span><br><span class="line">编码格式--meta标记用于定义文件信息，对网页文件进行说明，便于搜索引擎查找设置关键字等  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span>文件主体(所有要写的内容)</span><br></pre></td></tr></table></figure><h4 id="4-标签-lt-gt"><a href="#4-标签-lt-gt" class="headerlink" title="4. 标签(&lt;&gt;)"></a>4. 标签(&lt;&gt;)</h4><h4 id="（1）标签单双分类（根据有无单独的结束标签）："><a href="#（1）标签单双分类（根据有无单独的结束标签）：" class="headerlink" title="（1）标签单双分类（根据有无单独的结束标签）："></a>（1）标签单双分类（根据有无单独的结束标签）：</h4><p>​          <strong>1. 双标签（常规标签）：有单独的结束标签</strong></p><p>​               h1~h6  p b strong i em del sup sub s strike ul ol dl dt dd li a table tr td</p><p>​               div span</p><p>​          <strong>2. 单标签（空标签）：没有单独结束标签</strong></p><p>​               br  hr img ​          </p><h4 id="（2）元素行块分类（根据有没有自占一行进行分类的）："><a href="#（2）元素行块分类（根据有没有自占一行进行分类的）：" class="headerlink" title="（2）元素行块分类（根据有没有自占一行进行分类的）："></a>（2）元素行块分类（根据有没有自占一行进行分类的）：</h4><p>​         <strong>1. 块状元素：自占一行：</strong></p><p>​                h1~h6  p  hr ul ol  dl  dt  dd   li   table div del</p><p>​          <strong>2.行内元素：</strong>宽度跟内容大小一致，并且可以跟其他的行内元素在一行内并列显示的：</p><p>​                 b  strong i em del s strike sup sub br  img a imput buttom span</p><h4 id="（3）标签作用"><a href="#（3）标签作用" class="headerlink" title="（3）标签作用"></a>（3）标签作用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">加粗：</span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>定义粗体的文本<span class="tag">&lt;/<span class="name">b</span>&gt;</span>     //没有语义强调的意思，一般称为物理字体格式化标签</span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>把文本定义为语气更强的强调的内容<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> //有语意 强调</span><br><span class="line">倾斜：</span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>显示斜体文本效果<span class="tag">&lt;/<span class="name">i</span>&gt;</span> //没有语义强调的意思，一般称为物理字体格式化标签</span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>把文本定义为强调的内容<span class="tag">&lt;/<span class="name">em</span>&gt;</span>  //有语意 强调</span><br><span class="line">删除标记：</span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">s</span>&gt;</span>元素，已废弃，用来给文本加删除线(在HTML 4.01中废除)</span><br><span class="line">HTML5 重定义了 <span class="tag">&lt;<span class="name">s</span>&gt;</span> 元素，现在是被用来定义那些不正确的文本。</span><br><span class="line"><span class="tag">&lt;<span class="name">strike</span>&gt;</span> 定义加删除线文本(html5不推荐使用)</span><br><span class="line">sup ：上标文本    sub：下标文本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**注：**语义强调作用的```<span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>```比```<span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>```更容易引起搜索引擎的注意，但是如果只是为了加粗样式，建议在css样式表里面实现  </span><br><span class="line"></span><br><span class="line">**div标记** (division-部分)</span><br><span class="line"></span><br><span class="line">可定义文档中的分区或节,可以把文档分割为独立的、不同的部分</span><br><span class="line"></span><br><span class="line">作用：文档区域，文档布局对象</span><br><span class="line"></span><br><span class="line">**span标记**</span><br><span class="line"></span><br><span class="line">文本结点：用来组合文档中的行内元素</span><br></pre></td></tr></table></figure><h4 id="5-列表（ul-ol-dl）"><a href="#5-列表（ul-ol-dl）" class="headerlink" title="5. 列表（ul, ol,  dl）"></a>5. 列表（ul, ol,  dl）</h4><p>HTML中有<strong>三种列表</strong>，分别是：<strong>无序列表(ul)，有序列表(ol)，自定义列表(dl)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">无序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>--unordered List</span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    … …</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">有序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span>-ordered List</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        … …</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">自定义列表 </span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span>Definition List</span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词<span class="tag">&lt;/<span class="name">dt</span>&gt;</span>Definition term</span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>解释<span class="tag">&lt;/<span class="name">dd</span>&gt;</span>Definition Description</span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6-图片-img"><a href="#6-图片-img" class="headerlink" title="6. 图片(img)"></a>6. <strong>图片</strong>(img)</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"目标文件路径及全称"</span> <span class="attr">alt</span>=<span class="string">"图片替换文本"</span> <span class="attr">title</span>=<span class="string">"图片标题"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>1. src属性：</strong>规定显示图像的 URL</p><p><strong>2. title属性:</strong>  在你鼠标悬停在该图片上时显示一个小提示，鼠标离开就没有了，HTML的绝大多数标签都支持title属性，title属性就是专门做提示信息的;</p><p><strong>3. alt属性:</strong> 规定图像的替代文本。[ælt] olt</p><p>注:所要插入的的图片必须放在站点下</p><p>src==source所用图片的来源(路径)</p><h4 id="7-超链接-a"><a href="#7-超链接-a" class="headerlink" title="7. 超链接(a)"></a>7. <strong>超链接(a)</strong></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">title</span>=<span class="string">""</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span> 链接文本/图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>1. href属性</strong>：设置目标文件路径</p><p><strong>2. title属性</strong>：超链接标题</p><p><strong>3. target属性</strong>：设置超链接的打开方式  [‘tɑrɡɪt]</p><p>   属性值：_blank-新窗口打开    [blæŋk]</p><p>​                 _self-默认的打开方式（本窗口打开） </p><p>​                 _top 在顶层WINDOW对象中打开,一般用于多层框架嵌套的情况<br>​                 _parent 在父窗口打开,一般用于框架内的窗口改变父窗口页面 [‘peər(ə)nt]</p><p>Href== Hypertext Reference的缩写，意思是超文本引用</p><h4 id="8-表单-from"><a href="#8-表单-from" class="headerlink" title="8. 表单(from)"></a>8. 表单(from)</h4><p> 作用：用来收集用户信息的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"test.html"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">name</span>=<span class="string">"myFomr"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">maxlength</span>=<span class="string">"50"</span> <span class="attr">placeholder</span>=<span class="string">"邮箱账号或手机账号"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"userPassword"</span>  <span class="attr">placeholder</span>=<span class="string">"密码"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"reset"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><strong>action属性：</strong>规定当提交表单时，向何处发送表单数据。’ækʃ(ə)n] </li><li><strong>method属性：</strong>规定如何发送表单数据（表单数据发送到 action 属性所规定的页面）浏览器使用method属性设置的方法将表单中的数据传送给服务器进行处理。共有两种方法：POST 方法和 GET 方法。[‘meθəd] </li></ol><h5 id="1-文本框-input"><a href="#1-文本框-input" class="headerlink" title="1.文本框(input)"></a>1.文本框(input)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"uername"</span> <span class="attr">value</span>=<span class="string">"内容"</span> <span class="attr">placeholder</span>=<span class="string">"提示"</span> <span class="attr">maxlength</span>=<span class="string">"20"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol><li><strong>type属性：</strong> 规定 input 元素的类型；（password，email，button）。</li><li><strong>value属性:</strong>  为 input 元素设定值；</li><li><strong>name属性：</strong>规定 input 元素的名称。name 属性用于对提交到服务器后的表单数据进行标识，或者在客户端通过 JavaScript 引用表单数据，只有设置了name属性的表单元素才能在提交表单时传递它们的值。</li><li><p><strong>placeholder属性：</strong>规定帮助用户填写输入字段的提示</p></li><li><p><strong>maxlength属性：</strong>规定输入字段中的字符的最大长度</p></li></ol><h5 id="2-按钮-button"><a href="#2-按钮-button" class="headerlink" title="2. 按钮(button)"></a>2. 按钮(button)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; name=&quot;&quot;  value=&quot;按钮内容&quot; /&gt;</span><br></pre></td></tr></table></figure><p><strong>button和submit的区别：</strong></p><p>submit是提交按钮起到提交信息的作用，button只是一个按钮</p><h4 id="9-表格-table"><a href="#9-表格-table" class="headerlink" title="9. 表格(table)"></a>9. 表格(table)</h4><p><strong>作用</strong>：显示数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"600px"</span> <span class="attr">height</span>=<span class="string">"400px"</span> <span class="attr">border</span>=<span class="string">"3"</span> <span class="attr">cellspacing</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"4"</span>&gt;</span>第一个单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">rowspan</span>=<span class="string">"4"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"4"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"4"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p><strong>table:</strong>  标签定义HTML表格</p></li><li><p><strong>tr:</strong>  元素定义表格行(table row)</p></li><li><p><strong>td:</strong>  元素定义表格单元(table data数据)</p></li><li><p><strong>border:</strong>  “表格的边框”</p></li><li><p><strong>bordercolor:</strong>“表格边框颜色”</p></li><li><p><strong>cellspacing=0</strong>:  单元格与单元格之间的间距</p></li><li><p><strong>cellpadding:</strong>  单元格与内容之间的空隙</p><p>​     水平对齐方式：align=”left/center/right”;</p><p>​     垂直对齐方式： vertical-align=”top/middle/bottom”;</p><p>​     注：对其方式在td,tr上使用</p></li><li><p><strong>colspan:</strong>  所要合并的单元格的列数” 横向合并;</p></li><li><p><strong>rowspan:</strong>  所要合并单元格的行数” 纵向合并;</p></li></ol><h4 id="10-HTML和XHTML的语法区别"><a href="#10-HTML和XHTML的语法区别" class="headerlink" title="10. HTML和XHTML的语法区别"></a>10. HTML和XHTML的语法区别</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XHTML 要求标签正确嵌套</span><br><span class="line">XHTML 所有标签必须关闭   /</span><br><span class="line">XHTML 区分大小写            </span><br><span class="line">XHTML 属性值要用双引号</span><br><span class="line">XHTML 用 id 属性代替 name 属性</span><br><span class="line">XHTML 特殊字符的处理 &amp;nbsp; &amp;lt; &amp;gt;</span><br></pre></td></tr></table></figure><h3 id="二、CSS基础"><a href="#二、CSS基础" class="headerlink" title="二、CSS基础"></a>二、CSS基础</h3><p><strong>CSS (cascading style sheets)</strong>WEB标准中的表现标准语言,表现标准语言在网页中主要对网页信息的显示进行控制，简单说就是如何修饰网页的显示样式。<strong>—级联样式表、层叠样式表</strong></p><p><strong>语法：</strong>选择符 { 属性：属性值；属性：属性值 }</p><h4 id="1-样式表分类-内部、外部、内嵌"><a href="#1-样式表分类-内部、外部、内嵌" class="headerlink" title="1.样式表分类(内部、外部、内嵌)"></a>1.样式表分类(内部、外部、内嵌)</h4><h5 id="1-内部样式-style"><a href="#1-内部样式-style" class="headerlink" title="1. 内部样式(style)"></a>1. 内部样式(style)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined">选择符 &#123; 属性：属性值；属性：属性值 &#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-外部样式-link"><a href="#2-外部样式-link" class="headerlink" title="2. 外部样式(link)"></a>2. 外部样式(link)</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel="stylesheet" type="text/css" href="目标文件路径" /&gt;</span><br></pre></td></tr></table></figure><ol><li><p><strong>rel:</strong>   规定当前文档与被连接文档之间的关系 stylesheet: 样式表</p></li><li><p><strong>type: </strong> 规定被链接文档的类型</p></li><li><p><strong>href:</strong>  规定被链接文档的位置</p></li></ol><h5 id="3-外部样式表的导入-2-import"><a href="#3-外部样式表的导入-2-import" class="headerlink" title="3.外部样式表的导入-2(@import)"></a>3.外部样式表的导入-2(@import)</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">@<span class="keyword">import</span> url(目标文件的路径就文件全称);</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>@和import之间没有空格 url和小括号之间也没有空格；必须结尾以分号结束</p><h5 id="3-外部样式对比"><a href="#3-外部样式对比" class="headerlink" title="3.外部样式对比"></a>3.外部样式对比</h5><p>两种导入样式表的方法比较：</p><ul><li>link 属于 HTML 标签，而 @import 是 CSS 提供的。</li><li>页面被加载时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载。</li><li>@import 只在 IE 5 以上才能识别，而 link 是 HTML 标签，无兼容问题。</li><li>link 方式的样式的权重高于 @import 权重。</li></ul><p>一般推荐使用 link 导入样式表的方法，@import 可以作为补充方法使用。</p><h4 id="2-选择器（选择符）"><a href="#2-选择器（选择符）" class="headerlink" title="2. 选择器（选择符）"></a>2. <strong>选择器（选择符）</strong></h4><h5 id="1-元素选择器-类型选择器（标签"><a href="#1-元素选择器-类型选择器（标签" class="headerlink" title="1.  元素选择器/类型选择器（标签 )"></a><strong>1.  元素选择器/类型选择器（标签 )</strong></h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：元素名称&#123;属性：属性值；&#125;</span><br><span class="line">说明：</span><br><span class="line">元素选择符就是以文档语言对象类型作为选择符，即使用结构中元素名称作为选择符。例如body、div、p,img,em,strong,span等。</span><br></pre></td></tr></table></figure><h5 id="2-id选择器"><a href="#2-id选择器" class="headerlink" title="2. id选择器 (#)"></a><strong>2. id选择器</strong> (#)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：#id名&#123; &#125;&#123;属性：属性值;&#125;</span><br><span class="line"> <span class="tag">&lt;<span class="name">标记</span> <span class="attr">id</span>=<span class="string">"名称1   名称2"</span> &gt;</span><span class="tag">&lt;/<span class="name">标记</span>&gt;</span></span><br><span class="line">说明：</span><br><span class="line">1） id属性值，在一个html文档中，必须是唯一的，不可重复，不能用关键字(所有的标记和属性都是关键字)</span><br><span class="line">2）一个id名称只能对应文档中一个具体的元素对象，因为id只能定义页面中某一个唯一的元素对象。</span><br><span class="line">3) 最大的用处：创建网页的外围结构</span><br></pre></td></tr></table></figure><h5 id="3-css选择器"><a href="#3-css选择器" class="headerlink" title="3. css选择器(.)"></a><strong>3. css选择器</strong>(.)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：.class名&#123;属性：属性值;&#125;</span><br><span class="line"> <span class="tag">&lt;<span class="name">标记</span> <span class="attr">class</span>=<span class="string">"名称1   名称2"</span> &gt;</span><span class="tag">&lt;/<span class="name">标记</span>&gt;</span></span><br><span class="line">说明：</span><br><span class="line">1）class选择符更适合定义一类样式； </span><br><span class="line">2） 一个标记可以设置多个class名</span><br><span class="line">3）class名可以重复</span><br><span class="line">4）限定标签类型</span><br></pre></td></tr></table></figure><h5 id="4-群组选择器"><a href="#4-群组选择器" class="headerlink" title="4. 群组选择器(,)"></a>4. 群组选择器(,)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：选择器1，选择器2，选择器3&#123;属性：属性值;&#125;</span><br><span class="line"></span><br><span class="line">说明：当有多个选择符应用相同的样式时，可以将选择符用“，”分隔的方式，合并为一组</span><br></pre></td></tr></table></figure><h5 id="5-后代选择器-包含选择器"><a href="#5-后代选择器-包含选择器" class="headerlink" title="5. 后代选择器/包含选择器"></a><strong>5. 后代选择器/包含选择器</strong></h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：选择器1 选择器2&#123;属性：属性值;&#125;</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">包含选择器选择器1和选择器2用空格隔开，含义就是选择符1中包含的所有选择器2;</span><br></pre></td></tr></table></figure><h5 id="6-子选择器-gt"><a href="#6-子选择器-gt" class="headerlink" title="6. 子选择器(&gt;)"></a><strong>6. 子选择器</strong>(&gt;)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法： 选择器1&gt;选择器2&#123;属性：属性值;&#125;</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">选择符1和选择符2用&gt;链接，选择符2必须是选择符1的子类</span><br></pre></td></tr></table></figure><h5 id="7-伪类选择器-伪类选择符"><a href="#7-伪类选择器-伪类选择符" class="headerlink" title="7. 伪类选择器(伪类选择符)"></a>7. 伪类选择器(伪类选择符)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法 ：</span><br><span class="line">       :link&#123;属性：属性值;&#125; //超链接的初始状态;</span><br><span class="line">       :visited&#123;属性：属性值;&#125; //超链接被访问后的状态;   ['vɪzɪtɪd] </span><br><span class="line">       :hover&#123;属性：属性值;&#125; //鼠标悬停，即鼠标划过超链接时的状态;</span><br><span class="line">       :active&#123;属性：属性值;&#125; //超链接被激活时的状态，即鼠标按下时超链接的状态; ['æktɪv]</span><br><span class="line">       :focus //元素获得焦点的样式   ['fəʊkəs] </span><br><span class="line">说明：</span><br><span class="line">1）当这4个超链接伪类选择符联合使用时，应注意他们的顺序，正常顺序为：a:link,a:visited,a:hover,a:active,错误的顺序有时会使超链接的样式失效； </span><br><span class="line">2）使用与超链接相关的伪类选择符时，应为a元素定义href属性;</span><br></pre></td></tr></table></figure><h5 id="8-通配符"><a href="#8-通配符" class="headerlink" title="8. 通配符(*)"></a>8. 通配符(*)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：*&#123;属性：属性值；&#125;</span><br><span class="line"></span><br><span class="line">说明：通配选择符的写法是“*”，其含义就是所有元素。</span><br><span class="line">用法：常用来重置样式</span><br><span class="line">全局样式</span><br><span class="line">*&#123;margin:0;padding:0;&#125;</span><br><span class="line">margin:0 auto; 让子元素相对父元素水平居中显示</span><br></pre></td></tr></table></figure><h4 id="3-选择器的权重"><a href="#3-选择器的权重" class="headerlink" title="3. 选择器的权重"></a><strong>3. 选择器的权重</strong></h4><p><img src="/2018/12/26/HTML笔记/C:/Users\meijuna\AppData\Roaming\Typora\typora-user-images\1553140384349.png" alt="1553140597918](C:\Users\meijuna\AppData\Roaming\Typora\typora-user-images\1553140597918.png)1553140384349"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">内联  id  class 标签</span><br><span class="line"> 1    0   0     0</span><br><span class="line"># css中用四位数字表示权重，权重的表达方式如：0，0，0，0</span><br><span class="line"># id 0100</span><br><span class="line"># class选择器  （伪类选择符 :focus,:hover以及&lt;a&gt;:link） 0010 </span><br><span class="line"># 属性选择符的权重为     0010</span><br><span class="line"># 元素a 伪元素 :before、:after  0001</span><br><span class="line"># 后代选择符：1 2 =  1 + 2 </span><br><span class="line"># 子选择器 1 &gt; 2 = 1 + 2</span><br><span class="line"># 群组看选择符类型</span><br><span class="line"># *&#123;&#125;(通配符) 0 </span><br><span class="line"># 继承 0</span><br><span class="line"># 权重相同时，根据书写顺序而定，后书写的会把县书写的覆盖掉，会显示后书写的代码效果</span><br></pre></td></tr></table></figure><h4 id="4-CSS特性：-层叠性和继承性"><a href="#4-CSS特性：-层叠性和继承性" class="headerlink" title="4. CSS特性：(层叠性和继承性)"></a>4. CSS特性：(<strong>层叠性</strong>和<strong>继承性</strong>)</h4><p><strong>层叠性：</strong>一个元素可能同时被多个css选择器选中，每个选择器都有一些css规则，这就是层叠。</p><p>CSS的处理原则是：</p><p>1）如果多个选择器定义的规则不发生冲突，则元素将应用所有选择器定义的样式。</p><p>2）如果多个选择器定义的规则发生了冲突，则CSS按选择器的特殊性(权重)让元素应用特殊性(权重)高的选择器定义的样式。</p><p><strong>继承</strong>：所谓继承，就是父元素的规则也会适用于子元素。比如给body设置为color:Red;那么他内部的元素如果没有其他的规则设置，也都会变成红色。继承得来的规则没有特殊性。</p><p>多数边框类属性，比如Padding（补白），Margin（边界），背景和边框的属性都是不能继承的。(border属性是用来设置元素的边框的，它没有继承性)</p><p>块状、内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font-family、font-size、font-style、font-weight、text-decoration、text-transform.</p><p>块状元素可继承：text-indent和text-align。</p><p>列表元素可继承： list-style、list-style-type、list-style-position、list-style-image。</p><p>表格元素可继承：border-collapse。</p><h4 id="5-颜色-color"><a href="#5-颜色-color" class="headerlink" title="5. 颜色(color)"></a>5. 颜色(color)</h4><p>可以用以下方法来规定 CSS 中的颜色：</p><ul><li><p>十六进制色 ：十六进制颜色是这样规定的：#RRGGBB，其中的 RR（红色）、GG（绿色）、BB（蓝色）十六进制整数规定了颜色的成分。所有值必须介于 0 与 FF 之间。举例说，#0000ff 值显示为蓝色，这是因为蓝色成分被设置为最高值（ff），而其他成分被设置为 0。</p></li><li><p>RGB 颜色：RGB 颜色值是这样规定的：rgb(red, green, blue)。每个参数 (red、green 以及 blue) 定义颜色的强度，可以是介于 0 与 255 之间的整数，或者是百分比值（从 0% 到 100%）。举例说，rgb(0,0,255) 值显示为蓝色，这是因为 blue 参数被设置为最高值（255），而其他被设置为 0。</p></li><li><p>RGBA 颜色：颜色值是 RGB 颜色值的扩展，带有一个 alpha 通道 - 它规定了对象的不透明度。</p><p>RGBA 颜色值是这样规定的：rgba(red, green, blue, alpha)。alpha 参数是介于 0.0（完全透明）与 1.0（完全不透明）的数字。</p></li><li><p>HSL 颜色：颜色值是这样规定的：hsl(hue, saturation, lightness)。</p><p>Hue 是色盘上的度数（从 0 到 360） - 0 (或 360) 是红色，120 是绿色，240 是蓝色。Saturation 是百分比值；0% 意味着灰色，而 100% 是全彩。Lightness 同样是百分比值；0% 是黑色，100% 是白色。</p></li><li><p>HSLA 颜色 ：颜色值是这样规定的：hsla(hue, saturation, lightness, alpha)，其中的 alpha 参数定义不透明度。alpha 参数是介于 0.0（完全透明）与 1.0（完全不透明）的数字。</p></li><li><p>预定义/跨浏览器颜色名</p></li></ul><h4 id="6-浮动-float"><a href="#6-浮动-float" class="headerlink" title="6. 浮动(float)"></a>6. 浮动(float)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">margin:0 auto/margin:auto;放置在一个标签上，可以使此标签在父元素中水平居中</span><br><span class="line">width:auto; =不设宽度</span><br><span class="line">  A. 对于块状元素而言,浏览器自动计算，，会与父元素同宽，</span><br><span class="line">  B.  对于块状元素而言，如果盒子浮动了，宽度与内容同宽</span><br><span class="line">  C. 如果给盒子设置具体的width:value，设置的多少，显示多宽</span><br><span class="line">2. 浮动对盒子宽度的影响：     </span><br><span class="line">          </span><br><span class="line">          标签的宽度为：width:auto; </span><br><span class="line">  A. 对于块状元素而言,浏览器自动计算，，会与父元素同宽，</span><br><span class="line">  B.  对于块状元素而言，如果盒子浮动了，宽度与内容同宽</span><br><span class="line">   </span><br><span class="line">          盒子的宽度为：width:value；</span><br><span class="line">          如果给盒子设置具体的width:value，设置的多少，显示多宽           </span><br><span class="line">         3. 浮动对盒子文档流的影响</span><br><span class="line">          添加了浮动的盒子，会脱离正常文档流；</span><br><span class="line">        </span><br><span class="line">         4. 父元素的高度塌陷</span><br><span class="line">         父元素在没有设置具体高度的情况下，子元素全部浮动了，父元素的高度为0；</span><br><span class="line">         </span><br><span class="line">        5. 浮动的图片应用：以往这个属性总应用于图像，使文本围绕在图像周围</span><br><span class="line">        </span><br><span class="line">        6. 浮动元素会生成一个块级框，而不论它本身是何种元素。</span><br></pre></td></tr></table></figure><p> 块状元素，当width的属性值为auto/没写时，浏览器自动计算宽度，宽度是与父元素同宽</p><p>​           宽度：width:auto;</p><p>​           高度：400px</p><p>​           行内元素：不能设置宽度和高度，设置无效</p><h4 id="7-background"><a href="#7-background" class="headerlink" title="7. background"></a>7. background</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">background-image:url(../img/mao.gif);</span><br><span class="line">background-repeat:no-repeat;</span><br><span class="line">background-position:100px 100px;  起始点时左上角  </span><br><span class="line">background-position:100% 100%     起始点时中心</span><br><span class="line">background-position:center;</span><br><span class="line">background-position:227px 99px;</span><br><span class="line"></span><br><span class="line"> 背景颜色：background-color</span><br><span class="line">       背景图片：background-image</span><br><span class="line">       背景重复：background-repeat [rɪ'piːt] 重复</span><br><span class="line">       背景定位：background-position  [pəˈzɪʃən] 位置</span><br><span class="line">       背景状态：background-attachment  [ə'tætʃm(ə)nt] e ta xu ment   </span><br><span class="line">       background：color url repeat position attachment; ['kʌlə(r)]</span><br></pre></td></tr></table></figure><h4 id="8-文本-font-fɒnt"><a href="#8-文本-font-fɒnt" class="headerlink" title="8. 文本(font)[fɒnt]"></a>8. 文本(font)[fɒnt]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">font-size: &#123;      none:[nʌn]  norm:[nɔːm] </span><br><span class="line">    px：设定固定值 </span><br><span class="line">    %:基于父元素的一个百分比值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">font-family: &#123;//规定元素的字体系列</span><br><span class="line">    (1)此属性设置几个字体名称作为一种&quot;后备&quot;机制，如果浏览器不支持第一种字体，将尝试下一种字体。</span><br><span class="line">    (2) 如果字体系列的名称超过一个字，它必须用引号，如Font Family：&quot;宋体&quot;&quot;Times New Roman&quot;。</span><br><span class="line">    (3) 多个字体系列是用一个逗号分隔指明;</span><br><span class="line">&#125;</span><br><span class="line">font-weight:设置显示元素的文本中所用的字体加粗 &#123;  [weɪt]</span><br><span class="line">    1-500=normal ,600-900=bold [bəʊld] </span><br><span class="line">    bolder 更粗</span><br><span class="line">&#125;</span><br><span class="line">font-style: //设置文本倾斜&#123;</span><br><span class="line">italic [ɪ&apos;tælɪk] </span><br><span class="line">oblique  [ə&apos;bliːk]</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">text-align:设置文本水平对齐&#123;  [ə&apos;laɪn] </span><br><span class="line">    left right center [ˈsentə(r)] justify </span><br><span class="line">    行内元素和文本是一样的   文本和行内元素都有作用对 块元素水平居中(0 auto)</span><br><span class="line">&#125;</span><br><span class="line">text-decoration: 文本修饰 [dekə&apos;reɪʃ(ə)n]&#123; // [dekə&apos;reɪʃ(ə)n] </span><br><span class="line">underline:文本下一条线 [ʌndə&apos;laɪn] </span><br><span class="line">overline: 文本上一条线</span><br><span class="line">line-through: 穿过文本一条线 [θruː]</span><br><span class="line">&#125;</span><br><span class="line">text-transform：&#123;  //设置文本大小写  [træns&apos;fɔrm] </span><br><span class="line"> capitalize: [&apos;kæpɪtəlaɪz] 文本单词开头大写</span><br><span class="line">     uppercase: [&apos;ʌpə&apos;keɪs]  文本定义大小</span><br><span class="line">     lowercase: [ləʊə&apos;keɪs] 文本定义小写</span><br><span class="line">&#125;</span><br><span class="line">letter-spacing: &#123; //定义字符之间的间隔</span><br><span class="line">+ -  </span><br><span class="line">对汉字起作用</span><br><span class="line">&#125;</span><br><span class="line">word-spacing: &#123; //定义单词与单词之间的间隔z</span><br><span class="line">只对单词有作用（字母和汉字无效）</span><br><span class="line">&#125;</span><br><span class="line">顺序: font-style | font-variant(小体大写字母) | font-weight | font-size / line-height | font-family </span><br><span class="line">font:[italic] [bold] 20px/&#123;100px] &apos;楷体&apos;;</span><br></pre></td></tr></table></figure><h4 id="9-行高-line-hight"><a href="#9-行高-line-hight" class="headerlink" title="9. 行高(line-hight)"></a>9. 行高(line-hight)</h4><p>文本行的基线间的距离</p><p><img src="/2018/12/26/HTML笔记/C:/Users\meijuna\AppData\Roaming\Typora\typora-user-images\1553307042913.png" alt="1553307042913"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">默认字体16px =&gt; lin-hight=21px;</span><br><span class="line">line-lenght:number 此数字会与当前字体尺寸相乘来设置行间距(2=2em,1em=元素文本大小)</span><br><span class="line">%：基于当前字体尺寸的百分比(100%=当前尺寸)</span><br><span class="line">10px</span><br><span class="line">16px</span><br><span class="line">10px</span><br><span class="line"></span><br><span class="line">10px</span><br><span class="line">16px</span><br><span class="line">10px</span><br><span class="line">文本在行高内垂直居中</span><br><span class="line">应用户单行文本 控制文本的垂直居中 应用于多行文本控制多行文本的间距</span><br></pre></td></tr></table></figure><p><img src="/2018/12/26/HTML笔记/C:/Users\meijuna\AppData\Roaming\Typora\typora-user-images\1553306925881.png" alt="1553306925881"></p><h4 id="10-边框-border"><a href="#10-边框-border" class="headerlink" title="10. 边框(border)"></a>10. 边框(border)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border-color:设置边框颜色 red green blue;上  左右 下</span><br><span class="line">border-weight: </span><br><span class="line">bordrer-style: 设置边框类型 dotted(点状) dashed(虚线) solid(实线) double(双线)</span><br><span class="line">border-width: 元素的所有边框设置宽度，或者单独地为各边边框设置宽度。</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">outline****：（轮廓）**是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用，轮廓线不会占据空间，也不一定是矩形。</span><br><span class="line"></span><br><span class="line">outline-width</span><br><span class="line"></span><br><span class="line">outline-style</span><br><span class="line"></span><br><span class="line">outline-color</span><br><span class="line"></span><br><span class="line">outline:简写</span><br><span class="line"></span><br><span class="line">border跟outline的区别：</span><br><span class="line"></span><br><span class="line">1. border可应用于几乎所有有形的html元素，而outline是针对链接、表单控件和ImageMap等元素设计</span><br><span class="line">2. border占据空间，outline不占据空间</span><br></pre></td></tr></table></figure><h4 id="11-列表-list"><a href="#11-列表-list" class="headerlink" title="11. 列表(list)"></a>11. 列表(list)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list-style：none;去掉列表符号</span><br><span class="line">//定义列表符号的位置</span><br><span class="line">list-style-position:inside（列表项目放置在文本以内，且环绕文本根据标记对齐） outside(默认)</span><br><span class="line">list-style-image: 设置图片作为列表符号</span><br><span class="line">list-type: 设置列表项标记的类型</span><br><span class="line">disc(实心圆)square(实心方块)decimal(数字)</span><br></pre></td></tr></table></figure><h4 id="12-盒模型"><a href="#12-盒模型" class="headerlink" title="12.盒模型"></a>12.盒模型</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、HTML&quot;&gt;&lt;a href=&quot;#一、HTML&quot; class=&quot;headerlink&quot; title=&quot;一、HTML&quot;&gt;&lt;/a&gt;一、HTML&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>优雅的使用 Subline Text3</title>
    <link href="http://yoursite.com/2018/12/25/sbulime/"/>
    <id>http://yoursite.com/2018/12/25/sbulime/</id>
    <published>2018-12-25T11:44:56.643Z</published>
    <updated>2019-03-19T03:41:01.275Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-插件下载安装方法"><a href="#1-插件下载安装方法" class="headerlink" title="1.插件下载安装方法"></a>1.插件下载安装方法</h3><p>快捷键<code>ctrl + shift + p</code>, 打开sublime命令工具，输入 <code>Install Package</code></p><h3 id="2-插件"><a href="#2-插件" class="headerlink" title="2.插件"></a>2.插件</h3><h5 id="1-格式化代码：html-css-js-Prettify"><a href="#1-格式化代码：html-css-js-Prettify" class="headerlink" title="1.格式化代码：html/css/js Prettify"></a>1.格式化代码：html/css/js Prettify</h5><p> 格式化代码快捷键   <code>Ctrl + Shift + H</code></p><h5 id="2-vue语法高亮：-vue-syntax-highlight"><a href="#2-vue语法高亮：-vue-syntax-highlight" class="headerlink" title="2.vue语法高亮： vue-syntax-highlight"></a>2.vue语法高亮： <strong>vue-syntax-highlight</strong></h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-插件下载安装方法&quot;&gt;&lt;a href=&quot;#1-插件下载安装方法&quot; class=&quot;headerlink&quot; title=&quot;1.插件下载安装方法&quot;&gt;&lt;/a&gt;1.插件下载安装方法&lt;/h3&gt;&lt;p&gt;快捷键&lt;code&gt;ctrl + shift + p&lt;/code&gt;, 打开su
      
    
    </summary>
    
      <category term="IDE工具" scheme="http://yoursite.com/categories/IDE%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="sublime，快捷键" scheme="http://yoursite.com/tags/sublime%EF%BC%8C%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + github 搭建个人博客</title>
    <link href="http://yoursite.com/2018/12/25/Hexo%20+%20github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/12/25/Hexo + github 搭建个人博客/</id>
    <published>2018-12-25T07:56:57.878Z</published>
    <updated>2019-03-19T05:53:38.873Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-博客维护"><a href="#1-博客维护" class="headerlink" title="1.博客维护"></a>1.博客维护</h3><h5 id="1-发布文章"><a href="#1-发布文章" class="headerlink" title="1.发布文章"></a>1.发布文章</h5><p>在站点文件夹中打开 git bash，输入如下命令部署和发布文章:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><p><strong>建议</strong>：在使用 <code>hexo g</code> 部署之后，可以先使用 <code>hexo s</code> 运行本地站点，然后在浏览器输入地址 <a href="http://lacolhost:4000/" target="_blank" rel="noopener">http://lacolhost:4000/</a> 查看运行结果，检查无误后再使用 <code>hexo d</code> 发布</p><h5 id="2-新建博客时添加对应的图片文件夹"><a href="#2-新建博客时添加对应的图片文件夹" class="headerlink" title="2.新建博客时添加对应的图片文件夹"></a>2.新建博客时添加对应的图片文件夹</h5><p>将 站点配置文件 中的 post_asset_folde 选项的值设置为 true</p><p>在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件</p><p>这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p><p>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <img src="/2018/12/25/Hexo + github 搭建个人博客/title/example.PNG" alt="示例图片" title="示例图片"> 添加图片</p><h5 id="3-模板设置"><a href="#3-模板设置" class="headerlink" title="3.模板设置"></a>3.模板设置</h5><p>当我们使用命令 <code>hexo new &quot;title&quot;</code> 创建文章时，Hexo 会根据 <code>/scaffolds/post.md</code> 对新文章进行初始化</p><p>换言之，<code>/scaffolds/post.md</code> 就是新文章的 <strong>模板</strong>，所以我们可以修改它来适应自己的写作习惯</p><p>在每篇利用 Hexo 创建的文章的开头，都会有对文章进行说明的文字，叫做 <strong>文章头部</strong></p><p>文章的头部除了可以设置文章标题、发布日期等基础信息外，还可以为文章添加标签、分类等</p><p>一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: Title</span><br><span class="line">date: YYYY-MM-DD HH:MM:SS</span><br><span class="line">tags: [tag1, tag2, ...]</span><br><span class="line">categories: category</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：属性和属性值之间必须有一个空格，否则会解析错误</p><h3 id="2-搭建博客"><a href="#2-搭建博客" class="headerlink" title="2.搭建博客"></a>2.搭建博客</h3><h4 id="1-搭建github博客"><a href="#1-搭建github博客" class="headerlink" title="1.搭建github博客"></a>1.搭建github博客</h4><p>1.github新建博客文件，库名要所有者名字一样，如：<strong>meijuna.github.io</strong> 的格式</p><p>2.Settings =&gt; 选择一个主题保存 就可以访问 meijuna.github.io 了 </p><h4 id="2-Hexo搭建本地博客"><a href="#2-Hexo搭建本地博客" class="headerlink" title="2.Hexo搭建本地博客"></a>2.Hexo搭建本地博客</h4><p><strong>hexo命令</strong></p><p>hexo s(server)  –&gt; 启动本地服务</p><p>hexo  clean –&gt; 清除缓存</p><p>hexo g (generate) –&gt; 创建网页</p><p>hexo d (deploy) –&gt; 同步到github</p><p>1.安装node.js + git </p><p>以Windows环境安装node.js为例，首先登录<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js官网</a>，选择适合自己的版本进行下载，然后进行安装。</p><p>登录<a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a>选择版本进行下载，基本一路<strong>next</strong>下去即可轻松完成安装。</p><p>2.首先在本地磁盘中建立一个Hexo文件夹用于存储本地文件(做本地文件保存以及测试使用)</p><p>3.下载Hexo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>4.初始化博客空间，生成博客运作所需要的文件，接下来安装依赖包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>5.同步Github,允许公共访问</p><p>1.首先找到我们的博客仓库，并拷贝仓库地址：git clone 主题仓库地址 放到 <strong>themes</strong> 文件夹下</p><p>2.打开_config.yml 文件配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">    type: git</span><br><span class="line">    repo: https://github.com/meijuna/meijuna.github.io</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><p>3.最后执行控制台命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git —save //安装部署插件</span><br><span class="line"></span><br><span class="line">hexo d //部署到github</span><br></pre></td></tr></table></figure><p>就用 meijuna.github.io 访问博客了</p><h4 id="2-Hexo-的主题美化"><a href="#2-Hexo-的主题美化" class="headerlink" title="2.Hexo 的主题美化"></a>2.Hexo 的主题美化</h4><p>1.到 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo主题官网</a> 下载主题放到 <strong>themes</strong> 文件夹</p><p>2.配置根目录的 _config.yml 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: pure //选择下载主体文件的名字</span><br></pre></td></tr></table></figure><p>3.hexo clean -&gt; hexo g -d 看效果</p><p>4.具体主题美化看下载的主题文档</p><h4 id="3-在Hexo博客上添加可爱的Live-2D模型"><a href="#3-在Hexo博客上添加可爱的Live-2D模型" class="headerlink" title="3.在Hexo博客上添加可爱的Live 2D模型"></a>3.在Hexo博客上添加可爱的Live 2D模型</h4><p>首先，安装npm包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>然后在hexo的根目录配置文件<code>_config.yml</code>中添加如下配置，详细配置可以参考<a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">文档</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-koharu</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br></pre></td></tr></table></figure><p>然后下载模型，模型名称可以到<a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">这里</a>参考，一些模型的预览可以在<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install live2d-widget-model-koharu</span><br></pre></td></tr></table></figure><p>下载完之后，在 Hexo 根目录中新建文件夹 live2d_models，然后在node_modules文件夹中找到刚刚下载的live2d模型，将其复制到 live2d_models 中，然后编辑<code>_config.ym</code>l配置文件中的model.use项，将其修改为live2d_models文件夹中的模型文件夹名称。</p><p>一切就绪之后，用<code>hexo server</code>命令启动服务器，大功告成！</p><h4 id="4-阿里云解析域名"><a href="#4-阿里云解析域名" class="headerlink" title="4.阿里云解析域名"></a>4.阿里云解析域名</h4><p>1.<a href="https://dns.console.aliyun.com/?spm=5176.100251.111252.14.7e144f15jRG8mz&amp;accounttraceid=9e23cc47-c762-4c2b-af1a-0eac8eaaed46#/dns/domainList" target="_blank" rel="noopener">阿里云</a>购买域名  解析 -&gt; 添加记录  -&gt; A 类型  -&gt; www -&gt; 默认 -&gt; ping  meijuna.github.io 地址的值 -&gt;ttl 10</p><p>3.在根目录下的 source 文件夹 创建 CNAME 文件 ，内容为 <a href="http://www.meijuna.top" target="_blank" rel="noopener">www.meijuna.top</a> </p><h4 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h4><h5 id="1-hexo中添加图片的方法"><a href="#1-hexo中添加图片的方法" class="headerlink" title="1.hexo中添加图片的方法"></a>1.hexo中添加图片的方法</h5><p>1.下载插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save // hexo n &quot;文件&quot; 自动生成相同文件名的文件夹存放图片</span><br></pre></td></tr></table></figure><p>2.设置站点配置_config.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-博客维护&quot;&gt;&lt;a href=&quot;#1-博客维护&quot; class=&quot;headerlink&quot; title=&quot;1.博客维护&quot;&gt;&lt;/a&gt;1.博客维护&lt;/h3&gt;&lt;h5 id=&quot;1-发布文章&quot;&gt;&lt;a href=&quot;#1-发布文章&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Live 2D模型" scheme="http://yoursite.com/tags/Live-2D%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="博客，阿里云" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%EF%BC%8C%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>Mackdown 基本语法</title>
    <link href="http://yoursite.com/2018/12/24/Mackdown%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2018/12/24/Mackdown语法/</id>
    <published>2018-12-24T01:35:48.462Z</published>
    <updated>2019-03-19T06:23:15.120Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Markdown-简介"><a href="#1、Markdown-简介" class="headerlink" title="1、Markdown 简介"></a>1、Markdown 简介</h3><p>但是，在我们正式写下第一个文字前，我们需要了解一下究竟什么是 Markdown？</p><blockquote><p>Markdown 是一种可以使用普通文本编辑器编写的 标记语言，通过简单的 标记语法，它可以使普通文本内容具有一定的格式</p></blockquote><p>基于 Markdown 语法的简洁性，它已经成为目前世界上最流行的用于书写博客的语言</p><h3 id="2、Markdown-语法"><a href="#2、Markdown-语法" class="headerlink" title="2、Markdown 语法"></a>2、Markdown 语法</h3><p>2、Markdown 语法<br>在编写 Markdown 时，博主强烈的推荐给大家一款简洁易用的 Markdown 编辑器 —— Typora</p><p>按照官方的说法就是 简单而强大，它不仅支持原生的语法，也支持对应的快捷键，更重要的是它还可以 实时预览</p><p>这里附上 Typora 的下载地址：<a href="https://www.typora.io/，有兴趣的朋友可以下载来试试" target="_blank" rel="noopener">https://www.typora.io/，有兴趣的朋友可以下载来试试</a></p><p>好，下面开始进入正题，介绍一些常用的 Markdown 语法</p><h4 id="（1）标题"><a href="#（1）标题" class="headerlink" title="（1）标题"></a>（1）标题</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line"></span><br><span class="line">## 二级标题</span><br><span class="line"></span><br><span class="line">### 三级标题</span><br><span class="line"></span><br><span class="line">#### 四级标题</span><br><span class="line"></span><br><span class="line">##### 五级标题</span><br><span class="line"></span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>Typora 快捷键：</p><p>Ctrl+1：一级标题</p><p>Ctrl+2：二级标题</p><p>Ctrl+3：三级标题</p><p>Ctrl+4：四级标题</p><p>Ctrl+5：五级标题</p><p>Ctrl+6 ：六级标题</p><p>Ctrl+0：段落</p><h4 id="（2）粗体、斜体、删除线和下划线"><a href="#（2）粗体、斜体、删除线和下划线" class="headerlink" title="（2）粗体、斜体、删除线和下划线"></a>（2）粗体、斜体、删除线和下划线</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>Typora 快捷键：</p><p>Ctrl+I：斜体</p><p>Ctrl+B：粗体</p><p>Ctrl+U：下划线</p><p>Alt+Shift+5：删除线</p><h4 id="（3）引用块"><a href="#（3）引用块" class="headerlink" title="（3）引用块"></a>（3）引用块</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文字引用：</span><br><span class="line">&gt;Typora 快捷键： Ctrl+Shift+Q</span><br></pre></td></tr></table></figure><h4 id="（4）代块"><a href="#（4）代块" class="headerlink" title="（4）代块"></a>（4）代块</h4><p>Markdown 语法：</p><p>行内代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">行内代码</span><br><span class="line"></span><br><span class="line">多行代码：</span><br><span class="line"></span><br><span class="line">多行代码</span><br><span class="line">多行代码</span><br><span class="line">多行代码</span><br></pre></td></tr></table></figure><p>Typora 快捷键：</p><p>行内代码：Ctrl+Shift+`</p><p>多行代码：Ctrl+Shift+K</p><h4 id="（5）公式块"><a href="#（5）公式块" class="headerlink" title="（5）公式块"></a>（5）公式块</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">数学公式</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>Typora 快捷键： Ctrl+Shift+M</p><h4 id="（6）分割线"><a href="#（6）分割线" class="headerlink" title="（6）分割线"></a>（6）分割线</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法一：---</span><br><span class="line"></span><br><span class="line">方法二：+++</span><br><span class="line"></span><br><span class="line">方法三：***</span><br></pre></td></tr></table></figure><h4 id="（7）列表"><a href="#（7）列表" class="headerlink" title="（7）列表"></a>（7）列表</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表项</span><br><span class="line"></span><br><span class="line">* 无序列表项</span><br><span class="line"></span><br><span class="line">+ 无序列表项</span><br><span class="line"></span><br><span class="line">- 无序列表项</span><br></pre></td></tr></table></figure><p>Typora 快捷键：</p><p>有序列表项：Ctrl+Shift+[</p><p>无序列表项：Ctrl+Shift+]</p><h4 id="（8）表格"><a href="#（8）表格" class="headerlink" title="（8）表格"></a>（8）表格</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表头1|表头2</span><br><span class="line">-|-|-</span><br><span class="line">内容11|内容12</span><br><span class="line">内容21|内容22</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头1</th><th>表头2</th></tr></thead><tbody><tr><td>内容11</td><td>内容12</td></tr><tr><td>内容21</td><td>内容22</td></tr></tbody></table><p>Typora 快捷键： <strong>Ctrl+T</strong></p><h4 id="（9）超链接"><a href="#（9）超链接" class="headerlink" title="（9）超链接"></a>（9）超链接</h4><p>Markdown语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法一：[链接文字](链接地址 &quot;链接描述&quot;)</span><br><span class="line">例如：[示例链接](https://www.example.com/ &quot;示例链接&quot;)</span><br><span class="line"></span><br><span class="line">方法二：&lt;链接地址&gt;</span><br><span class="line">例如：&lt;https://www.example.com/&gt;</span><br></pre></td></tr></table></figure><p>Typora快捷键： <strong>Ctrl+K</strong></p><h4 id="（10）图片"><a href="#（10）图片" class="headerlink" title="（10）图片"></a>（10）图片</h4><p>Markdown语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![图片文字](图片地址 &quot;图片描述&quot;)</span><br><span class="line">例如：![示例图片](https://www.example.com/example.PNG &quot;示例图片&quot;)</span><br></pre></td></tr></table></figure><p>Typora快捷键： <strong>Ctrl+Shift+I</strong></p><p><strong>说明</strong>：在 Hexo中 插入图片时，请按照以下的步骤进行设置</p><ol><li>将 站点配置文件 中的 post_asset_folde 选项的值设置为 true</li></ol><ol start="2"><li><p>在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件</p></li><li><p>这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p></li><li>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <code>![示例图片](title/example.PNG &quot;示例图片&quot;)</code> 添加图片</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Markdown-简介&quot;&gt;&lt;a href=&quot;#1、Markdown-简介&quot; class=&quot;headerlink&quot; title=&quot;1、Markdown 简介&quot;&gt;&lt;/a&gt;1、Markdown 简介&lt;/h3&gt;&lt;p&gt;但是，在我们正式写下第一个文字前，我们需要了解一下究
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Mackdown" scheme="http://yoursite.com/tags/Mackdown/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="http://yoursite.com/2018/12/21/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9D%A1%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/12/21/我的第一条博客/</id>
    <published>2018-12-21T15:03:47.376Z</published>
    <updated>2019-03-19T05:59:24.902Z</updated>
    
    <content type="html"><![CDATA[<p>Hello, 欢迎来到我的博客，以后我会不定时的发布博客，记录生活！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hello, 欢迎来到我的博客，以后我会不定时的发布博客，记录生活！&lt;/p&gt;

      
    
    </summary>
    
      <category term="测试" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
</feed>
