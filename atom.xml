<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MeiJuna</title>
  
  <subtitle>一行代码 一行诗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://meijuna.github.io/"/>
  <updated>2019-07-04T12:35:33.237Z</updated>
  <id>http://meijuna.github.io/</id>
  
  <author>
    <name>MeiJuna</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vuex</title>
    <link href="http://meijuna.github.io/2019/07/03/vuex/"/>
    <id>http://meijuna.github.io/2019/07/03/vuex/</id>
    <published>2019-07-03T01:30:05.000Z</published>
    <updated>2019-07-04T12:35:33.237Z</updated>
    
    <content type="html"><![CDATA[<p>vux 的组成部分</p><p>vuex的核心组成部分： state、Actions、Mutaions</p><p>后端数据请求写在Actions 里</p><p>数据流向？ </p><p>​    </p><p>核心组成部分？</p><p>Actions Muta</p><p>store</p><p>​    index.js</p><ol><li><p>引入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line"></span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line">import state from &apos;./state&apos;</span><br><span class="line">import actions from &apos;./actions&apos;</span><br><span class="line">import mutations from &apos;./mutations&apos;</span><br><span class="line">import getters from &apos;./getters&apos;</span><br><span class="line">Vue.use( Vuex )</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">state, //state 就是状态（数据）</span><br><span class="line">actions,  // 用户交互发出的东子</span><br><span class="line">mutations, // 修改数据</span><br><span class="line">getters  //获取数据</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">export defalut store</span><br></pre></td></tr></table></figure><p>state.js</p></li></ol><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const state = &#123;</span><br><span class="line">    count:0</span><br><span class="line">&#125;</span><br><span class="line">export default state</span><br></pre></td></tr></table></figure>actions.js   //是一个对象，是用来存储用户交互的方法，并且发送动作给 mutations<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import * as type from &apos;./type&apos;</span><br><span class="line">const ations =&#123;</span><br><span class="line">//都是方法</span><br><span class="line">  add( store对象，组件传来的数据) &#123;</span><br><span class="line"> //1 创建动作</span><br><span class="line"> const action = &#123;</span><br><span class="line">type: type.INCREMENT,</span><br><span class="line">payload: food //视图传来的数据陈 负载</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//2. 发送动作个 mutations</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>3. type.js    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const INCREMENT = &quot;INCREME&quot;</span><br></pre></td></tr></table></figure>4. mutations.js //是一个对象，存储的方法是用来修改数据的   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import * as type from &apos;./type&apos;</span><br><span class="line">const mutations = &#123;</span><br><span class="line">   [ type.INCREMENT ] (state, actions ) &#123;  // 数据， 动作</span><br><span class="line">state.count ++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">export default mutations</span><br></pre></td></tr></table></figure>5.  getters.js    // 是一个对象，1. 存储的是方法，必须有方绘制6. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const getters =&#123;</span><br><span class="line">getCount (state)  // 数据</span><br><span class="line">return state.count</span><br><span class="line">&#125;</span><br><span class="line">exppo</span><br></pre></td></tr></table></figure></code></pre><p>this.$store.dispatch(‘add’)</p><p>辅助工具：</p><ol><li><p>mapActions  mapMutations map Getters </p><p>好处：</p><ol><li>当用户交互过多时，重复代码过多</li><li>分担视图中的部分逻辑，减轻视图的负担</li></ol></li><li><p>是使用…结构的好处</p><ol><li>按需</li><li>可以据需在当前组件内自定义事件处理程序</li></ol></li></ol><p>module  </p><p>​    可以将数据分块管理，方便将来维护</p><p>vue 通过交 module 模块</p><p>vue 项目中 store 下的一个目录就是一个数据包</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vux 的组成部分&lt;/p&gt;
&lt;p&gt;vuex的核心组成部分： state、Actions、Mutaions&lt;/p&gt;
&lt;p&gt;后端数据请求写在Actions 里&lt;/p&gt;
&lt;p&gt;数据流向？ &lt;/p&gt;
&lt;p&gt;​    &lt;/p&gt;
&lt;p&gt;核心组成部分？&lt;/p&gt;
&lt;p&gt;Actions Mu
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack 的基本概念和配置</title>
    <link href="http://meijuna.github.io/2019/06/28/webpack/"/>
    <id>http://meijuna.github.io/2019/06/28/webpack/</id>
    <published>2019-06-28T01:05:17.000Z</published>
    <updated>2019-06-29T13:53:49.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack-的基本概念和配置"><a href="#webpack-的基本概念和配置" class="headerlink" title="webpack 的基本概念和配置"></a>webpack 的基本概念和配置</h1><h2 id="一、市面上有哪些类似于-Webpack-的前端工程化工具？"><a href="#一、市面上有哪些类似于-Webpack-的前端工程化工具？" class="headerlink" title="一、市面上有哪些类似于 Webpack 的前端工程化工具？"></a>一、市面上有哪些类似于 Webpack 的前端工程化工具？</h2><ol><li>grunt  (14-16年)</li><li>gulp  ( 4.x )  流的操作 .pipe()</li><li>Browserify ( Webpack 前身)  没有兼容模块化问题（ es6 ）</li><li>Webpack   ( 主流行 )   自动解决模块化的依赖问题</li></ol><h2 id="二、-webpakc-的概念"><a href="#二、-webpakc-的概念" class="headerlink" title="二、 webpakc 的概念"></a>二、 webpakc 的概念</h2><blockquote><p>webpack<em> 是一个现代 JavaScript 应用程序的</em>静态模块打包器(module bundler)<em>。当 webpack 处理应用程序时，它会递归地构建一个</em>依赖关系图(dependency graph)<em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 </em>bundle*（ 分块束 ）</p></blockquote><h2 id="三、Webpack-版本的发展过程"><a href="#三、Webpack-版本的发展过程" class="headerlink" title="三、Webpack 版本的发展过程"></a>三、Webpack 版本的发展过程</h2><p>​    官网: <a href="https://webpack.js.org/" target="_blank" rel="noopener">https://webpack.js.org/</a></p><p>​    中文: <a href="https://www.webpackjs.com/" target="_blank" rel="noopener">https://www.webpackjs.com/</a></p><p> <strong>webpack1</strong></p><p>​        支持CMD和AMD，同时拥有丰富的plugin和loader，webpack逐渐得到广泛应用。</p><p> <strong>webpack2</strong> </p><p>​        支持ES Module，分析ESModule之间的依赖关系，</p><p>​        webpack1必须将ES，Module转换成CommonJS模块，2支持tree sharking</p><p> <strong>webpack3</strong> </p><p>​        新的特性大都围绕ES Module提出，如Scope Hoisting和Magic Comment；</p><p>​                webpack3以上基本上都可以解决es6提出的模块化</p><p><strong>webpack4</strong></p><p>​            可以解决es6模块化</p><p>​        更多个功能性 pulgin  和  loader     </p><p>​        前端框架中广泛使用： Angular  Vue  React  的脚手架都是由webpack来进行开发、管理</p><p><strong>对比总结</strong>：</p><p>webpack 2 比 webpack1 多的是对 es 模块的支持，</p><p>webpack3 比 webpack2 多的是es 模块功能性的的增加，如 Scope Hoistion（ 作用域 ）和  Magic Comment (注释语法）</p><p>webpack4 增加了 更多的 个性化插件和 和 loader( 转换器)，对 es 6 模块更加支持，在前端的框架中广泛使用（Vue/ Angular React 的脚手架都是由 webpack 来开发和管理的 ）</p><h2 id="四、Webpack-涉及到的前端环境问题"><a href="#四、Webpack-涉及到的前端环境问题" class="headerlink" title="四、Webpack 涉及到的前端环境问题"></a>四、Webpack 涉及到的前端环境问题</h2><ol><li>Webpack 底层是由 Node 来开发的，也就是说 webpack 的配置文件的是 Node 文件    </li><li>Webpack 的模块化书写的规范是 Common.js 规范</li><li>环境支持： Node 8+</li><li><p>前端环境</p><ul><li>开发环境     - 无法直接在服务器中运行</li><li>生产环境    -  将开发环境下的代码经过打包、压缩、编译、之后的文件</li><li>测试环境    -  将开发环境下的代码经过打包、压缩、编译、之后的文件 放在测试环境服务器运行，测试是否有 BUG<ul><li>unit test   单元测试</li><li>e2e         端到端测试</li></ul></li><li>预上线环境 -  将开发环境下的代码经过打包、压缩、编译、之后的文件 放在局域网运行</li><li>上线环境    -  将开发环境的代码经过打包、压缩、编译、之后的文件 放在云服务器或服务器主机中，可以供任何人访问和使用（这个环境上线要经过国家的审核）</li></ul></li><li><p>前端核心关注点在：<br>​    - 开发环境<br>​    - 生产环境</p></li></ol><h2 id="五、Webpack-的安装"><a href="#五、Webpack-的安装" class="headerlink" title="五、Webpack 的安装"></a>五、Webpack 的安装</h2><blockquote><p>安装可以使用任意一个包管理器： cpm yarn cnpm</p><p>优先级 ：yarn &gt; cnpm &gt; npm </p><p>举例： 使用 npm 安装 node-sass 的包出错了，卸载时出错</p><p>解决： 需要换个包管理器覆盖安装</p><p>cnpm  ||  yarn 进行覆盖安装</p></blockquote><h3 id="1-全局安装"><a href="#1-全局安装" class="headerlink" title="1.  全局安装"></a>1.  全局安装</h3>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli -g</span><br><span class="line"></span><br><span class="line">cnpm install webpack webpack-cli -g</span><br><span class="line"></span><br><span class="line">yarn add webpack webpack-cli -g</span><br></pre></td></tr></table></figure><h4 id="2-局部安装"><a href="#2-局部安装" class="headerlink" title="2. 局部安装"></a>2. 局部安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli -D</span><br><span class="line">   </span><br><span class="line">cnpm install webpack webpack-cli -D</span><br><span class="line">   </span><br><span class="line">yarn add webpack webpack-cli -D</span><br></pre></td></tr></table></figure><h2 id="六、-Webpack-的使用"><a href="#六、-Webpack-的使用" class="headerlink" title="六、 Webpack 的使用"></a>六、 Webpack 的使用</h2><blockquote><p>默认源代码开发目录为： src</p><p>默认的入口文件为： scr/index.js</p><p>默认的出口目录为： dist</p><p>默认的出口打包文件： main.js</p></blockquote><h3 id="1-终端命令行使用"><a href="#1-终端命令行使用" class="headerlink" title="1. 终端命令行使用"></a>1. 终端命令行使用</h3><ul><li><p>终端运行 webpack  -配置项</p><ul><li><p>默认以生产环境打包</p></li><li><p>设置开发环境打包 or 生产环境打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --mode development/production</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-配置文件使用-推荐"><a href="#2-配置文件使用-推荐" class="headerlink" title="2. 配置文件使用( 推荐)"></a>2. 配置文件使用( 推荐)</h3><blockquote><p>由于命令行使用需要多个配置参数，很麻烦，这时候就需要用 webpack.config.js 这个文件配置文件来配置参数</p></blockquote><ul><li><p>默认  webpack 配置文件名为 webpack.config.js，这个文件需要在根元素下运行</p></li><li><p>运行 webpack 命令 就会自动去寻找 webpack.config.js 文件</p></li><li><p>webpack.config.js 文件中，我们就是配置的就是 webpack 的参数</p></li></ul><h3 id="3-配置-webpack"><a href="#3-配置-webpack" class="headerlink" title="3. 配置  webpack"></a>3. 配置  webpack</h3><blockquote><p>这个配置文件是一个 Node.js 文件，也就是一个独立的 Common.js 模块，需要创建和导出</p></blockquote><p>主要这要以下功能进行配置</p><ol><li><p>基础功能 : 入口 出口 文件配置</p></li><li><p>转换器 :loader</p></li><li><p>插件: plugin</p></li></ol><h4 id="1-单页面配置"><a href="#1-单页面配置" class="headerlink" title="1.单页面配置"></a>1.单页面配置</h4><h5 id="1-1-基础功能配置"><a href="#1-1-基础功能配置" class="headerlink" title="1.1 基础功能配置"></a>1.1 基础功能配置</h5><h6 id="1-1-1-入口-出口"><a href="#1-1-1-入口-出口" class="headerlink" title="1.1.1  入口 出口"></a>1.1.1  入口 出口</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpackConfig  = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,              <span class="comment">//入口文件，网络路径 （相对路径）,</span></span><br><span class="line">  output: &#123;          <span class="comment">//出口</span></span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>), <span class="comment">//出口的目录，磁盘路径</span></span><br><span class="line">    filename: <span class="string">'js/app.js'</span> ,             <span class="comment">//出口文件的名字</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">'development'</span>                   <span class="comment">// 确定是生产环境还是开发环境的打包</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//导出模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig;</span><br></pre></td></tr></table></figure><h5 id="1-2-loader-转换器-配置"><a href="#1-2-loader-转换器-配置" class="headerlink" title="1.2 loader (转换器) 配置"></a>1.2 loader (转换器) 配置</h5><h6 id="1-2-1-转换-css"><a href="#1-2-1-转换-css" class="headerlink" title="1.2.1  转换 css"></a>1.2.1  转换 css</h6><ul><li><p>安装转换器需要的包</p><p>  cnpm i css-loader  style-loader  -D </p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以将其他类型文件，转换为我们想要的类型文件</span></span><br><span class="line"> css-loader: 在 js 文件中 识别 css</span><br><span class="line">style-loader: 将 js 编译过后的 css 文件，转成 css 内部样式 插入到页面</span><br><span class="line"> <span class="comment">// ---------------转换器 ----------------</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;  <span class="comment">//存放转换器的配置</span></span><br><span class="line">    rules: [            <span class="comment">//rulse数组来存放转换器</span></span><br><span class="line">      &#123;                 <span class="comment">//每一个对象就是一个转换器啊</span></span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,   <span class="comment">//整个项目匹配 .css 结尾的文件</span></span><br><span class="line">        use: [<span class="string">'style-loader'</span>,<span class="string">'css-loader'</span>]   <span class="comment">//越靠前，缺后执行</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h6 id="1-2-2-babel-优雅降级"><a href="#1-2-2-babel-优雅降级" class="headerlink" title="1.2.2 babel 优雅降级"></a>1.2.2 babel 优雅降级</h6><p>  ES6+ –&gt;  ES5 </p><ul><li><p>安装转换器需要的包</p><p> <code>$ cnpm install babel-loader@8.0.4 @babel/core @babel/preset-env -D</code></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在webpack.config.js的module &gt; rules中进行配置</span></span><br><span class="line">&#123;<span class="comment">// 配置优雅降级</span></span><br><span class="line">       test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">       exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">       use: [&#123;</span><br><span class="line">         loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">         options: &#123;</span><br><span class="line">           presets: [<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;]</span><br><span class="line">   </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ul><h6 id="1-3-3-图片打包"><a href="#1-3-3-图片打包" class="headerlink" title="1.3.3  图片打包"></a>1.3.3  图片打包</h6><ul><li>安装转换器需要的包</li></ul><p><code>$ cnpm  i url-loader file-loader -D</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//url-loader 存base64  file-loader存文件（woff mp3）</span></span><br><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.(png|jpg|gif)/</span>,</span><br><span class="line">    use:[&#123;</span><br><span class="line">      loader: <span class="string">'url-loader'</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        limit: <span class="number">4000</span>,<span class="comment">//字节少于4000 ——》 base64  超过4000  file</span></span><br><span class="line">        outputPath: <span class="string">'img/'</span>, <span class="number">5000</span>意思存到images</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-plugin-插件-配置"><a href="#1-3-plugin-插件-配置" class="headerlink" title="1.3 plugin (插件) 配置"></a>1.3 plugin (插件) 配置</h5><h6 id="1-3-1-html-产出"><a href="#1-3-1-html-产出" class="headerlink" title="1.3.1 html 产出"></a>1.3.1 html 产出</h6><ul><li><p>安装插件需要的第三方包</p><p><code>$ cnpm i html-webpack-plugin -D</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个配置项</span></span><br><span class="line">    plugins:[</span><br><span class="line">            <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">                template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">                filename: <span class="string">'./index.html'</span>,<span class="comment">//默认到output目录</span></span><br><span class="line">                hash:<span class="literal">true</span>,   <span class="comment">//防止缓存,会给文件后面加入hash</span></span><br><span class="line">                minify:&#123;</span><br><span class="line">                    removeAttributeQuotes:<span class="literal">true</span><span class="comment">//压缩 去掉引号</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure></li></ul><h6 id="1-3-2-css抽离"><a href="#1-3-2-css抽离" class="headerlink" title="1.3.2  css抽离"></a>1.3.2  css抽离</h6><blockquote><p>将 webpack 编译过得css文件以 css外部引用的形式引入</p></blockquote><ul><li><p>安装插件</p><p><code>$ cnpm i extract-text-webpack-plugin -D</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextWebapckPlugin= <span class="built_in">require</span>(<span class="string">"extract-text-webpack-plugin"</span>)</span><br><span class="line">   <span class="comment">//loader配置：</span></span><br><span class="line">   use: ExtractTextWebapckPlugin.extract(&#123;    <span class="comment">//不再需要style-loader</span></span><br><span class="line">         use: <span class="string">'css-loader'</span></span><br><span class="line">    &#125;) </span><br><span class="line">     </span><br><span class="line">  <span class="comment">//pulgin配置  </span></span><br><span class="line"> <span class="keyword">new</span> ExtractTextWebapckPlugin(<span class="string">'css/[name][hash:6].css'</span>)</span><br></pre></td></tr></table></figure></li></ul><h6 id="1-3-3-静态资源拷贝"><a href="#1-3-3-静态资源拷贝" class="headerlink" title="1.3.3  静态资源拷贝"></a>1.3.3  静态资源拷贝</h6><p>安装插件</p><p><code>$  cnpm i copy-webpack-plugin -D</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>)</span><br><span class="line"><span class="comment">//plugin配置</span></span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">      &#123; <span class="attr">from</span>: path.resolve(__dirname,<span class="string">'static'</span>), <span class="attr">to</span>: path.resolve(__dirname,<span class="string">'build/static'</span>) &#125;</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><h5 id="1-4-其他配置"><a href="#1-4-其他配置" class="headerlink" title="1.4 其他配置"></a>1.4 其他配置</h5><h6 id="1-41-前端静态服务器配置"><a href="#1-41-前端静态服务器配置" class="headerlink" title="1.41 前端静态服务器配置"></a>1.41 前端静态服务器配置</h6><blockquote><p>运行服务器需要本地安装 webpack webpack-cli webpack-dev-server -D </p></blockquote><ol><li><p>命令行使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack-dev-server --port 9000 --open</span><br></pre></td></tr></table></figure></li><li><p>写在 webpack.config.js 配置文件</p><ol><li>命令行使用不方便，可以在配置 webpack.config.js 中配置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">devServer:&#123;</span><br><span class="line">port: 8088,</span><br><span class="line">open: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在package.json scripts 标签下添加</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server"</span> <span class="comment">//不用加参数，因为在配置文件配置过了，直接输入npm run dev 开启服务器</span></span><br><span class="line"> &#125;</span><br><span class="line"> or</span><br><span class="line">  <span class="string">"scripts"</span>:&#123;</span><br><span class="line">     <span class="string">"dev"</span>: <span class="string">"webpack-dev-server  --port 8088 --open"</span> <span class="comment">//直接在 scripts 写参数， 不需要在webpack配置文件中配置</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="1-4-2-省略引入文件名后缀"><a href="#1-4-2-省略引入文件名后缀" class="headerlink" title="1.4.2 省略引入文件名后缀"></a>1.4.2 省略引入文件名后缀</h6>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">   extensions: [&apos;.js&apos;, &apos;.css&apos;, &apos;.json&apos;, &apos;.jsx&apos;, &apos;.vue&apos;, &apos;.png&apos;, &apos;.sass&apos;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="1-4-3-配置文件拆分"><a href="#1-4-3-配置文件拆分" class="headerlink" title="1.4.3 配置文件拆分"></a>1.4.3 配置文件拆分</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">   <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">   <span class="string">"dev"</span>:   <span class="string">"webpack --config config/webpack.config.dev.js"</span>,</span><br><span class="line">   <span class="string">"build"</span>: <span class="string">"webpack --config config/webpack.config.prod.js"</span>,</span><br><span class="line">   <span class="string">"server"</span>:  <span class="string">"webpack-dev-server --config config/webpack.config.dev.js"</span>,</span><br><span class="line">   <span class="string">"prod"</span>: <span class="string">"webpack-dev-server --config config/webpack.config.prod.js"</span>,</span><br><span class="line">   <span class="string">"devAndStart"</span> : <span class="string">"npm run dev &amp; npm run server"</span>,</span><br><span class="line">   <span class="string">"buildAndStart"</span>: <span class="string">"npm run build &amp; npm run prod "</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h6 id="1-4-4-错误资源定制"><a href="#1-4-4-错误资源定制" class="headerlink" title="1.4.4 错误资源定制"></a>1.4.4 错误资源定制</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在webpack.config.js中添加如下配置项：</span></span><br><span class="line">devtool: <span class="string">'source-map'</span>  </span><br><span class="line">制定报错信息的源,不然错误会指向编译打包后的代码</span><br></pre></td></tr></table></figure><h4 id="2-多页面配置"><a href="#2-多页面配置" class="headerlink" title="2. 多页面配置"></a>2. 多页面配置</h4><p>2.1 基础功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="comment">// 1. 创建模块</span></span><br><span class="line"><span class="keyword">const</span> webpackConfig = &#123;</span><br><span class="line">  entry: &#123;   <span class="comment">// 多页面配置，多个入口文件 &#123;  key: value  &#125; </span></span><br><span class="line">    <span class="string">'index'</span>: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    <span class="string">'main'</span>: <span class="string">'./src/main.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123; <span class="comment">//出口目录、文件的配置</span></span><br><span class="line">    path: path.join( __dirname,<span class="string">'dist'</span>), <span class="comment">// 磁盘路径</span></span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>           <span class="comment">// 入口文件将来打包到出口目录中的文件的路径和名称 js/key.js</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">'development'</span>                 <span class="comment">//确定是生产环境还是开发环境的打包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 导出模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = webpackConfig</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;webpack-的基本概念和配置&quot;&gt;&lt;a href=&quot;#webpack-的基本概念和配置&quot; class=&quot;headerlink&quot; title=&quot;webpack 的基本概念和配置&quot;&gt;&lt;/a&gt;webpack 的基本概念和配置&lt;/h1&gt;&lt;h2 id=&quot;一、市面上有哪些类
      
    
    </summary>
    
      <category term="webpack" scheme="http://meijuna.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://meijuna.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>vue cli</title>
    <link href="http://meijuna.github.io/2019/06/27/vue-cli/"/>
    <id>http://meijuna.github.io/2019/06/27/vue-cli/</id>
    <published>2019-06-27T13:28:13.000Z</published>
    <updated>2019-06-29T04:03:06.403Z</updated>
    
    <content type="html"><![CDATA[<p>Vue cli </p><p>什么是cli?</p><p>文档 <a href="https://cli.vuejs.org/zh/config/#%E7%9B%AE%E6%A0%87%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">https://cli.vuejs.org/zh/config/#%E7%9B%AE%E6%A0%87%E6%B5%8F%E8%A7%88%E5%99%A8</a></p><p>cli是vue 提供的一个快速构建项目环境的一个工具，底层是使用的是 webpack。</p><p>目前 cli 有哪些版本？</p><p>cli2 cli3</p><p>cli 使用</p><ol><li><p>clide anzhuan </p><p>npm/cnpm/yarn 都可以</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add @vue/cli -global  // cli3 版本</span><br><span class="line"></span><br><span class="line">yarn add @vue/cli-init -global // cli2, cli3 共存调节工具</span><br></pre></td></tr></table></figure><ol start="2"><li><p>验证是否成功</p><p>命令行输入：<code>$vue</code> 查看是否按照成功</p></li><li><p>创建项目</p><p>cli3 版本创建</p><p>1.命令行创建 【推荐】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create projectName</span><br></pre></td></tr></table></figure><ul><li>手动配置</li><li>如果安装node-sass 出现问题，解决：<ul><li>使用cnpm 安装  cnpm i node-sass sass-loader -D</li></ul></li><li><img src="/2019/06/27/vue-cli/1.jpg" alt="./"></li></ul><ol start="2"><li><p>please pick a preset( user arrow keys ) 使用键盘上下键来选择一个配置 （我选的是手动配置）</p></li><li><p>default 默认配置</p></li><li><p>Manually select features 手动选择配置</p><p>   配置的是webpack</p><p>   babel:  优雅降级 ,es6/7 –&gt; es5</p><p>   eslint:   js 语法检查</p><p>3.选择配置到你的项目，空格选择，a 选择全部，i  反选</p><p><img src="/2019/06/27/vue-cli/2.jpg" alt=""></p><p>PWA  (web app ) 在浏览器中使用的app</p><p>CSS Pre-processors css 预处理语言  less  sass/scss  stylus</p><p> Linter / Formatter              =》 eslint  /   jslint</p><p> Unit Testing   单元测试     =》测试项目中单元模块</p><p> E2E Testing   端到端的测试</p><p>In dedicated config files   将所选的每一个选项用一个文件来保存（ 配置 ）</p><p>4.选择一种 css 预处理器</p><p><img src="/2019/06/27/vue-cli/3.jpg" alt=""></p></li></ol></li></ol></li></ol><ol start="5"><li>你是选择刚才选的配置放在单独的文件里还是放在 package.json 里</li><li>鼎折覆餗=dd</li><li><img src="/2019/06/27/vue-cli/4.jpg" alt=""></li></ol><p>Save this as a preset for future projects?  将上面所选的配置保存下来，以备将来的项目使用,shu</p><p><img src="/2019/06/27/vue-cli/5.png" alt=""></p><p>​<br>​<br>​<br>​    2.图像界面创建<br>​      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">​      vue ui</span><br><span class="line">​</span><br></pre></td></tr></table></figure></p><p>​<br>​      cli2 </p><p><img src="/2019/06/27/vue-cli/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1561645381458.png" alt="1561645381458"></p><p>cli2</p><p>标准版 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack projectName</span><br></pre></td></tr></table></figure><p>简易版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack-simple projectName</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue cli &lt;/p&gt;
&lt;p&gt;什么是cli?&lt;/p&gt;
&lt;p&gt;文档 &lt;a href=&quot;https://cli.vuejs.org/zh/config/#%E7%9B%AE%E6%A0%87%E6%B5%8F%E8%A7%88%E5%99%A8&quot; target=&quot;_blank
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue 虚拟DOM和diff算法</title>
    <link href="http://meijuna.github.io/2019/06/26/vue%20%E8%99%9A%E6%8B%9FDOM%E5%92%8Cdiff%E7%AE%97%E6%B3%95/"/>
    <id>http://meijuna.github.io/2019/06/26/vue 虚拟DOM和diff算法/</id>
    <published>2019-06-26T14:20:01.000Z</published>
    <updated>2019-07-02T15:05:34.881Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟DOM &amp;&amp; diff 算法</p><p>Vue 是一个 mvvm 框架，Vue高性能的原因之一是使用的 vdom </p><ol><li><p>虚拟dom 是什么？</p><p>  是 js 中的对象模型，用对象的结构来模拟真实DOM</p></li><li><p>虚拟DOM的使用基本流程</p><p>  先获取数据 ，在创建 jsx 语法糖，然后根据 render 函数将 jsx 生成虚拟对象结构再根据对象结构生成真实的DOM 。当数据改变时， 第二次生成虚拟DOM，然后通过 diff 算法进行对比，生成 path 对象。根据key将patch对象使用render函数渲染到页面中改变的结构上，而其他没有改变的地方是不做任何修改的 ——也叫虚拟dom的 惰性原则 。</p></li><li><p>什么是 jsx?<br>  就是 javascript + xml ，可以在 js 中可以写 标签结构</p></li><li><p>diff 算法是什么？</p><p>diff 来源 于后端，是比较两个文件的差异的算法。</p><p>前端将其应用到了 虚拟dom 当中去， 将 diff 算法放在了 patch.js 文件中，使用 js 来对两个虚拟DOM对象进行比较。</p><p>diff 算法运行结束，返回的是一个补丁对象（patch对象）</p><p>diff 算法是同级比较，给每一个层级打一个数字标记，这个标记就是 key ，根据key 进行同级比较，父级元素比完比子元素，直到没有子元素。</p></li><li><p>什么是key?</p><ul><li>跟踪每个节点身份，从而重用和重新排序现有的元素</li><li><p>理想的 key 值都是每个项都有的且唯一的 id</p><p>为什么列表循环要加key?</p><p>​    需要给每一个节点添加一个唯一的标识key，vue 通过key 进行重用和重新排序现有元素。</p><p>key要注意什么?</p></li></ul><ol><li><p>类型只能是 number 和String</p></li><li><p>通过v-bind 属性绑定的形式来    指定key 的值</p></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虚拟DOM &amp;amp;&amp;amp; diff 算法&lt;/p&gt;
&lt;p&gt;Vue 是一个 mvvm 框架，Vue高性能的原因之一是使用的 vdom &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;虚拟dom 是什么？&lt;/p&gt;
&lt;p&gt;  是 js 中的对象模型，用对象的结构来模拟真实DOM&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue 自定义组件</title>
    <link href="http://meijuna.github.io/2019/06/26/vue%20%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://meijuna.github.io/2019/06/26/vue 知识点/</id>
    <published>2019-06-26T14:19:01.000Z</published>
    <updated>2019-07-05T01:15:18.365Z</updated>
    
    <content type="html"><![CDATA[<ol><li>vue 的路由就是用webpakc的注释语法</li></ol><ol><li>webpack 一个功能性的模块 都会以一个闭包的形式，保存在 main.js 中</li><li><p>开发环境的打包，</p></li><li><p>v-text 和  插值表达式的区别：  </p><ol><li>v-text 会替换元素中的内容， 插值表达式只会替换自己的占位符，整个元素的内容不会清空</li><li>网速太慢会先显示插值表达式，在显示内容。而v-text 不会显示内容。</li></ol></li><li><p>事件修饰符： </p><ol><li>top ： 阻止事件冒泡</li><li>prevent ：阻止默认时间</li><li>.capture  ：事件捕获模式</li><li>.self:  当前事件只对该元素本手有效</li></ol><p>self 和 . stop 事件修饰符的区别？</p><p>.self 只会阻止本身的时间冒泡，不会阻止整个的实际那冒泡</p></li></ol><p>使用 class </p><ol><li><p>数组的形式 ：</p><p>:class = “[‘.class’,’class2’]”  //没啥优点，了解</p></li><li><p>表达式的形式：</p><p>：class=”[‘.class’, ‘class2’, flag?’active’: ‘ ‘]”</p></li><li><p>数组嵌套的形式：用对象来替代三元表达式，提高可读性</p><p>:class =”[‘.class’, ‘class2’,{ ‘active’: flag }]”</p></li><li><p>直接使用对象的形式：</p><p>:calss = “{red: true, class: true, class2: flag}”</p></li></ol><p>v-show 和 v-if 有什么区别？</p><p>​    v-if 和 v-show 都是改变元素的显示与隐藏，v-if  通过元素的创建和销毁，有较高切换性能消耗。而v-show 是改变元素的 dispaly 的属性进行显示和隐藏的。有较高的初始渲染消耗。</p><p>如果元素可能永远不会被显示出来，推荐使用 v-if</p><p>如果元素需要频繁的切换，推荐使用 v-show</p><p>路由</p><ol><li><p>你的项目怎么匹配错误路由的？<br>​    我在路由表最下面配置一个两个*号的路径，redirect 重定向到错误路由</p></li><li><p>在页面中，可以使用 router-like 做页面的跳转，router-view 做页面的展示</p><p>router-link 身上的属性： </p></li></ol><p>​            to : 表示路由跳转的路径</p><p>​            tag: 转换为 标签</p><p>​            keep-alive:做缓存</p><p>​               active-class ：激活路由</p><ol start="3"><li>二级路由怎么配？</li></ol><p>​    在路由配置项中，用一个chlidren 数组来配置，</p><ol start="4"><li>什么是命名路由？</li></ol><p>​    在路由配置中 设置 name 属性，这个名字叫命名路由，有了命名路由之后，跳转的 :to 属性就可以用对象的形式了： :to { name: ‘login ‘}</p><h4 id="路由的导航守卫"><a href="#路由的导航守卫" class="headerlink" title="路由的导航守卫"></a>路由的导航守卫</h4><ol><li>导航守卫的作用：</li></ol><p>​    导航守卫是用来监听项目中路由的变化情况的</p><ol start="2"><li><p>你的项目中路由是怎么监听怎么处理的？ （指的是导航守卫）</p></li><li><p>导航守卫有三种使用形式：</p></li><li><p>全局导航守卫</p><p>三个钩子函数：</p><p>beforeEarch()</p><p>afterEarch()</p><p>befored()</p></li><li><p>路由独享守卫</p></li></ol><p>​    beforeEnter( to, from, next )</p><p>​    指的是写在当前组件的路由配置项里面，它只能监听到与这个组件相关的路由变换情况</p><ol start="3"><li><p>组件内的守卫</p><p>组件内守卫有三种形式：</p><ol><li><p>前置前置守卫   beforeRouterEnter( (to, from ,next ) =&gt; {})</p><ul><li><p>导航进入组件时调用</p></li><li><p>因为组件此时没有创建，所以 this 是访问不到的，需要通过 next(vm=&gt;) 访问</p></li><li><p>案例： 数据预载 （ 进入组件前就获取数据）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">net(vm =&gt; &#123;  //vm指的是组件</span><br><span class="line">const result = JSON.parse(res.data.slice(7, -1).rp_result.categorys)</span><br><span class="line">vm.$set(vm.category, &apos;categorys&apos;, result) </span><br><span class="line">&#125;)</span><br><span class="line">工作在哪？ 工作多长时间，做了哪些项目用到的技术，</span><br></pre></td></tr></table></figure></li></ul></li><li><p>后置守卫 </p><ul><li><p>当离开组件时调用</p></li><li><p>this 是可以访问的</p></li></ul></li><li><p>更新守卫</p></li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大家下午好，我叫梅伟军，今天给大家分享下关于原型和原型链的方面的知识，虽然自己理解的也不是全面，但是我会把知道尽可能的分享给大家，也算是回顾一下以前学的知识，希望同学们能有所搜获。</span><br></pre></td></tr></table></figure><pre><code>各位面试官下午好，我先自己我介绍一下，我叫梅伟军，来自浙江丽水，毕业于浙江机电职业技术学院计算机专业，是今年的应届毕业生，我想从以下两个方面介绍自己，在校期间，自学了很多前端方面的课程，写的最多的就是静态页面，也写过H5和响应式的页面,和老师一起开发了两个综合的项目。也会定期的对所学的知识进行总结，发表技术博客。毕业后，在电鲸网络做前端开发，工作期间主要负责移动端的页面和脚本的交互，还有配合后端，接收后端接口，实现数据交互。另我在这段实习的也让我成长了很多，学习了很多的知识，接触并使用了 vue，regeat等框架，并能熟练的使用框架开发项目。对以前掌握的技能有了更深入的认识。工作之余我也会通过视频，书籍等渠道充实前端知识。最后，虽然我没有很长的工作经验，当我认为我还是有很大的潜力的，希望能加入贵公司贡献自己的一份力量，与公司一起进步。以上是我的自我介绍，谢谢。</code></pre><p>   路由的穿插</p><p>   动态路由？</p><p>   ​    url中路由是改变的，当是改变路由公用一个组件。</p><p>配合后端工程师增加页面的JS交互效果以及CSS排版</p><p>   各位面试官下午好，我</p><p>   ​    </p><p>​     </p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;vue 的路由就是用webpakc的注释语法&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;webpack 一个功能性的模块 都会以一个闭包的形式，保存在 main.js 中&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开发环境的打包，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;v-text 和
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue 的生命周期</title>
    <link href="http://meijuna.github.io/2019/06/26/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://meijuna.github.io/2019/06/26/vue生命周期/</id>
    <published>2019-06-26T11:10:13.000Z</published>
    <updated>2019-06-27T11:06:53.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-的生命周期"><a href="#Vue-的生命周期" class="headerlink" title="Vue 的生命周期"></a>Vue 的生命周期</h1><h2 id="1-什么是生命周期？"><a href="#1-什么是生命周期？" class="headerlink" title="1.  什么是生命周期？"></a>1.  什么是生命周期？</h2><p>​    vue的生命周期是组件从创建到销毁的一个过程，这个过程中，我们在每个特定的阶段会触发一些方法，这些方法有协议功能。我们把这些方法叫生命周期钩子函数 or 组件钩子</p><h2 id="2-为什么学习生命周期？"><a href="#2-为什么学习生命周期？" class="headerlink" title="2.  为什么学习生命周期？"></a>2.  为什么学习生命周期？</h2><p>​    因为我们要想在生命周期钩子中实现项目功能，那么必须知道每一个生命周期钩子的具体功能。</p><h2 id="3-这个声明周期是谁的声明周期？"><a href="#3-这个声明周期是谁的声明周期？" class="headerlink" title="3.  这个声明周期是谁的声明周期？"></a>3.  这个声明周期是谁的声明周期？</h2><p>​    生命周期指的是组件的生命周期</p><h2 id="4-vue-生命周期-分为-三个-阶段"><a href="#4-vue-生命周期-分为-三个-阶段" class="headerlink" title="4. vue 生命周期 分为 三个 阶段"></a>4. vue 生命周期 分为 三个 阶段</h2><p>​    Vue 生命周期分为 <strong>初始化</strong>， <strong>运行中</strong>  <strong>销毁</strong>   <strong>三个阶段   8个钩子函数</strong></p><p>​       声明周期钩子函数不能使用箭头函数来定义，因为所有的生命周期钩子自动绑定 <code>this</code> 上下文到实例中，而箭头函数可能影响 this 的指向。</p><p><img src="/2019/06/26/vue生命周期/vue-生命周期/lifecycle.png" alt=""></p><h3 id="1-始化化阶段："><a href="#1-始化化阶段：" class="headerlink" title="1.始化化阶段："></a>1.始化化阶段：</h3><h4 id="1-beforeCreate"><a href="#1-beforeCreate" class="headerlink" title="1. beforeCreate"></a>1. beforeCreate</h4><p>​    组件创建前，目的是为了组件的生命周期 和 组件中的事件 做准备。</p><p>​     数据没有获得，真实 dom 也没有渲染出来的</p><p>​    可以做数据请求，提供一次数据修改的机会</p><h4 id="2-created"><a href="#2-created" class="headerlink" title="2. created"></a>2. created</h4><p>​    组件创建结束</p><p>​    数据得到了，真实 dom 没有渲染出来</p><p>​    可以做数据请求，提供一次数据修改的机会</p><h4 id="3-beforeMount"><a href="#3-beforeMount" class="headerlink" title="3.  beforeMount"></a>3.  beforeMount</h4><p>​    组件挂载前， （挂载：把VDOM渲染到页面）</p><p>​    任务： 判断 el 判断 template</p><p>​         如果 el 没有，我们需要手动挂载，如果有判断 template, 如果存在，进行 render 函数（jsx =》 虚拟DOM）,</p><p>如果没有 template， 通过 outHTML 手动书写模板。</p><h4 id="4-mounted"><a href="#4-mounted" class="headerlink" title="4. mounted"></a>4. mounted</h4><p>​    1. 组件挂载结束</p><p>​    2. 数据有了，VDOM 渲染出了真实DOM </p><p>​    3.可以数据请求，修改数据 </p><p>​     有了真实DOM，一般用于静态的第三方库的实例化</p><p>初始化阶段总结：</p><ol><li>数据请求一般写在 created 里面, 因为这时候刚好能得到数据</li><li>第三方实例化 一般写在 mounted 中，因为 mounted 能够获得真实 DOM</li></ol><h3 id="2-运行中阶段"><a href="#2-运行中阶段" class="headerlink" title="2.  运行中阶段"></a>2.  运行中阶段</h3><p>​    触发条件：数据发生改变才触发，可以触发多次 </p><h4 id="1-beforeUpdata"><a href="#1-beforeUpdata" class="headerlink" title="1. beforeUpdata"></a>1. beforeUpdata</h4><ol><li><p>更新前</p><p>任务：重新渲染 VDOM, 然后通过 dif 算法比较两次VDOM, 生成 path 补丁对象</p></li></ol><h4 id="2-update"><a href="#2-update" class="headerlink" title="2. update"></a>2. update</h4><ol><li>更新结束</li><li>更新后的数据和真实的DOM得到了</li><li>一般进行动态数据获取 （可以进行第三方库实例化）</li></ol><h3 id="3-销毁阶段"><a href="#3-销毁阶段" class="headerlink" title="3. 销毁阶段"></a>3. 销毁阶段</h3><p>​    触发条件： 当组件销毁时触发</p><h4 id="1-beforeDestroy"><a href="#1-beforeDestroy" class="headerlink" title="1. beforeDestroy"></a>1. beforeDestroy</h4><h4 id="2-destroyed"><a href="#2-destroyed" class="headerlink" title="2. destroyed"></a>2. destroyed</h4><p>两个钩子功能是一致，没什么区别，作用是做善后的，比如组件销毁后，清除组件的定时器，删除第三方实例</p><h4 id="3-vue-的销毁有两种形式"><a href="#3-vue-的销毁有两种形式" class="headerlink" title="3. vue 的销毁有两种形式"></a>3. vue 的销毁有两种形式</h4><pre><code>1. 外部销毁——通过开关的方式    外部销毁不仅能销毁组件，也能销毁该组件的 DOM 结构   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;button @click=&quot;flag = !flag&quot;&gt;点击&lt;/button&gt;  //改变数据，创建和销毁组件</span><br><span class="line">    &lt;Hello v-if=&quot;flag&quot;&gt;&lt;/Hello&gt;  //使用  v-if 根据数据创建销毁</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> &lt;template id=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;hello&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"> &lt;/template&gt;</span><br></pre></td></tr></table></figure>2. 内部销毁——通过调用 $destroy 方法     内部销毁只能销毁组件， 当不能销毁组件的DOM结构。   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;tempate id=<span class="string">"hello"</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;button @click=<span class="string">"clear"</span>&gt;销毁&lt;<span class="regexp">/button&gt;   /</span><span class="regexp">/调用方法销毁组件</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/tempate&gt;</span></span><br><span class="line"><span class="regexp">Vue.component('Hello',&#123;</span></span><br><span class="line"><span class="regexp">   template: '#hello',</span></span><br><span class="line"><span class="regexp">   methods:&#123;</span></span><br><span class="line"><span class="regexp">    clear() &#123;             </span></span><br><span class="line"><span class="regexp">      this.$destroy();  /</span><span class="regexp">/通过 $destroy() 方法销毁组件</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;，</span></span><br><span class="line"><span class="regexp">    mouted() &#123;</span></span><br><span class="line"><span class="regexp">         this.time = setInterval( () =&gt; &#123;   /</span><span class="regexp">/给组件添加定时器</span></span><br><span class="line"><span class="regexp">           console.log('18094')</span></span><br><span class="line"><span class="regexp">         &#125;)</span></span><br><span class="line"><span class="regexp">       &#125;,</span></span><br><span class="line"><span class="regexp">       beforeDestroy() &#123;               /</span><span class="regexp">/组件销毁后， beforeDestroy() destroyed() 都会执行</span></span><br><span class="line"><span class="regexp">         console.log('beforeDestroy');</span></span><br><span class="line"><span class="regexp">         clearInterval( this.time )     /</span><span class="regexp">/组件销毁后，清除组件的计时器</span></span><br><span class="line"><span class="regexp">         document.querySelector('#app').remove();  /</span><span class="regexp">/手动删除</span></span><br><span class="line"><span class="regexp">       &#125;,</span></span><br><span class="line"><span class="regexp">       destroyed () &#123;</span></span><br><span class="line"><span class="regexp">         console.log('destroyed');</span></span><br><span class="line"><span class="regexp">       &#125;</span></span><br></pre></td></tr></table></figure>   静态数据第三方库实例化，写在 mouted  中   动态数据第三方库实例化，写在 update   中   优化问题：   ​    将动态数据的第三库实例化放在 update 中是由弊端的，弊端是数据改变时，update 函数会多次触发，第三方库会重复实例化，造成性能浪费。   解决：    1.  判断实例是否存在，存在则不实例化  if( this.mySwiper) return false       - 弊端： 多个实例化判断可能会相互影响       2.   将实例化放在异步队列中            1.   将实例化使用 setTimeout 加入异步队列， 放在 created 钩子的数据请求中。            2.   nextTick: 表示组件渲染结束后，nextTick（）才会执行。             使用 Vue.nextTick(回调)  this.$nextTick()   总结：   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">静态数据第三方库实例化，写在 mouted  中</span><br><span class="line"></span><br><span class="line">动态数据第三方库实例化，用异步的方式，写在 created 函数中</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue-的生命周期&quot;&gt;&lt;a href=&quot;#Vue-的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Vue 的生命周期&quot;&gt;&lt;/a&gt;Vue 的生命周期&lt;/h1&gt;&lt;h2 id=&quot;1-什么是生命周期？&quot;&gt;&lt;a href=&quot;#1-什么是生命周期？&quot; cla
      
    
    </summary>
    
      <category term="Vue" scheme="http://meijuna.github.io/categories/Vue/"/>
    
    
      <category term="知识点，Vue" scheme="http://meijuna.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8CVue/"/>
    
  </entry>
  
  <entry>
    <title>localStroage和 sessionStorage以及 cookie的区别</title>
    <link href="http://meijuna.github.io/2019/06/23/localStroage%E5%92%8C%20sessionStorage%E4%BB%A5%E5%8F%8A%20cookie%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://meijuna.github.io/2019/06/23/localStroage和 sessionStorage以及 cookie的区别/</id>
    <published>2019-06-23T04:29:51.000Z</published>
    <updated>2019-07-03T00:35:49.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-localStroage-和-sessionStorage-以及-cookie-的区别。"><a href="#1-localStroage-和-sessionStorage-以及-cookie-的区别。" class="headerlink" title="1. localStroage 和 sessionStorage 以及 cookie 的区别。"></a>1. localStroage 和 sessionStorage 以及 cookie 的区别。</h2><p>   首先总的来说，三者都是用于持久化数据存储的手段，都是存储在浏览器端，且同源（协议，端口号，都域名相同）</p><p>​     localStorage 和s essionStorage 都是Web存储，大小5M左右，完全存储在客户端，它们是因为本地存储数据而存在的</p><p>​     cookies也是存储在浏览器端的，大小不超过4k，作为http规范的一部分，它是通过浏览器的请求将数据传给服务器的。</p><p>   localStorage属于永久性存储，而 sessionStorage 属于当会话结束的时候，存储的值会被清空，而cookie是通过设置过期时间来存储的。</p><h2 id="2-什么是localStorage-本地存储"><a href="#2-什么是localStorage-本地存储" class="headerlink" title="2. 什么是localStorage(本地存储)"></a>2. 什么是localStorage(本地存储)</h2><p>在HTML5中，新加入了一个 localStorage 特性，这个特性主要是用来作为本地存储来使用的，localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中  localStorage 会有所不同。</p><h3 id="2-1-localStorage的特点"><a href="#2-1-localStorage的特点" class="headerlink" title="2.1 localStorage的特点"></a>2.1 localStorage的<strong>特点</strong></h3><ul><li><p>localStorage拓展了cookie的 4K 限制。</p></li><li><p>localStorage会将第一次请求的数据直接存储到本地，这个相当于一个5M大       小的针对于前端页面的数据库，但只有在高版本的浏览器中才支持的。</p></li><li><p>目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换。</p></li><li><p>localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡。</p></li></ul><ol start="2"><li><h3 id="2-localStroage读写及删除操作。"><a href="#2-localStroage读写及删除操作。" class="headerlink" title="2 localStroage读写及删除操作。"></a>2 localStroage读写及删除操作。</h3></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//localStorage的写入有三种方法</span></span><br><span class="line"><span class="built_in">window</span>.localStorage.key=value</span><br><span class="line"><span class="built_in">window</span>.localStorage[key]=value</span><br><span class="line"><span class="built_in">window</span>.localStorage.setItem(key,value) <span class="comment">//推荐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 localStorage</span></span><br><span class="line">   <span class="built_in">window</span>.localStorage.key</span><br><span class="line">   <span class="built_in">window</span>.localStorage[key]</span><br><span class="line">   <span class="built_in">window</span>.localStorage.getItem(key) <span class="comment">//推荐</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// localStorage的删除</span></span><br><span class="line"><span class="comment">//将localStorage中的某个键值对删除</span></span><br><span class="line"><span class="built_in">window</span>.localStorage.removeItem(<span class="string">"a"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将localStorage的所有内容清除</span></span><br><span class="line"><span class="built_in">window</span>.localStorage.clear();</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-localStroage-和-sessionStorage-以及-cookie-的区别。&quot;&gt;&lt;a href=&quot;#1-localStroage-和-sessionStorage-以及-cookie-的区别。&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="存储" scheme="http://meijuna.github.io/tags/%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>知识点</title>
    <link href="http://meijuna.github.io/2019/06/21/vue%20%E7%BB%84%E4%BB%B6%E5%92%8C%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <id>http://meijuna.github.io/2019/06/21/vue 组件和组件通信/</id>
    <published>2019-06-21T13:40:26.000Z</published>
    <updated>2019-06-27T00:22:14.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vu-两大特性："><a href="#vu-两大特性：" class="headerlink" title="vu 两大特性："></a>vu 两大特性：</h2><p>1 . 指令 – 用来操作 dom</p><p>2 . 组件 – 组件是 html css js的聚合体</p><p>为什么要使用组件？</p><ol><li>组件可以在项目中进行复用</li><li>加快项目进度</li><li>将一个具备完整功能的项目的一部分进行多处使用</li></ol><p>要想使用组件化，那么这个组件是完整的</p><p>组件中的根元素必须是唯一</p><p>组件要先注册，再实例化，要在实例范围内执行</p><p>vue 借鉴 react ,组件以标签的形式呈现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//组件使用前必须先注册</span><br><span class="line">Vue.component(组件名称，组件配置)</span><br><span class="line">var Hello = Vue.extend(&#123;&#125;)</span><br><span class="line">Vue.compoent(&apos;Father&apos;, Hello)</span><br><span class="line"></span><br><span class="line">可以简化</span><br><span class="line">Vue.componet(&apos;Father&apos;, &#123;</span><br><span class="line">template</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>组件的创建</p><ol><li><p>全局注册</p><p>所有实例都可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.componet(&apos;Father&apos;, &#123;</span><br><span class="line">template</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>局部注册</p><p>在实例中间使用 components:{ }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">el: &apos;#app&apos;,</span><br><span class="line">components: &#123;</span><br><span class="line">&apos;Father&apos;: &#123;</span><br><span class="line">   template: &apos;&lt;div&gt;局部组粗&lt;/div&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>组件的嵌套</p><p>   在父组件里放子组件： 将子组件以标签的形式放在父组件中</p><p>全局嵌套</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">&lt;Father&gt;&lt;/Father&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;template id=&quot;father&quot;&gt;</span><br><span class="line">&lt;h3&gt;这里是父组件模板&lt;/h3&gt;</span><br><span class="line">&lt;/Son&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">Vue.component(&apos;Father&apos;,&#123;</span><br><span class="line">template: &apos;#father&apos;</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(&apos;Son&apos;, &#123;</span><br><span class="line">template:&apos;&lt;div&gt; son &lt;/div&gt;&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>局部嵌套</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">new Vue([</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    compoents: &#123;</span><br><span class="line">template: &apos;&lt;div&gt; father 组件 &lt;/Son&gt; &lt;/div&gt;&apos;,</span><br><span class="line">components: &#123;</span><br><span class="line">&apos;Son&apos;: &#123;</span><br><span class="line">template: &apos;&lt;div&gt; son 组件 &lt;/div&gt;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>is  规则</p><p>ul&gt;li ol&gt;li table&gt;tr&gt;td select&gt;option</p><p>如上直属父子级如果直接组件以标签化形式使用，会出现 bug</p><p>解决：需要通过   is 属性来绑定一个组件</p><p>组件的一些特殊使用规则  【</p><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h2 id="1-为什么要进行组件通信？"><a href="#1-为什么要进行组件通信？" class="headerlink" title="1. 为什么要进行组件通信？"></a>1. 为什么要进行组件通信？</h2><ul><li>每个组件都是一个<strong>独立功能</strong>的整体，当我们要将这些组件拼接在一起时，就需要在这些组件之间建立通信</li></ul><h2 id="2-组件的通信有哪些？"><a href="#2-组件的通信有哪些？" class="headerlink" title="2 组件的通信有哪些？"></a>2 组件的通信有哪些？</h2><h3 id="1-父子组件通信"><a href="#1-父子组件通信" class="headerlink" title="1. 父子组件通信"></a>1. 父子组件通信</h3><p>​    使用 props 来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.在父组件的模板中将数据用单项数据绑定的形式(v-bind)绑定到子组件上</span></span><br><span class="line"> &lt;Son :aa = <span class="string">"money"</span>  :maskFlag = <span class="string">"maskFlag"</span>/&gt;</span><br><span class="line"> Vue.component(<span class="string">'Father'</span>,&#123;</span><br><span class="line">    template: <span class="string">'#father'</span>,</span><br><span class="line">    data () &#123; </span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        money: <span class="number">2000</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  Vue.component(<span class="string">'Son'</span>,&#123;</span><br><span class="line">    template: <span class="string">'#son'</span>,</span><br><span class="line">    props: [<span class="string">'aa'</span>,<span class="string">'maskFlag'</span>]          </span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h3 id="2-子父组件通信"><a href="#2-子父组件通信" class="headerlink" title="2.  子父组件通信"></a>2.  子父组件通信</h3><p>​    使用做自定义事件通信</p><ol><li><p>在父组件模板中，通过事件绑定的形式，绑定一个自定义事件在子组件身上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Son @a = &apos;fn&apos;&gt;  //注意： fn 是在父组件配置项 methods 中定义</span><br></pre></td></tr></table></figure></li><li><p>在子组件的配置项 methods 中写一个事件处理程序，在事件处理程序中 使用 $emit() 触发父组件中绑定的自定义事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;Son&apos;,&#123;</span><br><span class="line">   template: &apos;#son&apos;,</span><br><span class="line">   props: [&apos;aa&apos;,&apos;maskFlag&apos;]          </span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></li><li><p>将子组件定义事件处理函数 ，绑定到子组件的按钮上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ol><h3 id="3-非父子组件通信"><a href="#3-非父子组件通信" class="headerlink" title="3.  非父子组件通信"></a>3.  非父子组件通信</h3><h4 id="1-ref-链"><a href="#1-ref-链" class="headerlink" title="1.ref  链"></a>1.ref  链</h4><p>父组件通过 ref 链得到一个子组件的数据，在把数据发送到另一个子组件上，就可以实现非父子组件的通信，当是如果层级太多，就比较繁琐</p><h4 id="2-bus-事件总线"><a href="#2-bus-事件总线" class="headerlink" title="2.bus 事件总线"></a>2.bus 事件总线</h4><p>通过 bus.$on 来定义事件，通过$emit 来触发事件</p><ol><li><p>在其中一个组件的 mounted 钩子函数上进行事件声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'sma'</span>, &#123;</span><br><span class="line">   template: <span class="string">'#sma'</span>,</span><br><span class="line">   data() &#123;</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">       flag: <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   mounted () &#123; <span class="comment">//在 mounted 钩子函中事件声明  </span></span><br><span class="line">     <span class="keyword">let</span> _this = <span class="keyword">this</span></span><br><span class="line">     bus.$on(<span class="string">'aa'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   <span class="comment">// 事件声明 </span></span><br><span class="line">       _this.flag = <span class="literal">true</span>;</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></li><li><p>在另一个组件中，通过 bus.$emit(‘aa’) 来触发这个事件</p></li></ol><h3 id="4-多组件状态共享-（-多组件共有同一个数据）"><a href="#4-多组件状态共享-（-多组件共有同一个数据）" class="headerlink" title="4.  多组件状态共享 （ 多组件共有同一个数据）"></a>4.  多组件状态共享 （ 多组件共有同一个数据）</h3><p>vuex</p><h3 id="5-非常规通信方式"><a href="#5-非常规通信方式" class="headerlink" title="5.  非常规通信方式"></a>5.  非常规通信方式</h3><p>不推荐：因为 mvvm 框架是单项数据流</p><h4 id="1-父子通信"><a href="#1-父子通信" class="headerlink" title="1. 父子通信"></a>1. 父子通信</h4><p>父组件窗体一个 对象类型 给子组件，子组件通过 props 接收，</p><p>会发现：子组件修改数据时，父组件的数据也会发生改变</p><p>因为父组件传递给子组件的是一个对象引用地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;Father&gt;&lt;/Father&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;template id=&quot;father&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;这是fatcher 组件&lt;/h3&gt;</span><br><span class="line">      &lt;p&gt;父组件小金库 ---&#123;&#123; xiaojingku.money &#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;Son :xiaojingku=&quot;xiaojingku&quot;&gt;&lt;/Son&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template id=&quot;son&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;这是 son组件&lt;/h3&gt;</span><br><span class="line">      &lt;button &gt;give&lt;/button&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;xiaojingku.money&quot;&gt;</span><br><span class="line">      &lt;p&gt;son : &#123;&#123; xiaojingku.money&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br></pre></td></tr></table></figure><h4 id="2-子父通信"><a href="#2-子父通信" class="headerlink" title="2. 子父通信"></a>2. 子父通信</h4><p>父组件将一个方通过属性绑定的形式给了子组件，子组件用 props 接收方法，在子组件中调用方法并传参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;Father&gt;&lt;/Father&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;template id=&quot;father&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;这是fatcher 组件&lt;/h3&gt;</span><br><span class="line">      &lt;Son :add=&quot;add&quot;&gt;&lt;/Son&gt;  //1.将方法绑定到子组件上</span><br><span class="line">      &#123;&#123; n &#125;&#125;  //2000</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template id=&quot;son&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;这是 son组件&lt;/h3&gt;</span><br><span class="line">      &lt;button @click=&quot;add(money)&quot;&gt;give&lt;/button&gt;  //3. 子组件调用传来的方法，并传值</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">  Vue.component(&apos;Father&apos;, &#123;</span><br><span class="line">    template: &apos;#father&apos;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        n: 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      add (val) &#123;</span><br><span class="line">        this.n = val;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  Vue.component(&apos;Son&apos;, &#123;</span><br><span class="line">    template: &apos;#son&apos;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        money: 1000</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    props: [&apos;add&apos;]   //2. 子组件接收方法</span><br><span class="line">  &#125;)</span><br><span class="line">  new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h2 id="3-动态组件"><a href="#3-动态组件" class="headerlink" title="3. 动态组件"></a>3. 动态组件</h2><ol><li>什么是动态组件？</li></ol><p>​    可以修改的组件</p><ol start="2"><li>使用</li></ol><p>​    vue 提供过了 一个 compoent 标签（组件）  + is  属性 来实现  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>  @<span class="attr">click</span>=<span class="string">"change"</span> &gt;</span>切换<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span>       <span class="tag">&lt;<span class="name">kee-alive</span>&gt;</span> 组件 可以对组件进行浏览器缓存，在切换组件时就可以提高效率。</span><br><span class="line">        <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span> = <span class="string">"type"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(<span class="string">'A'</span>,&#123;</span><br><span class="line">      template: <span class="string">'&lt;div&gt;A组件啊&lt;/div&gt;'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    Vue.component(<span class="string">'B'</span>,&#123;</span><br><span class="line">      template: <span class="string">'&lt;div&gt;B组件啊啊&lt;/div&gt;'</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      el: <span class="string">'#app'</span>,</span><br><span class="line">      data: &#123;</span><br><span class="line">        type: <span class="string">'A'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        change()&#123;</span><br><span class="line">          <span class="keyword">this</span>.type = <span class="keyword">this</span>.type === <span class="string">'A'</span> ? <span class="string">'B'</span>:<span class="string">'A'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>语法糖： 对代码的另一种语法实现，功能保持不变，提高代码的可读性，减少出错</p><p>组件中data定义是一个函数？</p><pre><code>因为组件是一个独立的个体，应该拥有的自己独立的作用域数据。</code></pre><p>为什么data 为什么要有 return，return 的还是一个对象？</p><pre><code>1. 因为Vue 是通过observer 来观察 data选项的，所以必须要有 返回值。2. 应为Vue 要通过 es5 的Object.defineProperty 属性对对象 进行getter 和 setter 设置，这个属性传的第一个参数是一个对象。</code></pre><p>自定义事件的发布</p><ol><li><p>通过$on 发布， $emit 触发</p><p>vm.$on(自定义事件名称，自定义事件处理函数)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.$on(&apos;a&apos;, function() &#123;</span><br><span class="line">console.log( &apos;aaa&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">vm.$emit(自定义事件的名称，自定义事件需要的参数)；</span><br></pre></td></tr></table></figure></li><li><p>把事件在组件上定义，通过 $emit() 触发</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>app实例的手动挂载 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">&#125;).$mount(&apos;#app&apos;);</span><br></pre></td></tr></table></figure><h3 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h3><ol><li><p>props: [ ‘msg’ ] 只是单纯的接收了一个父组件传来的数据，没有验证</p></li><li><p>props: { attr: attType } 进行数据类型验证</p></li><li><p>props: { type: typeType, defalut: value } 为数据设置初始值</p></li><li><p>props: { varlidator ( val ) { return boolean }}   对数据进行条件比较，return booblean</p></li><li><p>第三方包： vue-validata vee-validate…</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'Son'</span>, &#123;</span><br><span class="line">   template: <span class="string">'#son'</span>,</span><br><span class="line">   props:&#123;</span><br><span class="line">     <span class="comment">// key: value</span></span><br><span class="line">     <span class="string">'money'</span>: <span class="built_in">Number</span>,</span><br><span class="line">     <span class="string">'n'</span>: &#123;</span><br><span class="line">       validator ( val ) &#123; <span class="comment">//属性验证函数，一般用于条件比较</span></span><br><span class="line">         <span class="keyword">return</span> val &gt; <span class="number">200</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="string">'num'</span>: &#123;</span><br><span class="line">       type: <span class="built_in">Number</span>,</span><br><span class="line">       <span class="keyword">default</span>: <span class="number">200</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></li></ol><p>过滤器</p><ol><li><p>什么是过滤器？</p><ul><li><p>用来格式化数据的一个函数 </p><p>vue 1.x 借鉴啦 angular， 提供了 10 个过滤器（ 日期，小数点位数保留，货币，大小写)</p><p>vue 2.x 废弃了 这10个过滤器，提供自定义过滤器的方式</p></li></ul></li><li><p>使用方式</p><p>过滤器要想获得我们的数据，要通过一个叫 ‘管道符 |  ’ 来获取数据</p><p>过滤器是对已有的数据进行格式化，必须先得到数据在可视化</p><pre><code>1. 全局定义过滤器   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Vue.filter(过滤器名称, 回调函数)；</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; time | timeFilter(&quot;/&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   Vue.filter(&apos;timeFilter&apos;, (val, type) =&gt; &#123;</span><br><span class="line">     let data = new Date();</span><br><span class="line">     return data.getFullYear() + type + ( data.getMonth() + 1 ) + type + data.getDate();</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li><p>局部定义过滤器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;p&gt; &#123;&#123;time | timeFilter(&apos;-&apos;)&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      time: Date.now()</span><br><span class="line">    &#125;,</span><br><span class="line">    filters: &#123;</span><br><span class="line">      &apos;timeFilter&apos;: function (val, type) &#123;</span><br><span class="line">        let date = new Date();</span><br><span class="line">        return date.getFullYear() + type + date.getMonth() + 1 + type + date.getDate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li></ol><p>solot 插槽</p></li><li><p>作用/概念： 预先将将来要是用的内容进行保留</p></li><li>具名插槽：</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vu-两大特性：&quot;&gt;&lt;a href=&quot;#vu-两大特性：&quot; class=&quot;headerlink&quot; title=&quot;vu 两大特性：&quot;&gt;&lt;/a&gt;vu 两大特性：&lt;/h2&gt;&lt;p&gt;1 . 指令 – 用来操作 dom&lt;/p&gt;
&lt;p&gt;2 . 组件 – 组件是 html css
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>执行环境及作用域链</title>
    <link href="http://meijuna.github.io/2019/06/20/%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://meijuna.github.io/2019/06/20/执行环境和作用域/</id>
    <published>2019-06-20T12:59:48.000Z</published>
    <updated>2019-06-26T13:58:15.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="执行环境及作用域链"><a href="#执行环境及作用域链" class="headerlink" title="执行环境及作用域链"></a>执行环境及作用域链</h1><p>​    执行环境定义了变量或函数有权访问的其他数据，确定了它们各自的行为。每个执行执行环境都有一个与之关联的<strong>变量对象</strong>，这个变量变量对象保存着环境中定义的所有<strong>变量</strong>和<strong>函数。</strong></p><p>​    全局执行环境就是最外围的一个执行环境。根据 ECMAScript 实现，所在的环境不同，表示的执行环境的对象页不一样。在浏览器中，全局执行环境被认为 window 对象。因此，在全局声明的属性和方法都是 window 对象的属性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">console.log( window.a ) //1</span><br><span class="line">window.b = 2;</span><br><span class="line">console.log( b ) //2</span><br></pre></td></tr></table></figure><p>​    在某个执行环境中的所有代码执行后，改环境被销毁，保存其中的所有变量和函数定义也随之销毁（ 全局执行直到应用退出——退出浏览器是才会被销毁）。</p><p>​    当代码在一个环境中执行时，会创建<strong>变量对象</strong>的一个<strong>作用域链</strong>。</p><p>​        作用域链的作用： 保证对有权访问的所有变量和函数进行有序的访问。</p><p>​         在作用域的前端，始终是当前执行的代码所在的 变量对象。如果这个环境是函数，活动对象就是变量对象。活动对象最开始只包含一个变量，即 （ arguments ) 对象（这个对象在全局环境是不存在的）。作用域链中的下一个变量对象来自包含环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局环境；全局执行环境的变量对象始终是最后一个对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var color = &quot;blue&quot;;</span><br><span class="line">function changeColor() &#123;</span><br><span class="line">if( color === &quot;blue&quot;) &#123;</span><br><span class="line">color = &quot;red&quot;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">color = &quot;blue&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">changeColor();</span><br><span class="line">alert()</span><br></pre></td></tr></table></figure><p>在上面的例子中， 函数 changeColor() 的作用域链包含两个对象：它自己的变量对象（其中定义这 arguments 对象 ）和全局环境的变量对象。所以可以在函数内部访问变量 color。</p><pre><code>2. 查找标识符</code></pre><p>查找标识符的过程从作用于链的前端开始，向上逐级查找给定名字匹配的标识符。如果在局部环境中找到了该标识符，则查找停止，变量就绪。如果在局部环境没有找到该标识符，则沿作用域上查找。查找过程将一直追溯到全局的变量的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量为声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var color = &quot;blue&quot;;</span><br><span class="line">function getColor() &#123;</span><br><span class="line">return color;</span><br><span class="line">&#125;</span><br><span class="line">alert(getColo()); // blue</span><br></pre></td></tr></table></figure><p>上面例子中调用了 getColor() 函数会引用变量 color 。为了确定 color 的值。就会沿着作用链向上搜索。</p><p>​    首先，搜索 getColor() 的变量对象，查找其中是否有个名叫color 的标识符。在没有找到的情况下，继续搜索下一个变量对象（全局环境的变量对象），在全局变量对象中搜索到了color，搜索结束。</p><p>​    在搜索过程中，如果存在一个局部变量的定义，则搜索会自动停止，不在进入另一个变量对象。换句话说，如果局部环境中存在着同名的标识符，就不会使用位于父环境中的标识符。例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var color = &quot;blue&quot;;</span><br><span class="line">function getColor() &#123;</span><br><span class="line">var color = red;</span><br><span class="line">return color;</span><br><span class="line">&#125;</span><br><span class="line">alert(getColo()); // red</span><br></pre></td></tr></table></figure><p>内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和对象。每个环境都可以上搜索作用域链，已查询变量和遍历和函数名。但任何环境都不能通过向下搜索作用域链。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;执行环境及作用域链&quot;&gt;&lt;a href=&quot;#执行环境及作用域链&quot; class=&quot;headerlink&quot; title=&quot;执行环境及作用域链&quot;&gt;&lt;/a&gt;执行环境及作用域链&lt;/h1&gt;&lt;p&gt;​    执行环境定义了变量或函数有权访问的其他数据，确定了它们各自的行为。每个执行
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://meijuna.github.io/categories/JavaScript/"/>
    
    
      <category term="知识点，JavaScript" scheme="http://meijuna.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%8CJavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript6 基础语法</title>
    <link href="http://meijuna.github.io/2019/06/19/ECMAScript6%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://meijuna.github.io/2019/06/19/ECMAScript6 基础语法/</id>
    <published>2019-06-19T11:26:15.000Z</published>
    <updated>2019-06-25T03:29:28.942Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>let 声明的变量只有在代码块内有效，在代码块外面调用会出错</p><p>相同的作用域内 不允许重复声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function()&#123;   //报错</span><br><span class="line">let a = &quot;1&quot; </span><br><span class="line">var a = &quot;2&quot;</span><br><span class="line">&#125;</span><br><span class="line">function func(age) &#123; //报错 不能再函数内部重新声明参数</span><br><span class="line">let arg</span><br><span class="line">&#125;</span><br><span class="line">function func(age) &#123; //不报错 </span><br><span class="line">    &#123;</span><br><span class="line">       let arg    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>let 定义的变量，不会发生变量提升( 在声明前使用，值为 undenfined )</p></li></ol><p>暂时性死区：</p><p>只要在块级作用域 let 和 const 命令，它所声明的变量就会绑定这个区域，不在受外部的影响。</p><p>这个区块对这些命令声明的变量从一开始就形成了封闭作用域。只要在声明之间就是用这些变量，就会报错。</p><p>2.2 块级作用域</p><p>2.2.1 为什么需要块级作用域？</p><p>因为 es5 只用全局作用域和块级作用域，倒是很多场景不合理</p><ol><li><p>内层变量可能覆盖外层变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var temp = new Date();</span><br><span class="line">function fn() &#123;</span><br><span class="line"> console.log(temp);</span><br><span class="line">     if (false) &#123;</span><br><span class="line">        var temp = &apos;hello&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn() //undefined 应为内部变量temp的提升导致覆盖外层 temp 变量</span><br></pre></td></tr></table></figure><ol start="2"><li>用来计数的循环边聊泄露为全局变量</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(s[i]); <span class="comment">//h e l l o</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">//5  i 只是来控制循环就，当是循环结束后，它并没有消失，而是变成了 全局变量</span></span><br></pre></td></tr></table></figure><p>let 为Javascript 新增了块级作用域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">let = 5;</span><br><span class="line">if (true) &#123;</span><br><span class="line">let n = 10;</span><br><span class="line">&#125;</span><br><span class="line">console.log(n); //5 外层代码块不受内层代码块的影响</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>块级作用域的出现，使得应用广泛应用的立即执行匿名不在必要了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（function()&#123;</span><br><span class="line">    var temp = &quot;&quot;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">let temp = &quot;&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const 声明一个常量 ，一旦声明，常量的值就不能改变</p><p>和 let 命令一样，只在声明所在的块级作用域内有效，声明的变量不会提升，同样存在暂死区，只能在声明后使用。</p><p>不可重复声明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const PI = 3.1415</span><br><span class="line">PI = 3.14</span><br></pre></td></tr></table></figure><p>这就意味着 const 声明的常量在声明的时候，就必须初始化，不能留到以后赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const PI;</span><br><span class="line">//SyntaxError</span><br></pre></td></tr></table></figure><p>const 的本质</p><blockquote><p>const 实质上保证的并不是变量的值不改变，而是变量指向的那个内存不会改变。对于基本数据类型，值保存在变量只要的内存地址中，因此等于常量。但是对于引用类型来说，变量指向的内存地址保存的是一个指针。const 只能保证这个指针是固定，它指向的数据结构是不是可变的，这个是不能控制的，因此，将一个对象声明为常量必须非常小心。</p></blockquote></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.prop = <span class="number">123</span>;</span><br><span class="line">obj.prop <span class="comment">//123</span></span><br><span class="line">obj = &#123;&#125;  <span class="comment">// error 给变量 obj 赋值一个新的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = [] ;</span><br><span class="line">a.push(<span class="string">'hello'</span>) <span class="comment">//可执行</span></span><br><span class="line">a.legth = <span class="number">0</span> <span class="comment">//可执行</span></span><br><span class="line">a = [<span class="string">'Dave'</span>] <span class="comment">//error</span></span><br><span class="line">常量 a 是一个数组，这个数组本身是可写的，当是如果将另一个数组赋值给 a， 就会报错</span><br></pre></td></tr></table></figure><p>2.3.3 es6 声明变量的 6 中方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">声明变量方法:</span><br><span class="line">es5 ：var function</span><br><span class="line">es6 : let const import class  </span><br><span class="line">所以共 6 种</span><br></pre></td></tr></table></figure><p>2.4 顶层对象的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">全局对象在浏览器环境： window 对象</span><br><span class="line">全局对象在 node 环境中： global 对象</span><br><span class="line"></span><br><span class="line">全局对象的属性和全局变量相关</span><br><span class="line"></span><br><span class="line">window.a = 1;</span><br><span class="line">console.log( a ) // 1</span><br><span class="line"></span><br><span class="line">a = 2 ;</span><br><span class="line">console.log( window.a ) //2</span><br></pre></td></tr></table></figure><p>全局对象的属性和全局变量相关，被认为是 javascript 语言中最大的败笔之一。</p><p>回带来以下一个很大的问题：</p><ol><li><p>无法在编译时就提示变量声明错误的提示，只有在运行时才知道。</p><ul><li><p>源代码需要被编译成机器可以识别的程序，这个编译过程被称为编译时。</p></li><li><p>用户可以运行编译过的程序，程序运行的过程被称为运行时。</p></li></ul></li><li><p>不知不觉就会创建全局变量</p></li><li><p>全局的属性导出都是可读写的，不利于模块化编程</p></li></ol><p>es 6 为了改变这点，保持了兼容性，var 和 function  命令的全局依旧是顶层对象的属性；let 和 const 命令、class命令声明的全局变量不属于顶层函数的属性，也就是说 ES6开始，全局变量逐步与顶层对象的属性隔离。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let b =1;</span><br><span class="line">window.b //undefined</span><br></pre></td></tr></table></figure><p>第3章 变量的解构赋值</p><p>es 6 允许按照一定模式从数据和对象中提取值，然后对变量进行赋值，这被称为解构赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只要左边的变量就会被赋予对应的值</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c ] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [foo, [ [bar], baz ] ] = [ <span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>] ]</span><br><span class="line"><span class="comment">//   1        2      3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [, , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>]</span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果解构解构不成功，变量的值就等于 undefined </span></span><br><span class="line"><span class="keyword">let</span> [foo] = [];</span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];</span><br><span class="line"><span class="comment">//以上都解构都不成功，foot值都为 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不完全解构 ：左边的模式只匹配了一部分的等号右边的数组</span></span><br><span class="line"><span class="keyword">let</span> [x,y] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">   <span class="comment">//1  2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>]</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure><p>默认值:</p><p>解构赋值允许指定默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [x, y = 1 ]  = [ &apos;a&apos; ] // x = a , y =1</span><br></pre></td></tr></table></figure><p>对象的解构赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let &#123; foo, bar &#125; = &#123; foo: &quot; aaa &quot;, bar: &quot; bbb &quot;&#125;;</span><br><span class="line">//aaa  bbb</span><br><span class="line">对象的解构与数组的解构有一个重要的不同，数组的元素按次序排列的，变量的取值由它的位置确定的，而对象的属性没有次序，变量必须与属性同名才能取到正确的值</span><br><span class="line"></span><br><span class="line">let &#123; baz &#125; = &#123; foo: &quot;aaa&quot; ,bar : &quot; bbb &quot;&#125;</span><br><span class="line"> undefined</span><br><span class="line"> kn</span><br></pre></td></tr></table></figure><p>如果等号右边的值不是对象或数组，就先将其转换为对象。由于undefinedd 和null 无法转换对象，所以进行结构赋值时会出错。</p><p>用途</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let x = 1;</span><br><span class="line">let y = 2;</span><br><span class="line">[x, y ] = [y, x] //交换变量的 x  y值</span><br><span class="line"></span><br><span class="line">从函数返回多个值</span><br><span class="line">由于函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了结构赋值，取出这些值就很方便</span><br><span class="line">function fn () &#123;</span><br><span class="line">return [1, 2,3]</span><br><span class="line">&#125;</span><br><span class="line">let [a, b, c] = fn()</span><br><span class="line"></span><br><span class="line">function obj () &#123;</span><br><span class="line">return &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: 2,</span><br><span class="line">  c: 3</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let [a, b, c] = obj ()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;let 声明的变量只有在代码块内有效，在代码块外面调用会出错&lt;/p&gt;
&lt;p&gt;相同的作用域内 不允许重复声明&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
      <category term="ECMAScript6" scheme="http://meijuna.github.io/categories/ECMAScript6/"/>
    
    
      <category term="ECMAScript6" scheme="http://meijuna.github.io/tags/ECMAScript6/"/>
    
  </entry>
  
  <entry>
    <title>浅谈MVC、MVP、MVVM架构模式的区别和联系</title>
    <link href="http://meijuna.github.io/2019/06/18/%E6%B5%85%E8%B0%88MVC%E3%80%81MVP%E3%80%81MVVM%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/"/>
    <id>http://meijuna.github.io/2019/06/18/浅谈MVC、MVP、MVVM架构模式的区别和联系/</id>
    <published>2019-06-18T13:48:08.823Z</published>
    <updated>2019-06-21T13:08:51.226Z</updated>
    
    <content type="html"><![CDATA[<p>MVC、MVP、MVVM这些模式是为了解决开发过程中的实际问题而提出来的，目前作为主流的几种架构模式而被广泛使用。</p><p>一、MVC（Model-View-Controller）</p><p>MVC  是最常见的软件架构之一，它与衍生的 MVP 和 MVVM 架构</p><p>MVC模式的意思是，软件可以分成三个部分。</p><p><img src="/2019/06/18/浅谈MVC、MVP、MVVM架构模式的区别和联系/mvc.png" alt=""></p><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- 视图（View）：用户界面。</span><br><span class="line">- 控制器（Controller）：业务逻辑处理</span><br><span class="line">- 模型（Model）：数据保存</span><br><span class="line"></span><br><span class="line">1. 视图 View 传送指令到 控制器 Controller</span><br><span class="line">2. 控制器 Controller 完成业务逻辑后，要求 模型 Model 改变状态</span><br><span class="line">2. 模型 Model 将新的数据发送到 视图 Vie                                   、、</span><br><span class="line">、</span><br><span class="line">、w，用户得到反馈</span><br><span class="line"></span><br><span class="line">MVC是比较直观的架构模式，</span><br><span class="line">用户操作-&gt;View（负责接收用户的输入操作）-&gt;Controller（业务逻辑处理）-&gt;Model（数据持久化）-&gt;View（将结果反馈给View）。</span><br><span class="line"></span><br><span class="line">所有通信都是单向的。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">优点</span><br><span class="line"></span><br><span class="line">模型与视图完全分离，我们可以修改视图而不影响模型</span><br><span class="line">可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部</span><br><span class="line">我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁。</span><br><span class="line">如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑（单元测试）</span><br><span class="line">缺点</span><br><span class="line"></span><br><span class="line">由于对视图的渲染放在了Presenter中，所以视图和Presenter的交互会过于频繁。还有一点需要明白，如果Presenter过多地渲染了视图，往往会使得它与特定的视图的联系过于紧密。一旦视图需要变更，那么Presenter也需要变更了。比如说，原本用来呈现Html的Presenter现在也需要用于呈现Pdf了，那么视图很有可能也需要变更</span><br></pre></td></tr></table></figure></li></ul><p>二、MVP （Model-View-Presenter）</p><p>MVP是把MVC中的Controller换成了Presenter（呈现），目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离。</p><p><img src="/2019/06/18/浅谈MVC、MVP、MVVM架构模式的区别和联系/mvp.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 各部分之间的通信，都是双向的。</span><br><span class="line"></span><br><span class="line">2. View 与 Model 不发生联系，都通过 Presenter 传递。</span><br><span class="line"></span><br><span class="line">3. View 非常薄，不部署任何业务逻辑，称为&quot;被动视图&quot;（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.NET程序员熟知的ASP.NET webform、winform基于事件驱动的开发技术就是使用的MVP模式。控件组成的页面充当View，实体数据库操作充当Model，而View和Model之间的控件数据绑定操作则属于Presenter。控件事件的处理可以通过自定义的IView接口实现，而View和IView都将对Presenter负责。</span><br></pre></td></tr></table></figure><p>三、MVVM（Model-View-ViewModel）</p><p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。</p><p>唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。<a href="https://angularjs.org/" target="_blank" rel="noopener">Angular</a> 和 <a href="http://emberjs.com/" target="_blank" rel="noopener">Ember</a> 都采用这种模式。</p><p>如果说MVP是对MVC的进一步改进，那么MVVM则是思想的完全变革。它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。</p><p>这方面典型的应用有.NET的WPF，js框架Knockout、AngularJS等。</p><p><img src="/2019/06/18/浅谈MVC、MVP、MVVM架构模式的区别和联系/mvvm.png" alt=""></p><blockquote><p>原文地址：<a href="https://www.cnblogs.com/guwei4037/p/5591183.html" target="_blank" rel="noopener">https://www.cnblogs.com/guwei4037/p/5591183.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MVC、MVP、MVVM这些模式是为了解决开发过程中的实际问题而提出来的，目前作为主流的几种架构模式而被广泛使用。&lt;/p&gt;
&lt;p&gt;一、MVC（Model-View-Controller）&lt;/p&gt;
&lt;p&gt;MVC  是最常见的软件架构之一，它与衍生的 MVP 和 MVVM 架构
      
    
    </summary>
    
      <category term="express" scheme="http://meijuna.github.io/categories/express/"/>
    
    
      <category term="Node" scheme="http://meijuna.github.io/tags/Node/"/>
    
      <category term="框架" scheme="http://meijuna.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB数据库</title>
    <link href="http://meijuna.github.io/2019/06/18/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://meijuna.github.io/2019/06/18/mongodb数据库/</id>
    <published>2019-06-18T11:24:38.081Z</published>
    <updated>2019-06-26T14:00:32.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">show dbs      查看数据库</span><br><span class="line">use dbname    创建数据库 如果不存在创建数据库，否则切换到数据库</span><br><span class="line">show collections 显示数据库集合</span><br><span class="line"></span><br><span class="line">1.添加数据</span><br><span class="line"></span><br><span class="line">db.web.save(&#123;&quot;name&quot;: &quot;meiejuna&quot;&#125;)  创建了名称为 web 的名称，名</span><br><span class="line">db.web.insert(&#123;&quot;name&quot;: &quot;meijuna&quot;&#125;)  </span><br><span class="line">插入相同的数据，sava 覆盖，insert 报错</span><br><span class="line"></span><br><span class="line">2.删除数据</span><br><span class="line">      </span><br><span class="line">   db.students.remove( &#123;&#125; )      删除 students 集合下的所有数据</span><br><span class="line">   db.students.remove(&#123;&quot;name&quot;: &quot;meijuna&quot; &#125;) 删除 students 集合为 name 为 meijuna 的数据</span><br><span class="line">   db.students.drop() or db.runCommand(&#123;&quot;&quot;&#125;)删除 students 集合</span><br><span class="line">   db.runCommand( &#123; dropDaatabase: 1 &#125; )    删除当前数据库</span><br><span class="line">   </span><br><span class="line">3.修改数据</span><br><span class="line"></span><br><span class="line">db.students.updata(&#123;&quot;name&quot;: &quot;meijuna&quot;&#125;,set:&#123;&quot;sex&quot;:&quot;women&quot;&#125;)                单行修改</span><br><span class="line">db.students.updata(&#123;&quot;name&quot;: &quot;meijuna&quot;&#125;,&#123;$set:&#123;&quot;sex&quot;:&quot;women&quot;&#125;&#125;, true, true) 多行修改</span><br><span class="line">     //&#123;查找条件&#125; , &#123; 修改内容 &#125;      匹配所有条件数据 修改所有匹配项</span><br><span class="line"></span><br><span class="line">4.查找数据</span><br><span class="line">  db.students.find()          查找 students 集合中的 所有    数据</span><br><span class="line">  db.students.findONe()       查找 students 集合中的 第一条  数据</span><br><span class="line">  db.students.find().pretty() 可视化查询 </span><br><span class="line">  </span><br><span class="line">5.排序 </span><br><span class="line">db.students.find().sort(&#123;&quot;age&quot;: 1&#125;) 1 升 -1 降序</span><br><span class="line"></span><br><span class="line">6.截取</span><br><span class="line">db.students.find().skip(2)  下标为 2 开始截取</span><br><span class="line">db.students.find().limit(2)   截取 2 条数据</span><br><span class="line"></span><br><span class="line">7.筛选显示</span><br><span class="line">db.students.find(&#123;age:20&#125;,&#123;_id:0,age:1,name:1&#125;)</span><br><span class="line">        0,筛选的结果不显示，1筛选结果显示</span><br></pre></td></tr></table></figure><h2 id="SQL简介"><a href="#SQL简介" class="headerlink" title="SQL简介"></a>SQL简介</h2><ul><li><p>关系型数据库 以行和列的形式存储数据，以便于用户理解。这一系列的行和列被称为表，一组表组成了数据库。表与表之间的数据记录有关系。</p></li><li><p><strong>关系型</strong>数据库有：<strong>mySql</strong> <strong>oracle</strong>   <strong>SqlServer</strong>  <strong>Access</strong>  <strong>db2 </strong> 等</p></li></ul><h2 id="NoSQL简介"><a href="#NoSQL简介" class="headerlink" title="NoSQL简介"></a>NoSQL简介</h2><ul><li>NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。</li><li>NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</li><li><strong>非关系型</strong>数据库: <strong>MongoDB</strong>，<strong>Redis</strong>，<strong>HBase</strong>，<strong>CouchDB </strong> 等</li></ul><h2 id="非关系型数据库与关系型数据库区别"><a href="#非关系型数据库与关系型数据库区别" class="headerlink" title="非关系型数据库与关系型数据库区别"></a>非关系型数据库与关系型数据库区别</h2><h3 id="关系型数据库的优势："><a href="#关系型数据库的优势：" class="headerlink" title="关系型数据库的优势："></a>关系型数据库的优势：</h3><h4 id="1-复杂查询"><a href="#1-复杂查询" class="headerlink" title="1. 复杂查询"></a>1. 复杂查询</h4><ul><li>可以用SQL语句方便的在多个表之间做非常复杂的数据查询。 </li></ul><h4 id="2-事务支持"><a href="#2-事务支持" class="headerlink" title="2. 事务支持"></a>2. 事务支持</h4><ul><li>使得对于安全性能很高的数据访问要求得以实现。</li></ul><h3 id="非关系型数据库的优势："><a href="#非关系型数据库的优势：" class="headerlink" title="非关系型数据库的优势："></a>非关系型数据库的优势：</h3><h4 id="1-性能"><a href="#1-性能" class="headerlink" title="1. 性能"></a>1. 性能</h4><ul><li>NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li></ul><h4 id="2-可扩展性"><a href="#2-可扩展性" class="headerlink" title="2. 可扩展性"></a>2. 可扩展性</h4><ul><li>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li></ul><h2 id="MongoDB优点"><a href="#MongoDB优点" class="headerlink" title="MongoDB优点"></a>MongoDB优点</h2><p>它的特点是高性能、易部署、易使用，存储数据非常方便。</p><p>主要功能特性有：</p><ul><li><p>面向集合存储，易存储对象类型的数据。</p></li><li><p>模式自由。</p></li><li><p>支持动态查询。</p></li><li><p>支持完全索引，包含内部对象。</p></li><li><p>支持查询。</p></li><li><p>支持复制和故障恢复。</p></li><li><p>使用高效的二进制数据存储，包括大型对象（如视频等）。</p></li><li><p>自动处理碎片，以支持云计算层次的扩展性</p></li><li><p>支持RUBY，PYTHON，JAVA，C++，PHP等多种语言。</p></li><li><p>文件存储格式为BSON（一种JSON的扩展）</p></li></ul><p>#### </p><h2 id="BSON-存储格式"><a href="#BSON-存储格式" class="headerlink" title="BSON 存储格式"></a>BSON 存储格式</h2><p>BSON是一种类似<a href="http://baike.baidu.com/view/136475.htm" target="_blank" rel="noopener">json</a>的二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的<strong>文档对象</strong>和<strong>数组对象</strong>，但是<strong>BSON</strong>有JSON没有的一些数据类型，**如Date和BinData类型。</p><p>BSON有三个特点：<strong>轻量性</strong>、<strong>可遍历性</strong>、<strong>高效性</strong>。 </p><p>非关系型数据库文件存储格式为 <strong>BSON</strong>（一种JSON的扩展）。</p><h2 id="MongoDB下载与安装"><a href="#MongoDB下载与安装" class="headerlink" title="MongoDB下载与安装"></a>MongoDB下载与安装</h2><h3 id="1-MongoDB下载："><a href="#1-MongoDB下载：" class="headerlink" title="1. MongoDB下载："></a>1. MongoDB下载：</h3><p><a href="https://www.mongodb.com/download-center#community" target="_blank" rel="noopener">https://www.mongodb.com/download-center#community</a>&gt;</p><h3 id="2-设置环境变量"><a href="#2-设置环境变量" class="headerlink" title="2. 设置环境变量"></a>2. 设置环境变量</h3><p>在环境变量窗口中一般有两个变量，一个是你当前所使用的用户独有的环境变量，另一个是所有用户都可以访问的系统变量。其实如果在你的电脑上你只使用一个用户的话，那么不管你修改的用户的环境变量还是系统变量，效果都是一样的。为了以防未来会新建其他用户，那么我建议你修改系统变量而不是某个用户独有的环境变量。</p><h3 id="3-测试连接"><a href="#3-测试连接" class="headerlink" title="3. 测试连接"></a>3. 测试连接</h3><ul><li>管理员身份运行 cmd 输入 <code>mongo</code></li><li>启动 mongdb 服务 <code>net start mongdb</code></li><li>关闭 mongdb 服务 <code>net stop MongoDB</code></li></ul><h3 id="4-安装可视化工具-Robo-3T"><a href="#4-安装可视化工具-Robo-3T" class="headerlink" title="4. 安装可视化工具(Robo 3T)"></a>4. 安装可视化工具(Robo 3T)</h3><p><a href="https://robomongo.org/download" target="_blank" rel="noopener">https://robomongo.org/download</a></p><p>node 使用 MongoDB</p><p>连接 MongoDB</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 下载 mongoose </span></span><br><span class="line">cnpm i mongoose -D </span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 引入 mongoose </span></span><br><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>( <span class="string">'mongoose'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 连接 mongoose </span></span><br><span class="line"><span class="comment">// 连接本地mongodb ，本机的ip 127.0.0.1，端口：27017 数据库：student</span></span><br><span class="line">mongoose.connect(<span class="string">"mongodb://127.0.0.1:27017/student"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!err)&#123; </span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"connected to Mongodb"</span>); <span class="comment">//连接成功</span></span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">throw</span> err;<span class="comment">//如果连接失败，则抛出异常</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>存储数据</p><p>Schema不仅<strong>定义了文档结构和使用性能</strong>，还可以有扩展插件、实例方法、静态方法、复合索引、文档生命周期钩子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Schema  ：   一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力</span><br><span class="line"></span><br><span class="line">Model   ：   由Schema发布生成的模型，具有抽象属性和行为的数据库操作对</span><br><span class="line"></span><br><span class="line">Entity  ：   由Model创建的实体，他的操作也会影响数据库</span><br></pre></td></tr></table></figure><p>存储数据步骤：定义Schema (骨架) &gt; 创建model（模型）&gt;  Entity实例化方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>( <span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"></span><br><span class="line">mongoose.connect( <span class="string">'mongodb://127.0.0.1:27017/meijuna'</span>,(error) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> ( error ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> error</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'database is connected~'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123;  <span class="comment">//定义数据模型</span></span><br><span class="line">  username: <span class="built_in">String</span>,</span><br><span class="line">  password: <span class="built_in">String</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过模式studentSchema  创建一个模型studentModel </span></span><br><span class="line"><span class="keyword">var</span> studentModel = mongoose.model(<span class="string">"students"</span>,studentSchema );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> studentModel (); </span><br><span class="line">instance1.name=<span class="string">"tangyan"</span>;</span><br><span class="line">instance1.age=<span class="string">"18"</span>;</span><br><span class="line"></span><br><span class="line">instance1.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;   <span class="comment">//通过save方法保存</span></span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'保存失败'</span>);  </span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>查询数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 查</span><br><span class="line">userModel.find(&#123;&#125;, ( error, result ) =&gt; &#123;</span><br><span class="line"> if ( error ) throw error </span><br><span class="line">console.log ( result )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>修改数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">userModel.find(&#123; <span class="attr">username</span>: <span class="string">'aaa'</span>&#125;, ( error, result) =&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> _id = result[<span class="number">0</span>]._id</span><br><span class="line"></span><br><span class="line">  userModel.findById(_id, ( error, doc ) =&gt; &#123;    <span class="comment">// 修改</span></span><br><span class="line">    <span class="keyword">if</span> (error ) <span class="keyword">throw</span> error</span><br><span class="line">    <span class="built_in">console</span>.log( doc );</span><br><span class="line">    doc.username = <span class="string">"meijuna"</span>;</span><br><span class="line">    doc.save ( <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> error</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"数据修改成功"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>删除数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">userModel.find(&#123; <span class="attr">username</span>: <span class="string">'aaa'</span>&#125;, ( error, result) =&gt;&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error</span><br><span class="line">  <span class="keyword">const</span> _id = result[<span class="number">0</span>]._id</span><br><span class="line"></span><br><span class="line">  userModel.findById(_id, ( error, doc ) =&gt; &#123;    <span class="comment">// 删除</span></span><br><span class="line">    <span class="keyword">if</span> (error ) <span class="keyword">throw</span> error</span><br><span class="line"></span><br><span class="line">    doc.remove( <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) <span class="keyword">throw</span> error</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'数据删除成功！'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注册</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"></span><br><span class="line">mongoose.connect(<span class="string">'mongodb://127.0.0.1:27017/meijuna'</span>, (error) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="keyword">throw</span> error</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'database is connected !!!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123; <span class="comment">//定义数据模型</span></span><br><span class="line">  username: <span class="built_in">String</span>,</span><br><span class="line">  password: <span class="built_in">String</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> userModel = mongoose.model(<span class="string">'users'</span>, userSchema) <span class="comment">//模型创建</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> userModel(); <span class="comment">//创建实体</span></span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/'</span>, (req, res, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username,  password &#125; = req.query;</span><br><span class="line">  <span class="built_in">console</span>.log(username,password);</span><br><span class="line">   userModel.find(&#123;&#125;, (error, result) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> flag = result.some(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item.username === username</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123; <span class="comment">//用户名存在</span></span><br><span class="line">      res.render(<span class="string">'register'</span>, &#123;</span><br><span class="line">        data: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">          ret: <span class="literal">true</span>, <span class="comment">//身份验证 权限验证</span></span><br><span class="line">          status: <span class="number">2</span> <span class="comment">//0 表示失败 1：成功  2：</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      user.username = username;</span><br><span class="line">      user.password = password;</span><br><span class="line">      user.save();</span><br><span class="line"></span><br><span class="line">      res.render(<span class="string">'register'</span>, &#123;</span><br><span class="line">        data: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">          ret : <span class="literal">true</span>,</span><br><span class="line">          status: <span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MongoDB&quot;&gt;&lt;a href=&quot;#MongoDB&quot; class=&quot;headerlink&quot; title=&quot;MongoDB&quot;&gt;&lt;/a&gt;MongoDB&lt;/h1&gt;&lt;p&gt;MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩
      
    
    </summary>
    
      <category term="数据库" scheme="http://meijuna.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Node" scheme="http://meijuna.github.io/tags/Node/"/>
    
      <category term="mongoDB" scheme="http://meijuna.github.io/tags/mongoDB/"/>
    
      <category term="数据库" scheme="http://meijuna.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Mackdown 基本语法</title>
    <link href="http://meijuna.github.io/2019/06/18/Mackdown%E8%AF%AD%E6%B3%95/"/>
    <id>http://meijuna.github.io/2019/06/18/Mackdown语法/</id>
    <published>2019-06-18T11:24:38.075Z</published>
    <updated>2019-06-18T05:41:05.814Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Markdown-简介"><a href="#1、Markdown-简介" class="headerlink" title="1、Markdown 简介"></a>1、Markdown 简介</h3><p>但是，在我们正式写下第一个文字前，我们需要了解一下究竟什么是 Markdown？</p><blockquote><p>Markdown 是一种可以使用普通文本编辑器编写的 标记语言，通过简单的 标记语法，它可以使普通文本内容具有一定的格式</p></blockquote><p>基于 Markdown 语法的简洁性，它已经成为目前世界上最流行的用于书写博客的语言</p><h3 id="2、Markdown-语法"><a href="#2、Markdown-语法" class="headerlink" title="2、Markdown 语法"></a>2、Markdown 语法</h3><p>2、Markdown 语法<br>在编写 Markdown 时，博主强烈的推荐给大家一款简洁易用的 Markdown 编辑器 —— Typora</p><p>按照官方的说法就是 简单而强大，它不仅支持原生的语法，也支持对应的快捷键，更重要的是它还可以 实时预览</p><p>这里附上 Typora 的下载地址：<a href="https://www.typora.io/，有兴趣的朋友可以下载来试试" target="_blank" rel="noopener">https://www.typora.io/，有兴趣的朋友可以下载来试试</a></p><p>好，下面开始进入正题，介绍一些常用的 Markdown 语法</p><h4 id="（1）标题"><a href="#（1）标题" class="headerlink" title="（1）标题"></a>（1）标题</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line"></span><br><span class="line">## 二级标题</span><br><span class="line"></span><br><span class="line">### 三级标题</span><br><span class="line"></span><br><span class="line">#### 四级标题</span><br><span class="line"></span><br><span class="line">##### 五级标题</span><br><span class="line"></span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>Typora 快捷键：</p><p>Ctrl+1：一级标题</p><p>Ctrl+2：二级标题</p><p>Ctrl+3：三级标题</p><p>Ctrl+4：四级标题</p><p>Ctrl+5：五级标题</p><p>Ctrl+6 ：六级标题</p><p>Ctrl+0：段落</p><h4 id="（2）粗体、斜体、删除线和下划线"><a href="#（2）粗体、斜体、删除线和下划线" class="headerlink" title="（2）粗体、斜体、删除线和下划线"></a>（2）粗体、斜体、删除线和下划线</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br><span class="line">***加粗斜体***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>Typora 快捷键：</p><p>Ctrl+I：斜体</p><p>Ctrl+B：粗体</p><p>Ctrl+U：下划线</p><p>Alt+Shift+5：删除线</p><h4 id="（3）引用块"><a href="#（3）引用块" class="headerlink" title="（3）引用块"></a>（3）引用块</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">文字引用：</span><br><span class="line">&gt;Typora 快捷键： Ctrl+Shift+Q</span><br></pre></td></tr></table></figure><h4 id="（4）代块"><a href="#（4）代块" class="headerlink" title="（4）代块"></a>（4）代块</h4><p>Markdown 语法：</p><p>行内代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">行内代码</span><br><span class="line"></span><br><span class="line">多行代码：</span><br><span class="line"></span><br><span class="line">多行代码</span><br><span class="line">多行代码</span><br><span class="line">多行代码</span><br></pre></td></tr></table></figure><p>Typora 快捷键：</p><p>行内代码：Ctrl+Shift+`</p><p>多行代码：Ctrl+Shift+K</p><h4 id="（5）公式块"><a href="#（5）公式块" class="headerlink" title="（5）公式块"></a>（5）公式块</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">数学公式</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>Typora 快捷键： Ctrl+Shift+M</p><h4 id="（6）分割线"><a href="#（6）分割线" class="headerlink" title="（6）分割线"></a>（6）分割线</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法一：---</span><br><span class="line"></span><br><span class="line">方法二：+++</span><br><span class="line"></span><br><span class="line">方法三：***</span><br></pre></td></tr></table></figure><h4 id="（7）列表"><a href="#（7）列表" class="headerlink" title="（7）列表"></a>（7）列表</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表项</span><br><span class="line"></span><br><span class="line">* 无序列表项</span><br><span class="line"></span><br><span class="line">+ 无序列表项</span><br><span class="line"></span><br><span class="line">- 无序列表项</span><br></pre></td></tr></table></figure><p>Typora 快捷键：</p><p>有序列表项：Ctrl+Shift+[</p><p>无序列表项：Ctrl+Shift+]</p><h4 id="（8）表格"><a href="#（8）表格" class="headerlink" title="（8）表格"></a>（8）表格</h4><p>Markdown 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">表头1|表头2</span><br><span class="line">-|-|-</span><br><span class="line">内容11|内容12</span><br><span class="line">内容21|内容22</span><br></pre></td></tr></table></figure><table><thead><tr><th>表头1</th><th>表头2</th></tr></thead><tbody><tr><td>内容11</td><td>内容12</td></tr><tr><td>内容21</td><td>内容22</td></tr></tbody></table><p>Typora 快捷键： <strong>Ctrl+T</strong></p><h4 id="（9）超链接"><a href="#（9）超链接" class="headerlink" title="（9）超链接"></a>（9）超链接</h4><p>Markdown语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法一：[链接文字](链接地址 &quot;链接描述&quot;)</span><br><span class="line">例如：[示例链接](https://www.example.com/ &quot;示例链接&quot;)</span><br><span class="line"></span><br><span class="line">方法二：&lt;链接地址&gt;</span><br><span class="line">例如：&lt;https://www.example.com/&gt;</span><br></pre></td></tr></table></figure><p>Typora快捷键： <strong>Ctrl+K</strong></p><h4 id="（10）图片"><a href="#（10）图片" class="headerlink" title="（10）图片"></a>（10）图片</h4><p>Markdown语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![图片文字](图片地址 &quot;图片描述&quot;)</span><br><span class="line">例如：![示例图片](https://www.example.com/example.PNG &quot;示例图片&quot;)</span><br></pre></td></tr></table></figure><p>Typora快捷键： <strong>Ctrl+Shift+I</strong></p><p><strong>说明</strong>：在 Hexo中 插入图片时，请按照以下的步骤进行设置</p><ol><li>将 站点配置文件 中的 post_asset_folde 选项的值设置为 true</li></ol><ol start="2"><li><p>在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件</p></li><li><p>这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p></li><li>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <code>![示例图片](title/example.PNG &quot;示例图片&quot;)</code> 添加图片</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、Markdown-简介&quot;&gt;&lt;a href=&quot;#1、Markdown-简介&quot; class=&quot;headerlink&quot; title=&quot;1、Markdown 简介&quot;&gt;&lt;/a&gt;1、Markdown 简介&lt;/h3&gt;&lt;p&gt;但是，在我们正式写下第一个文字前，我们需要了解一下究
      
    
    </summary>
    
      <category term="前端" scheme="http://meijuna.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Mackdown" scheme="http://meijuna.github.io/tags/Mackdown/"/>
    
  </entry>
  
  <entry>
    <title>HTML+css 基础语法</title>
    <link href="http://meijuna.github.io/2019/06/18/HTML+css%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://meijuna.github.io/2019/06/18/HTML+css 基础语法/</id>
    <published>2019-06-18T11:24:38.055Z</published>
    <updated>2019-06-21T13:19:30.298Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、HTML"><a href="#一、HTML" class="headerlink" title="一、HTML"></a>一、HTML</h3><p><strong>什是么网站？</strong>     </p><p>​      网站(Website)开始是指在因特网上根据一定的规则，使用HTML等工具制作的用于展示特定内容相关网页的集合</p><p><strong>什么是网页？</strong></p><p>​       网页是一个包含HTML标签的纯文本文件，它可以存放在世界某个角落的某一台计算机中，是超文本标记语言格式文件扩展名为.html。</p><p>文字与图片是构成一个网页的两个最基本的元素。</p><h4 id="1-WEB标准的概念及组成"><a href="#1-WEB标准的概念及组成" class="headerlink" title="1. WEB标准的概念及组成"></a>1. <strong>WEB</strong>标准的概念及组成</h4><p><img src="/2019/06/18/HTML+css 基础语法/HTML笔记/01.jpg" alt="组成"></p><p><strong>结构：</strong></p><p>HTML- 超文本标记语言 (Hyper Text Markup Language)  </p><p>XHTML-可扩展超文本标记语言(EXtensible HyperText Markup Language)</p><p><strong>表现：</strong></p><p>CSS-层叠样式表（Cascading Style Sheets）</p><p><strong>行为：</strong></p><p>JavaScript-是轻量级的脚本语言</p><h4 id="2-XHTM基本语法"><a href="#2-XHTM基本语法" class="headerlink" title="2. XHTM基本语法"></a>2. XHTM基本语法</h4><h5 id="1、常规标记-双标记"><a href="#1、常规标记-双标记" class="headerlink" title="1、常规标记/双标记"></a>1、常规标记/双标记</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标记</span> 属性=<span class="string">“属性值”</span>  属性=<span class="string">“属性值”</span>&gt;</span><span class="tag">&lt;/<span class="name">标记</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2、空标记-单标记"><a href="#2、空标记-单标记" class="headerlink" title="2、空标记/单标记"></a>2、空标记/单标记</h5><p>&lt;标记 属性=“属性值” /&gt;</p><p><strong>说明：</strong></p><p>​      写在&lt;&gt;中的第一个单词叫做标记、标签、元素名。</p><p>​      标记和属性用空格隔开，属性和属性值用等号连接，属性值必须放在“”号内。</p><p>​      一个标记可以没有属性也可以有多个属性，属性和属性之间不分先后顺序。</p><p>​      空标记没有单独的结束标签，用“/”代替。</p><h4 id="3-HTML5-基本结构"><a href="#3-HTML5-基本结构" class="headerlink" title="3. HTML5 基本结构"></a>3. <strong>HTML5</strong> <strong>基本结构</strong></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype html&gt;</span>文档类型声明</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span>说明文档写的是标记语言 ，根标签</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span>文件头部</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span>文件标题（显示在状态栏上的内容）</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span>['metə]</span><br><span class="line">编码格式--meta标记用于定义文件信息，对网页文件进行说明，便于搜索引擎查找设置关键字等  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span>文件主体(所有要写的内容)</span><br></pre></td></tr></table></figure><h4 id="4-标签-lt-gt"><a href="#4-标签-lt-gt" class="headerlink" title="4. 标签(&lt;&gt;)"></a>4. 标签(&lt;&gt;)</h4><h4 id="（1）标签单双分类（根据有无单独的结束标签）："><a href="#（1）标签单双分类（根据有无单独的结束标签）：" class="headerlink" title="（1）标签单双分类（根据有无单独的结束标签）："></a>（1）标签单双分类（根据有无单独的结束标签）：</h4><p>​          <strong>1. 双标签（常规标签）：有单独的结束标签</strong></p><p>​               h1~h6  p b strong i em del sup sub s strike ul ol dl dt dd li a table tr td</p><p>​               div span</p><p>​          <strong>2. 单标签（空标签）：没有单独结束标签</strong></p><p>​               br  hr img ​          </p><h4 id="（2）元素行块分类（根据有没有自占一行进行分类的）："><a href="#（2）元素行块分类（根据有没有自占一行进行分类的）：" class="headerlink" title="（2）元素行块分类（根据有没有自占一行进行分类的）："></a>（2）元素行块分类（根据有没有自占一行进行分类的）：</h4><p>​         <strong>1. 块状元素：自占一行：</strong></p><p>​                h1~h6  p  hr ul ol  dl  dt  dd   li   table div del</p><p>​          <strong>2.行内元素：</strong>宽度跟内容大小一致，并且可以跟其他的行内元素在一行内并列显示的：</p><p>​                 b  strong i em del s strike sup sub br  img a imput buttom span</p><h4 id="（3）标签作用"><a href="#（3）标签作用" class="headerlink" title="（3）标签作用"></a>（3）标签作用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">加粗：</span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>定义粗体的文本<span class="tag">&lt;/<span class="name">b</span>&gt;</span>     //没有语义强调的意思，一般称为物理字体格式化标签</span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>把文本定义为语气更强的强调的内容<span class="tag">&lt;/<span class="name">strong</span>&gt;</span> //有语意 强调</span><br><span class="line">倾斜：</span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>显示斜体文本效果<span class="tag">&lt;/<span class="name">i</span>&gt;</span> //没有语义强调的意思，一般称为物理字体格式化标签</span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>把文本定义为强调的内容<span class="tag">&lt;/<span class="name">em</span>&gt;</span>  //有语意 强调</span><br><span class="line">删除标记：</span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">s</span>&gt;</span>元素，已废弃，用来给文本加删除线(在HTML 4.01中废除)</span><br><span class="line">HTML5 重定义了 <span class="tag">&lt;<span class="name">s</span>&gt;</span> 元素，现在是被用来定义那些不正确的文本。</span><br><span class="line"><span class="tag">&lt;<span class="name">strike</span>&gt;</span> 定义加删除线文本(html5不推荐使用)</span><br><span class="line">sup ：上标文本    sub：下标文本</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**注：**语义强调作用的```<span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>```比```<span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>```更容易引起搜索引擎的注意，但是如果只是为了加粗样式，建议在css样式表里面实现  </span><br><span class="line"></span><br><span class="line">**div标记** (division-部分)</span><br><span class="line"></span><br><span class="line">可定义文档中的分区或节,可以把文档分割为独立的、不同的部分</span><br><span class="line"></span><br><span class="line">作用：文档区域，文档布局对象</span><br><span class="line"></span><br><span class="line">**span标记**</span><br><span class="line"></span><br><span class="line">文本结点：用来组合文档中的行内元素</span><br></pre></td></tr></table></figure><h4 id="5-列表（ul-ol-dl）"><a href="#5-列表（ul-ol-dl）" class="headerlink" title="5. 列表（ul, ol,  dl）"></a>5. 列表（ul, ol,  dl）</h4><p>HTML中有<strong>三种列表</strong>，分别是：<strong>无序列表(ul)，有序列表(ol)，自定义列表(dl)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">无序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>--unordered List</span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">    … …</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line">有序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span>-ordered List</span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项内容<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        … …</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line">自定义列表 </span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span>Definition List</span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>名词<span class="tag">&lt;/<span class="name">dt</span>&gt;</span>Definition term</span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>解释<span class="tag">&lt;/<span class="name">dd</span>&gt;</span>Definition Description</span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="6-图片-img"><a href="#6-图片-img" class="headerlink" title="6. 图片(img)"></a>6. <strong>图片</strong>(img)</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"目标文件路径及全称"</span> <span class="attr">alt</span>=<span class="string">"图片替换文本"</span> <span class="attr">title</span>=<span class="string">"图片标题"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><strong>1. src属性：</strong>规定显示图像的 URL</p><p><strong>2. title属性:</strong>  在你鼠标悬停在该图片上时显示一个小提示，鼠标离开就没有了，HTML的绝大多数标签都支持title属性，title属性就是专门做提示信息的;</p><p><strong>3. alt属性:</strong> 规定图像的替代文本。[ælt] olt</p><p>注:所要插入的的图片必须放在站点下</p><p>src==source所用图片的来源(路径)</p><h4 id="7-超链接-a"><a href="#7-超链接-a" class="headerlink" title="7. 超链接(a)"></a>7. <strong>超链接(a)</strong></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">title</span>=<span class="string">""</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span> 链接文本/图片<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>1. href属性</strong>：设置目标文件路径</p><p><strong>2. title属性</strong>：超链接标题</p><p><strong>3. target属性</strong>：设置超链接的打开方式  [‘tɑrɡɪt]</p><p>   属性值：_blank-新窗口打开    [blæŋk]</p><p>​                 _self-默认的打开方式（本窗口打开） </p><p>​                 _top 在顶层WINDOW对象中打开,一般用于多层框架嵌套的情况<br>​                 _parent 在父窗口打开,一般用于框架内的窗口改变父窗口页面 [‘peər(ə)nt]</p><p>Href== Hypertext Reference的缩写，意思是超文本引用</p><h4 id="8-表单-from"><a href="#8-表单-from" class="headerlink" title="8. 表单(from)"></a>8. 表单(from)</h4><p> 作用：用来收集用户信息的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"test.html"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">name</span>=<span class="string">"myFomr"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">maxlength</span>=<span class="string">"50"</span> <span class="attr">placeholder</span>=<span class="string">"邮箱账号或手机账号"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"userPassword"</span>  <span class="attr">placeholder</span>=<span class="string">"密码"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"reset"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><strong>action属性：</strong>规定当提交表单时，向何处发送表单数据。’ækʃ(ə)n] </li><li><strong>method属性：</strong>规定如何发送表单数据（表单数据发送到 action 属性所规定的页面）浏览器使用method属性设置的方法将表单中的数据传送给服务器进行处理。共有两种方法：POST 方法和 GET 方法。[‘meθəd] </li></ol><h5 id="1-文本框-input"><a href="#1-文本框-input" class="headerlink" title="1.文本框(input)"></a>1.文本框(input)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"uername"</span> <span class="attr">value</span>=<span class="string">"内容"</span> <span class="attr">placeholder</span>=<span class="string">"提示"</span> <span class="attr">maxlength</span>=<span class="string">"20"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol><li><strong>type属性：</strong> 规定 input 元素的类型；（password，email，button）。</li><li><strong>value属性:</strong>  为 input 元素设定值；</li><li><strong>name属性：</strong>规定 input 元素的名称。name 属性用于对提交到服务器后的表单数据进行标识，或者在客户端通过 JavaScript 引用表单数据，只有设置了name属性的表单元素才能在提交表单时传递它们的值。</li><li><p><strong>placeholder属性：</strong>规定帮助用户填写输入字段的提示</p></li><li><p><strong>maxlength属性：</strong>规定输入字段中的字符的最大长度</p></li></ol><h5 id="2-按钮-button"><a href="#2-按钮-button" class="headerlink" title="2. 按钮(button)"></a>2. 按钮(button)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; name=&quot;&quot;  value=&quot;按钮内容&quot; /&gt;</span><br></pre></td></tr></table></figure><p><strong>button和submit的区别：</strong></p><p>submit是提交按钮起到提交信息的作用，button只是一个按钮</p><p>3.</p><h4 id="9-表格-table"><a href="#9-表格-table" class="headerlink" title="9. 表格(table)"></a>9. 表格(table)</h4><p><strong>作用</strong>：显示数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"600px"</span> <span class="attr">height</span>=<span class="string">"400px"</span> <span class="attr">border</span>=<span class="string">"3"</span> <span class="attr">cellspacing</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"4"</span>&gt;</span>第一个单元格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">rowspan</span>=<span class="string">"4"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"4"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"4"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p><strong>table:</strong>  标签定义HTML表格</p></li><li><p><strong>tr:</strong>  元素定义表格行(table row)</p></li><li><p><strong>td:</strong>  元素定义表格单元(table data数据)</p></li><li><p><strong>border:</strong>  “表格的边框”</p></li><li><p><strong>bordercolor:</strong>“表格边框颜色”</p></li><li><p><strong>cellspacing=0</strong>:  单元格与单元格之间的间距</p></li><li><p><strong>cellpadding:</strong>  单元格与内容之间的空隙</p><p>​     水平对齐方式：align=”left/center/right”;</p><p>​     垂直对齐方式： vertical-align=”top/middle/bottom”;</p><p>​     注：对其方式在td,tr上使用</p></li><li><p><strong>colspan:</strong>  所要合并的单元格的列数” 横向合并;</p></li><li><p><strong>rowspan:</strong>  所要合并单元格的行数” 纵向合并;</p></li></ol><h4 id="10-HTML和XHTML的语法区别"><a href="#10-HTML和XHTML的语法区别" class="headerlink" title="10. HTML和XHTML的语法区别"></a>10. HTML和XHTML的语法区别</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XHTML 要求标签正确嵌套</span><br><span class="line">XHTML 所有标签必须关闭   /</span><br><span class="line">XHTML 区分大小写            </span><br><span class="line">XHTML 属性值要用双引号</span><br><span class="line">XHTML 用 id 属性代替 name 属性</span><br><span class="line">XHTML 特殊字符的处理 &amp;nbsp; &amp;lt; &amp;gt;</span><br></pre></td></tr></table></figure><h3 id="二、CSS基础"><a href="#二、CSS基础" class="headerlink" title="二、CSS基础"></a>二、CSS基础</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">white-space:pre</span><br><span class="line">   nowrap //文本不进行换行知道</span><br><span class="line">text-overflow:  //设置单行文本溢出是否显示省略号</span><br><span class="line">clip 修剪文本</span><br></pre></td></tr></table></figure><p><strong>CSS (cascading style sheets)</strong>WEB标准中的表现标准语言,表现标准语言在网页中主要对网页信息的显示进行控制，简单说就是如何修饰网页的显示样式。<strong>—级联样式表、层叠样式表</strong></p><p><strong>语法：</strong>选择符 { 属性：属性值；属性：属性值 }</p><h4 id="1-样式表分类-内部、外部、内嵌"><a href="#1-样式表分类-内部、外部、内嵌" class="headerlink" title="1.样式表分类(内部、外部、内嵌)"></a>1.样式表分类(内部、外部、内嵌)</h4><h5 id="1-内部样式-style"><a href="#1-内部样式-style" class="headerlink" title="1. 内部样式(style)"></a>1. 内部样式(style)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined">选择符 &#123; 属性：属性值；属性：属性值 &#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-外部样式-link"><a href="#2-外部样式-link" class="headerlink" title="2. 外部样式(link)"></a>2. 外部样式(link)</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel="stylesheet" type="text/css" href="目标文件路径" /&gt;</span><br></pre></td></tr></table></figure><ol><li><p><strong>rel:</strong>   规定当前文档与被连接文档之间的关系 stylesheet: 样式表</p></li><li><p><strong>type: </strong> 规定被链接文档的类型</p></li><li><p><strong>href:</strong>  规定被链接文档的位置</p></li></ol><h5 id="3-外部样式表的导入-2-import"><a href="#3-外部样式表的导入-2-import" class="headerlink" title="3.外部样式表的导入-2(@import)"></a>3.外部样式表的导入-2(@import)</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">@<span class="keyword">import</span> url(目标文件的路径就文件全称);</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>@和import之间没有空格 url和小括号之间也没有空格；必须结尾以分号结束</p><h5 id="3-外部样式对比"><a href="#3-外部样式对比" class="headerlink" title="3.外部样式对比"></a>3.外部样式对比</h5><p>两种导入样式表的方法比较：</p><ul><li>link 属于 HTML 标签，而 @import 是 CSS 提供的。</li><li>页面被加载时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载。</li><li>@import 只在 IE 5 以上才能识别，而 link 是 HTML 标签，无兼容问题。</li><li>link 方式的样式的权重高于 @import 权重。</li></ul><p>一般推荐使用 link 导入样式表的方法，@import 可以作为补充方法使用。</p><h4 id="2-选择器（选择符）"><a href="#2-选择器（选择符）" class="headerlink" title="2. 选择器（选择符）"></a>2. <strong>选择器（选择符）</strong></h4><h5 id="1-元素选择器-类型选择器（标签"><a href="#1-元素选择器-类型选择器（标签" class="headerlink" title="1.  元素选择器/类型选择器（标签 )"></a><strong>1.  元素选择器/类型选择器（标签 )</strong></h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：元素名称&#123;属性：属性值；&#125;</span><br><span class="line">说明：</span><br><span class="line">元素选择符就是以文档语言对象类型作为选择符，即使用结构中元素名称作为选择符。例如body、div、p,img,em,strong,span等。</span><br></pre></td></tr></table></figure><h5 id="2-id选择器"><a href="#2-id选择器" class="headerlink" title="2. id选择器 (#)"></a><strong>2. id选择器</strong> (#)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法：#id名&#123; &#125;&#123;属性：属性值;&#125;</span><br><span class="line"> <span class="tag">&lt;<span class="name">标记</span> <span class="attr">id</span>=<span class="string">"名称1   名称2"</span> &gt;</span><span class="tag">&lt;/<span class="name">标记</span>&gt;</span></span><br><span class="line">说明：</span><br><span class="line">1） id属性值，在一个html文档中，必须是唯一的，不可重复，不能用关键字(所有的标记和属性都是关键字)</span><br><span class="line">2）一个id名称只能对应文档中一个具体的元素对象，因为id只能定义页面中某一个唯一的元素对象。</span><br><span class="line">3) 最大的用处：创建网页的外围结构</span><br></pre></td></tr></table></figure><h5 id="3-css选择器"><a href="#3-css选择器" class="headerlink" title="3. css选择器(.)"></a><strong>3. css选择器</strong>(.)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：.class名&#123;属性：属性值;&#125;</span><br><span class="line"> <span class="tag">&lt;<span class="name">标记</span> <span class="attr">class</span>=<span class="string">"名称1   名称2"</span> &gt;</span><span class="tag">&lt;/<span class="name">标记</span>&gt;</span></span><br><span class="line">说明：</span><br><span class="line">1）class选择符更适合定义一类样式； </span><br><span class="line">2） 一个标记可以设置多个class名</span><br><span class="line">3）class名可以重复</span><br><span class="line">4）限定标签类型</span><br></pre></td></tr></table></figure><h5 id="4-群组选择器"><a href="#4-群组选择器" class="headerlink" title="4. 群组选择器(,)"></a>4. 群组选择器(,)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：选择器1，选择器2，选择器3&#123;属性：属性值;&#125;</span><br><span class="line"></span><br><span class="line">说明：当有多个选择符应用相同的样式时，可以将选择符用“，”分隔的方式，合并为一组</span><br></pre></td></tr></table></figure><h5 id="5-后代选择器-包含选择器"><a href="#5-后代选择器-包含选择器" class="headerlink" title="5. 后代选择器/包含选择器"></a><strong>5. 后代选择器/包含选择器</strong></h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：选择器1 选择器2&#123;属性：属性值;&#125;</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">包含选择器选择器1和选择器2用空格隔开，含义就是选择符1中包含的所有选择器2;</span><br></pre></td></tr></table></figure><h5 id="6-子选择器-gt"><a href="#6-子选择器-gt" class="headerlink" title="6. 子选择器(&gt;)"></a><strong>6. 子选择器</strong>(&gt;)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法： 选择器1&gt;选择器2&#123;属性：属性值;&#125;</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">选择符1和选择符2用&gt;链接，选择符2必须是选择符1的子类</span><br></pre></td></tr></table></figure><h5 id="7-伪类选择器-hover"><a href="#7-伪类选择器-hover" class="headerlink" title="7. 伪类选择器(:hover)"></a>7. 伪类选择器(:hover)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法 ：</span><br><span class="line">       :link&#123;属性：属性值;&#125; //超链接的初始状态;</span><br><span class="line">       :visited&#123;属性：属性值;&#125; //超链接被访问后的状态;   ['vɪzɪtɪd] </span><br><span class="line">       :hover&#123;属性：属性值;&#125; //鼠标悬停，即鼠标划过超链接时的状态;</span><br><span class="line">       :active&#123;属性：属性值;&#125; //超链接被激活时的状态，即鼠标按下时超链接的状态; ['æktɪv]</span><br><span class="line">       :focus //元素获得焦点的样式   ['fəʊkəs] </span><br><span class="line">说明：</span><br><span class="line">1）当这4个超链接伪类选择符联合使用时，应注意他们的顺序，正常顺序为：a:link,a:visited,a:hover,a:active,错误的顺序有时会使超链接的样式失效； </span><br><span class="line">2）使用与超链接相关的伪类选择符时，应为a元素定义href属性;</span><br></pre></td></tr></table></figure><h5 id="8-通配符"><a href="#8-通配符" class="headerlink" title="8. 通配符(*)"></a>8. 通配符(*)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">语法：*&#123;属性：属性值；&#125;</span><br><span class="line"></span><br><span class="line">说明：通配选择符的写法是“*”，其含义就是所有元素。</span><br><span class="line">用法：常用来重置样式</span><br><span class="line">全局样式</span><br><span class="line">*&#123;margin:0;padding:0;&#125;</span><br><span class="line">margin:0 auto; 让子元素相对父元素水平居中显示</span><br></pre></td></tr></table></figure><h4 id="3-选择器的权重"><a href="#3-选择器的权重" class="headerlink" title="3. 选择器的权重"></a><strong>3. 选择器的权重</strong></h4><p><img src="/2019/06/18/HTML+css 基础语法/HTML笔记/1553140597918.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">内联  id  class 标签</span><br><span class="line"> 1    0   0     0</span><br><span class="line"># css中用四位数字表示权重，权重的表达方式如：0，0，0，0</span><br><span class="line"># id 0100</span><br><span class="line"># class选择器  （伪类选择符 :focus,:hover以及&lt;a&gt;:link） 0010 </span><br><span class="line"># 属性选择符的权重为     0010</span><br><span class="line"># 元素a 伪元素 :before、:after  0001</span><br><span class="line"># 后代选择符：1 2 =  1 + 2 </span><br><span class="line"># 子选择器 1 &gt; 2 = 1 + 2</span><br><span class="line"># 群组看选择符类型</span><br><span class="line"># *&#123;&#125;(通配符) 0 </span><br><span class="line"># 继承 0</span><br><span class="line"># 权重相同时，根据书写顺序而定，后书写的会把县书写的覆盖掉，会显示后书写的代码效果</span><br></pre></td></tr></table></figure><h4 id="4-CSS特性：-层叠性和继承性"><a href="#4-CSS特性：-层叠性和继承性" class="headerlink" title="4. CSS特性：(层叠性和继承性)"></a>4. CSS特性：(<strong>层叠性</strong>和<strong>继承性</strong>)</h4><p><strong>层叠性：</strong>一个元素可能同时被多个css选择器选中，每个选择器都有一些css规则，这就是层叠。</p><p>CSS的处理原则是：</p><p>1）如果多个选择器定义的规则不发生冲突，则元素将应用所有选择器定义的样式。</p><p>2）如果多个选择器定义的规则发生了冲突，则CSS按选择器的特殊性(权重)让元素应用特殊性(权重)高的选择器定义的样式。</p><p><strong>继承</strong>：所谓继承，就是父元素的规则也会适用于子元素。比如给body设置为color:Red;那么他内部的元素如果没有其他的规则设置，也都会变成红色。继承得来的规则没有特殊性。</p><p>多数边框类属性，比如Padding（补白），Margin（边界），背景和边框的属性都是不能继承的。(border属性是用来设置元素的边框的，它没有继承性)</p><p>块状、内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font-family、font-size、font-style、font-weight、text-decoration、text-transform.</p><p>块状元素可继承：text-indent和text-align。</p><p>列表元素可继承： list-style、list-style-type、list-style-position、list-style-image。</p><p>表格元素可继承：border-collapse。</p><p>css层叠性：<br>​       使用不同的选择符作用于同一个对象，每个选择符都有一些css声明/规则<br>​       如果规则没有发生冲突，这些样式都可以被执行<br>​       如果规则发生了冲突，根据选择符的权重/特殊性而定，执行权重高的选择符设置的样式<br>​       权重：<br>​          内联：1000<br>​          id：100<br>​          class 伪类：10<br>​          类型：1<br>​          群组：根据具体对象而定<br>​          包含：将使用的选择符相加=和<br>​          子：子结合符&gt; = 0  其他选择符相加=和<br>​          通配父，继承的样式 子结合符：权重为0<br>​           </p><p>   css继承性： 子类可以继承父类的css样式<br>​          可以利用css继承，节省代码量，提高代码的可读性</p><h4 id="5-颜色-color"><a href="#5-颜色-color" class="headerlink" title="5. 颜色(color)"></a>5. 颜色(color)</h4><p>可以用以下方法来规定 CSS 中的颜色：</p><ul><li><p>十六进制色 ：十六进制颜色是这样规定的：#RRGGBB，其中的 RR（红色）、GG（绿色）、BB（蓝色）十六进制整数规定了颜色的成分。所有值必须介于 0 与 FF 之间。举例说，#0000ff 值显示为蓝色，这是因为蓝色成分被设置为最高值（ff），而其他成分被设置为 0。</p></li><li><p>RGB 颜色：RGB 颜色值是这样规定的：rgb(red, green, blue)。每个参数 (red、green 以及 blue) 定义颜色的强度，可以是介于 0 与 255 之间的整数，或者是百分比值（从 0% 到 100%）。举例说，rgb(0,0,255) 值显示为蓝色，这是因为 blue 参数被设置为最高值（255），而其他被设置为 0。</p></li><li><p>RGBA 颜色：颜色值是 RGB 颜色值的扩展，带有一个 alpha 通道 - 它规定了对象的不透明度。</p><p>RGBA 颜色值是这样规定的：rgba(red, green, blue, alpha)。alpha 参数是介于 0.0（完全透明）与 1.0（完全不透明）的数字。</p></li><li><p>HSL 颜色：颜色值是这样规定的：hsl(hue, saturation, lightness)。</p><p>Hue 是色盘上的度数（从 0 到 360） - 0 (或 360) 是红色，120 是绿色，240 是蓝色。Saturation 是百分比值；0% 意味着灰色，而 100% 是全彩。Lightness 同样是百分比值；0% 是黑色，100% 是白色。</p></li><li><p>HSLA 颜色 ：颜色值是这样规定的：hsla(hue, saturation, lightness, alpha)，其中的 alpha 参数定义不透明度。alpha 参数是介于 0.0（完全透明）与 1.0（完全不透明）的数字。</p></li><li><p>预定义/跨浏览器颜色名</p></li></ul><h4 id="6-浮动-float"><a href="#6-浮动-float" class="headerlink" title="6. 浮动(float)"></a>6. 浮动(float)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">margin:0 auto/margin:auto;放置在一个标签上，可以使此标签在父元素中水平居中</span><br><span class="line">float:left/right/none</span><br><span class="line">   A. 给元素添加浮动之后，会脱离正常文档流</span><br><span class="line">   B. 子元素浮动了，父元素在没有设置高度的情况下，会高度塌陷</span><br><span class="line">   C. 给元素添加浮动之后，元素会产生块级框，而不论本身是什么元素类型</span><br><span class="line">块状元素：</span><br><span class="line">         默认：</span><br><span class="line">             width:auto  -  与父元素同宽</span><br><span class="line">             height:auto -  与内容的高度相同</span><br><span class="line">         加浮动之后：</span><br><span class="line">             width:auto  -  与内容同宽</span><br><span class="line">             height:auto -  与内容的高度相同  </span><br><span class="line">         设置具体的宽度和高度,设置的属性为多少，显示的大小就是多少</span><br><span class="line">             width:300px;height:300px    </span><br><span class="line">    行内元素：</span><br><span class="line">         默认：不能设置宽度和高度，设置了显示无效</span><br><span class="line">               所以行内元素的显示大小，根据内容多少而定</span><br><span class="line">         加浮动之后：变成块状元素；    </span><br><span class="line">width:auto; =不设宽度</span><br><span class="line">  A. 对于块状元素而言,浏览器自动计算，，会与父元素同宽，</span><br><span class="line">  B.  对于块状元素而言，如果盒子浮动了，宽度与内容同宽</span><br><span class="line">  C. 如果给盒子设置具体的width:value，设置的多少，显示多宽</span><br><span class="line">2. 浮动对盒子宽度的影响：     </span><br><span class="line">          </span><br><span class="line">          标签的宽度为：width:auto; </span><br><span class="line">  A. 对于块状元素而言,浏览器自动计算，，会与父元素同宽，</span><br><span class="line">  B.  对于块状元素而言，如果盒子浮动了，宽度与内容同宽</span><br><span class="line">   </span><br><span class="line">          盒子的宽度为：width:value；</span><br><span class="line">          如果给盒子设置具体的width:value，设置的多少，显示多宽           </span><br><span class="line">         3. 浮动对盒子文档流的影响</span><br><span class="line">          添加了浮动的盒子，会脱离正常文档流；</span><br><span class="line">        </span><br><span class="line">         4. 父元素的高度塌陷</span><br><span class="line">         父元素在没有设置具体高度的情况下，子元素全部浮动了，父元素的高度为0；</span><br><span class="line">         </span><br><span class="line">        5. 浮动的图片应用：以往这个属性总应用于图像，使文本围绕在图像周围</span><br><span class="line">        </span><br><span class="line">        6. 浮动元素会生成一个块级框，而不论它本身是何种元素。</span><br><span class="line">   width:height固定宽度时，除了padding 不管里面有多少内容 width height不变 </span><br><span class="line">   解决flaot父元素高度塌陷</span><br><span class="line">   1.overflow:</span><br></pre></td></tr></table></figure><p> 块状元素，当width的属性值为auto/没写时，浏览器自动计算宽度，宽度是与父元素同宽</p><p>​           宽度：width:auto;</p><p>​           高度：400px</p><p>​           行内元素：不能设置宽度和高度，设置无效</p><h4 id="7-background"><a href="#7-background" class="headerlink" title="7. background"></a>7. background</h4><p>background-image:url(../img/mao.gif);<br>background-repeat:no-repeat;<br>background-position:100px 100px;  起始点时左上角   [pəˈzɪʃn]</p><p>background-position:100% 100%     起始点时中心<br>background-position:center;<br>background-position:227px 99px;</p><p> 背景颜色：background-color<br>​       背景图片：background-image<br>​       背景重复：background-repeat [rɪ’piːt] 重复<br>​       背景定位：background-position  [pəˈzɪʃən] 位置<br>​       背景状态：background-attachment  [ə’tætʃm(ə)nt] e ta xu ment<br>​       background：color url repeat position attachment; [‘kʌlə(r)]</p><p>单位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">绝对长度单位、相对长度单位</span><br><span class="line">   绝对：cm mm in 等等</span><br><span class="line">   相对：</span><br><span class="line">        ex - 字符x的高度   1ex=x的高度 </span><br><span class="line">        em - 当前元素/父元素的文本大小  1em=font-size </span><br><span class="line">        px - 设备上能显示的最小单位 css相对长度单位</span><br></pre></td></tr></table></figure><h4 id="8-文本-font-fɒnt"><a href="#8-文本-font-fɒnt" class="headerlink" title="8. 文本(font)[fɒnt]"></a>8. 文本(font)[fɒnt]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">font-size: &#123;      none:[nʌn]  norm:[nɔːm] </span><br><span class="line">    px：设定固定值 </span><br><span class="line">    %:基于父元素的一个百分比值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">font-family: &#123;//规定元素的字体系列</span><br><span class="line">    (1)此属性设置几个字体名称作为一种&quot;后备&quot;机制，如果浏览器不支持第一种字体，将尝试下一种字体。</span><br><span class="line">    (2) 如果字体系列的名称超过一个字，它必须用引号，如Font Family：&quot;宋体&quot;&quot;Times New Roman&quot;。</span><br><span class="line">    (3) 多个字体系列是用一个逗号分隔指明;</span><br><span class="line">&#125;</span><br><span class="line">font-weight:设置显示元素的文本中所用的字体加粗 &#123;  [weɪt]</span><br><span class="line">    1-500=normal ,600-900=bold [bəʊld] </span><br><span class="line">    bolder 更粗</span><br><span class="line">&#125;</span><br><span class="line">font-style: //设置文本倾斜&#123;</span><br><span class="line">italic [ɪ&apos;tælɪk] </span><br><span class="line">oblique  [ə&apos;bliːk]</span><br><span class="line">&#125;</span><br><span class="line">text-indent&#123;</span><br><span class="line">%</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">text-align:设置文本水平对齐&#123;  [ə&apos;laɪn] </span><br><span class="line">    left right center [ˈsentə(r)] justify </span><br><span class="line">    行内元素和文本是一样的   文本和行内元素都有作用对 块元素水平居中(0 auto)</span><br><span class="line">&#125;</span><br><span class="line">text-decoration: 文本修饰 [dekə&apos;reɪʃ(ə)n]&#123; // [dekə&apos;reɪʃ(ə)n] </span><br><span class="line">underline:文本下一条线 [ʌndə&apos;laɪn] </span><br><span class="line">overline: 文本上一条线</span><br><span class="line">line-through: 穿过文本一条线 [θruː]</span><br><span class="line">&#125;</span><br><span class="line">text-transform：&#123;  //设置文本大小写  [træns&apos;fɔrm] </span><br><span class="line"> capitalize: [&apos;kæpɪtəlaɪz] 文本单词开头大写</span><br><span class="line">     uppercase: [&apos;ʌpə&apos;keɪs]  文本定义大小</span><br><span class="line">     lowercase: [ləʊə&apos;keɪs] 文本定义小写</span><br><span class="line">&#125;</span><br><span class="line">letter-spacing: &#123; //定义字符之间的间隔</span><br><span class="line">+ -  </span><br><span class="line">对汉字起作用</span><br><span class="line">&#125;</span><br><span class="line">word-spacing: &#123; //定义单词与单词之间的间隔z</span><br><span class="line">只对单词有作用（字母和汉字无效）</span><br><span class="line">&#125;</span><br><span class="line">顺序: font-style | font-variant(小体大写字母) | font-weight | font-size / line-height | font-family </span><br><span class="line">font:[italic] [bold] 20px/&#123;100px] &apos;楷体&apos;;</span><br></pre></td></tr></table></figure><h4 id="9-行高-line-hight"><a href="#9-行高-line-hight" class="headerlink" title="9. 行高(line-hight)"></a>9. 行高(line-hight)</h4><p>文本行的基线间的距离</p><p><img src="/2019/06/18/HTML+css 基础语法/HTML笔记/1553307042913.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">默认字体16px =&gt; lin-hight=21px;</span><br><span class="line">line-lenght:number 此数字会与当前字体尺寸相乘来设置行间距(2=2em,1em=元素文本大小)</span><br><span class="line">%：基于当前字体尺寸的百分比(100%=当前尺寸)</span><br><span class="line">10px</span><br><span class="line">16px</span><br><span class="line">10px</span><br><span class="line"></span><br><span class="line">10px</span><br><span class="line">16px</span><br><span class="line">10px</span><br><span class="line">文本在行高内垂直居中</span><br><span class="line">应用户单行文本 控制文本的垂直居中 应用于多行文本控制多行文本的间距</span><br></pre></td></tr></table></figure><p><img src="/2019/06/18/HTML+css 基础语法/HTML笔记/1553306925881.png" alt=""></p><h4 id="10-边框-border"><a href="#10-边框-border" class="headerlink" title="10. 边框(border)"></a>10. 边框(border)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">border-color:设置边框颜色 red green blue;上  左右 下</span><br><span class="line">border-weight: </span><br><span class="line">bordrer-style: 设置边框类型 dotted(点状) dashed(虚线) solid(实线) double(双线)</span><br><span class="line">border- : 元素的所有边框设置宽度，或者单独地为各边边框设置宽度。</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">outline****：（轮廓）**是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用，轮廓线不会占据空间，也不一定是矩形。</span><br><span class="line"></span><br><span class="line">outline-width</span><br><span class="line"></span><br><span class="line">outline-style</span><br><span class="line"></span><br><span class="line">outline-color</span><br><span class="line"></span><br><span class="line">outline:简写</span><br><span class="line"></span><br><span class="line">border跟outline的区别：</span><br><span class="line"></span><br><span class="line">1. border可应用于几乎所有有形的html元素，而outline是针对链接、表单控件和ImageMap等元素设计</span><br><span class="line">2. border占据空间，outline不占据空间</span><br></pre></td></tr></table></figure><h4 id="11-列表-list"><a href="#11-列表-list" class="headerlink" title="11. 列表(list)"></a>11. 列表(list)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list-style：none;去掉列表符号</span><br><span class="line">//定义列表符号的位置 [pəˈzɪʃən]</span><br><span class="line">list-style-position:inside（列表项目放置在文本以内，且环绕文本根据标记对齐） outside(默认)</span><br><span class="line">list-style-image: 设置图片作为列表符号</span><br><span class="line">list-type: 设置列表项标记的类型</span><br><span class="line">disc(实心圆)square(实心方块)decimal(数字)</span><br><span class="line">[dɪsk]    [skweə]          [&apos;desɪm(ə)l]</span><br></pre></td></tr></table></figure><h4 id="12-盒模型"><a href="#12-盒模型" class="headerlink" title="12.盒模型"></a>12.盒模型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 占据的宽度：width+左右padding+左右border+左右margin</span><br><span class="line"> 占据的高度：height+上下padding+上下border+上下margin</span><br><span class="line"> 1.     盒模型的四个组成部分：</span><br><span class="line">   content[kən&apos;tent] padding border margin</span><br><span class="line"></span><br><span class="line">padding: 调整内容在盒子中的位置关系</span><br><span class="line">1. 需要添加到父元素上</span><br><span class="line">2. 不允许是负边距值</span><br><span class="line">3. 可以把内容撑大 </span><br><span class="line">4. 行内可以设置padding,但是显示有问题(上下显示有问题，左右没问题)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1）. 将图片放在超链接中，在ie的低版本浏览器中，会自动解释出边框；</span><br><span class="line">    解决方法:img&#123;border:0/none&#125;</span><br><span class="line">2）. 将图片放在行内元素中，在行内元素没有设置高度的基础上，会将行内元素在图片自身高度的基础上，撑大3~5px</span><br><span class="line">        A. img&#123;display:block&#125;</span><br><span class="line">        B.  div&#123;font-size:0</span><br><span class="line">        c. overflow:hidden;</span><br><span class="line">        d.float:left;&#125;”。如果要实现图文混排，这种方法是很好的选择</span><br><span class="line">5. display:设置元素的显示类型</span><br><span class="line">        block：将元素设置为块状元素 </span><br><span class="line">        图片将盒子撑大3~5px的原因：、</span><br><span class="line">        因为图片是行内元素，跟匿名文本之间的对齐方式是基线对齐，在文本基线的下行距</span><br><span class="line">        会</span><br></pre></td></tr></table></figure><h5 id="外边距-margin"><a href="#外边距-margin" class="headerlink" title="外边距(margin)"></a>外边距(margin)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% 属性总结</span><br><span class="line">text-indent:参照父元素的宽度计算</span><br><span class="line">padding margin :基于父元素的宽度计算</span><br><span class="line">width height: 父元素的width,height</span><br><span class="line">line-height：参照元素的font-size</span><br><span class="line">background-size: 参照父元素 你   </span><br><span class="line">absolut:left/right/top/bottom</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">负值属性</span><br><span class="line">text-indent -负值</span><br><span class="line">background-postion: 负值</span><br><span class="line">margin</span><br><span class="line">absolut:left/right/top/bottom</span><br><span class="line">z-index: 0=auto</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">简写属性</span><br><span class="line">background:</span><br><span class="line">border:</span><br><span class="line">font:</span><br><span class="line">list-style: type position</span><br><span class="line">list-style: url position</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">margin：auto - 浏览器计算  --具体valuepx/em/cm/mm  %</span><br><span class="line">padding：不能为auto ，---具体valuepx/em/cm/mm  %</span><br><span class="line">  1. 给子元素设置margin-top时，会影响到父元素一起向下移动；</span><br><span class="line">      A. 给父元素后者子元素添加浮动</span><br><span class="line">      B. 给父元素加边框</span><br><span class="line">      C. overflow:hidden;</span><br><span class="line">   2. 两个盒子之间的margin区域是可以重叠的（没有浮动的情况下）；</span><br><span class="line">   3. 两个浮动盒子之间的margin区域是不重叠的；</span><br><span class="line">   4. margin可以设置负值，显示方向和正值完全相反；</span><br><span class="line">   5. 行内元素可以执行margin，但是上下显示  不正确，左右显示正确(padding一样)</span><br></pre></td></tr></table></figure><h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">overflow: //主要应用 设置溢出盒子的显示方式</span><br><span class="line">visible:默认溢出，正常显示  [ˈvɪzəbl]</span><br><span class="line">hidden:溢出以后，隐藏 [&apos;hɪdn]</span><br><span class="line">scroll: 显示滚动条 [skrəʊl] </span><br><span class="line">auto: 如果溢出显示滚动条，如果不溢出就不显示滚动条</span><br><span class="line">其他应用：</span><br><span class="line">A，给父元素添加overflow:hidden 可以解决高度塌陷</span><br><span class="line">B. 给父元素添加overflow:hidden  解决给子元素设置maring-top 影响父元素一起向上移动</span><br><span class="line">overflow-x</span><br><span class="line">overflow-y</span><br><span class="line">省略</span><br><span class="line">text-overflow: clip //直接裁剪</span><br><span class="line">ellipsis //显示省略号</span><br><span class="line">string  新增的，浏览器不支持</span><br><span class="line">width:设置官渡</span><br><span class="line">overflow: hidden </span><br><span class="line">white-space:nowrap //强制让文本在一行内显示</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">块级格式化上下文 BFC</span><br><span class="line">其实归根结底，这里的浮动没有清除，只是因为overflow属性的值是hidden的时候会形成一个BFC，而BFC就是一个隔离的渲染区域，因此浮动造成的高崩塌会导致对外部布局的影响，为了消除这种不益的表现，计算高度的时候浮动元素也计算进去了。</span><br><span class="line"></span><br><span class="line">需要保证满足下面至少一条就会触发BFC：</span><br><span class="line"></span><br><span class="line">根元素body；</span><br><span class="line">设置了float值不为none的元素；</span><br><span class="line">设置了overflow属性不为visible的元素；</span><br><span class="line">设置了属性position不为relative和static的元素；</span><br><span class="line">设置了display的值为flex、table-cell、table-caption和inline-block中的任何一个的元素。</span><br><span class="line">可以看出来，就是一个比较独立的块，因为是一个独立的环境，在开发时候适度使用会有效降低开发和维护难度。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">大致可以归纳为三个方面：独立性、垂直分布规则和水平分布规则。</span><br><span class="line"></span><br><span class="line">独立性：BFC是页面上一个隔离的容器，和外面的关系是不会互相影响，对浮动而言也是，不会和浮动元素发生重叠，高也和上面提到的一样不会崩塌；</span><br><span class="line">垂直分布规则：BFC的内部里面的一个个盒子在垂直方向一个接着一个排放，位置由margin决定，两个相邻的盒子margin会发生重叠；</span><br><span class="line">水平分布规则：BFC里面的盒子的左外边缘和包含块的左边相接触，简单的理解就是水平方向不会发生margin重叠。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">要实现溢出时产生省略号的效果还需定义：</span><br><span class="line"> </span><br><span class="line">1）、容器宽度：width：value；</span><br><span class="line">2）、强制文本在一行内显示:white-space：nowrap;</span><br><span class="line">3）、溢出内容为隐藏：overflow：hidden；</span><br><span class="line">4）、溢出文本显示省略号：text-overflow：ellipsis; [ɪ&apos;lɪpsɪs]</span><br></pre></td></tr></table></figure><h4 id="元素类型"><a href="#元素类型" class="headerlink" title="元素类型"></a>元素类型</h4><ol><li>块状元素</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 1. display: //设置盒子的显示类型</span><br><span class="line">          none:此标签在浏览器中不显示</span><br><span class="line">          block：此标签显示为块状元素-div p ul ol dl dt dd h1 form h1~h6</span><br><span class="line">          inline:此标签显示为行内元素-a span b strong i em img br sup sub</span><br><span class="line">          inline-block:此标签显示为行内块元素 - input; 行内</span><br><span class="line">          list-item:此标签显示为列表项标签 - li</span><br><span class="line">          table:此标签显示为块级表格标签 - table</span><br><span class="line"></span><br><span class="line">        元素类型：</span><br><span class="line">         块状级元素：display:block list-item table</span><br><span class="line">         行内级元素：display:inline inline-block inline-table;</span><br><span class="line"></span><br><span class="line">2. 块状元素的特征：  </span><br><span class="line">   (1) 可以设置宽度和高度</span><br><span class="line">   (2) 自占一行</span><br><span class="line">   (3) 作为容器使用，作为盒子使用，可以正确解释4盒模型中的属性；</span><br><span class="line">   (4) 给盒子添加浮动之后，盒子在没有设置宽度和高度的情况下，在没有内容的情况下，宽度，高度为0；</span><br><span class="line"></span><br><span class="line">行内设置 a img span i em b strong br sub sup del s</span><br><span class="line">3. 行内元素的特征：</span><br><span class="line">   A。不能设置宽度和高度</span><br><span class="line">   B。可以和其他行内元素在一行内显示</span><br><span class="line">   C。行内元素也符合盒模型的特征，也能执行盒模型中的规则，但是margin，padding，border的上下显示不正确，左右显示正常；</span><br><span class="line">   D。盒子的大小有内容而定，如果给行内元素添加浮动之后，会生成块级框，变成块状元素</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.行内元素</span><br><span class="line">2.行内元素1</span><br><span class="line">ver-align练习</span><br><span class="line">置换元素和飞置换元素</span><br><span class="line">小米商城</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">行内元素垂直方向的对齐方式：默认基线对齐</span><br><span class="line">1.给元素添加float 摆脱基线对齐 基线(小写字母x ,s,a 的下断沿的先)</span><br><span class="line">2.行内元素在开发工具书写时，如果进行换行和空格</span><br><span class="line">解决：A. 写在一行，不进行换行</span><br><span class="line"> B. 给所有的行内元素添加float</span><br><span class="line"> c. 给行内元素的父元素设置 font-size: 0; 当时行内元素有继承 font-size:0; 影响元素内的文本大小为0； 解决：给行内元素再设置font-size</span><br></pre></td></tr></table></figure><h5 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vertical-align  设置元素的垂直的对齐方式</span><br><span class="line">baseline: 默认 元素放在父元素的基线上(父元素的基线就是文本内容的基线)</span><br><span class="line">top</span><br><span class="line">bottom</span><br><span class="line">middle 垂直居中对齐</span><br><span class="line">sub: 垂直对齐文本的下标</span><br><span class="line">super:</span><br><span class="line">在没有边距没区别</span><br><span class="line">%：当前line-hight(开发不推荐) 允许负值 正值：向上移动当前行高的大小</span><br><span class="line">       负值：向下移动当前行高的大小</span><br></pre></td></tr></table></figure><h4 id="置换元素"><a href="#置换元素" class="headerlink" title="置换元素"></a>置换元素</h4><p><img src="/2019/06/18/HTML+css 基础语法/HTML笔记/1553755206346.png" alt=""></p><p><img src="/2019/06/18/HTML+css 基础语法/HTML笔记/1553755238537.png" alt=""></p><h5 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postion: </span><br><span class="line">absolute 绝对定位 相当于static 定位以为的第一个父元素定位</span><br><span class="line">body--position:static div没设就是static</span><br><span class="line">hmlt---是绝对定为诶元素最大的参照物-默认</span><br><span class="line">fixed</span><br></pre></td></tr></table></figure><h5 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">1. 行内元素在垂直方向的对其方式：默认是基线对其</span><br><span class="line">   基线：参照css核心属性的笔记-line-height</span><br><span class="line">         小写的英文字母x,s,a的下断沿的线</span><br><span class="line"></span><br><span class="line">2. 行内元素在开发工具中书写时，如果进行换行或者空格，在浏览器中，两个标签之间有一个空格；</span><br><span class="line"></span><br><span class="line">3. 去掉空格：</span><br><span class="line">  A. 写在一行中，不进行换行；</span><br><span class="line">  B. 给所有的行内元素添加浮动；</span><br><span class="line">  C. 给行内元素的父元素设置font-size：0；可以解决这个问题，但是行内元素会继承font-size:0;造成元素内的文本大小为0；</span><br><span class="line">       解决：给行内元素单独再设置文本大小</span><br><span class="line">  D. 都都转为inline-block</span><br><span class="line"></span><br><span class="line">4. vertical-align： 设置元素的垂直对齐方式</span><br><span class="line">   注意：用在行内元素上面才有效</span><br><span class="line"></span><br><span class="line">5. 图片将盒子撑大3~5px的原因</span><br><span class="line">   因为图片是行内元素，跟空白字节之间的对其方式是基线对其，在文本基线的下面有下行间距，下行间距会将盒子撑大3~5px； </span><br><span class="line">   方法：img&#123;display：block&#125;</span><br><span class="line">         div&#123;font-size:0;&#125;</span><br><span class="line">         img&#123;vertical-align:只要不是baseline ，推荐使用top，middle，bottom&#125;  </span><br><span class="line"></span><br><span class="line">6. </span><br><span class="line">    静态定位的特点：</span><br><span class="line">    position:static; 静态定位-没有特殊的定位效果，正常在文档流中显示</span><br><span class="line">  </span><br><span class="line">    绝对定位的使用和特点：</span><br><span class="line">        (1) : position:absolute-绝对定位;</span><br><span class="line">        (2) : 根据参照物进行定位（参照物==包含块：有除了static以外的定位设置，并且是定位元素的父元素）</span><br><span class="line">        (3) : left right top bottom 确定元素坐标的位置</span><br><span class="line">        (4) : left right top bottom:属性值可以是正值也可以是负值,属性值可以为%，px</span><br><span class="line">        (5) 我们可以改变包含块的对象，不一定非是html</span><br><span class="line">              只要是父元素，只要设置了其他的定位设置（除static以为），都可以作为定位元素的参照物</span><br><span class="line">        (6) 绝对定位会使元素脱离正常文档流；            </span><br><span class="line"></span><br><span class="line">   body: ----默认是position:static;</span><br><span class="line">   html:----是绝对定位元素最大的参照物，具有除静态定位以外的其他定位设置；</span><br><span class="line"></span><br><span class="line">    相对定位的使用和特点：</span><br><span class="line">        （1）相对定位不会使元素脱离正常文档流；   </span><br><span class="line"></span><br><span class="line">7. 元素在垂直方向上的层叠顺序</span><br><span class="line">    (1) 如果元素没有设置css表现，按正常的书写，后书写的显示在上面</span><br><span class="line">    (2) 如果元素设置定位（除static之外），层叠顺序比没有设置定位的元素高；</span><br><span class="line">    (3) 如果两个盒子都设置了定位，后书写的比较高</span><br><span class="line">    (4) 可以设置z-index属性，来提高元素的层叠顺序；</span><br><span class="line">      z-index: auto/number;</span><br><span class="line">      值越大，层叠顺序越高</span><br><span class="line">      值越小，层叠顺序越低</span><br><span class="line">      z-index属性必须结合position属性使用才有效（属性值除static以外）；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">重点：       给盒子添加浮动，会脱离文档流</span><br><span class="line">            给行内元素添加浮动，产生块级框，变成块状元素</span><br><span class="line">            给盒子添加绝对定位，会脱离文档流</span><br><span class="line">            给行内元素添加绝对定位，产生块级框，变成块状元素</span><br><span class="line">            </span><br><span class="line">p 标签不能 嵌套div</span><br><span class="line">a 标签不能嵌套 a标签</span><br><span class="line">h1 标题不能嵌套 标题</span><br></pre></td></tr></table></figure><ol><li><p>盒模型</p><p>content(width,height) + border + padding + margin </p></li><li><p>overflow使用-设置溢出容器的内容，如何显示</p><pre><code>visible:表示溢出正常显示  [ˈvɪzəbl]hidden：表示溢出容器的内容，被裁剪掉scroll：让容器显示滚动条，查看其余的内容  [skrəʊl]auto：如果溢出显示滚动条，不溢出就不显示</code></pre><p>省略号的设置：<br>   text-overflow：clip - 直接裁剪</p><pre><code>ellipsis- 显示省略号string - 新增的，浏览器不支持</code></pre><p>   width:设置宽度   overflow：hidden-溢出隐藏   white-space：nowrap 强制让文本在一行内显示；  </p><ol start="3"><li>元素类型<br>类型分类： 块状元素  行内（内联）元素<br>块状元素：对应的标签：li ul ol dt dd form table h1~h6 div p<br>​            特征:(1) 能设置宽度和高度（2）自占一行 （3）作为容器使用，能正常解释盒模型的属性 （4）盒子在浏览器中以块的形式显示，宽度默认是auto与父元素同宽，高度根据内容而定，没有内容宽度为0<br>行内元素：对应标签： a img i em b strong span br sup sub del s input<br>​            特征：（1）不能设置宽度和高度  （2）在一行内显示（3）也可以遵循盒模型的规则，但是个别显示不正确，border，padding，margin上下显示不正确，左右显示正常 （4）盒子的大小有内容而定，如果添加了浮动，盒子变成块状元素<br>display：设置盒子的显示类型<br>​    none：让盒子消失不可见<br>​    block：快装<br>​    inline：行内<br>​    inline-block：行内块元素<br>​    list-item：显示列表项 -li<br>​    table：显示为块状表格</li><li>定位：<br>position：<br>absolute：绝对定位<br>​    （1） 会使元素脱离正常文档流<br>​    （2） 根据包含块进行定位<br>​         包含块：离绝对定位元素最近的并且有定位设置的父元素，定位设置不能是默认值-static<br>​    （3） 根据left right top bottom<br>相对定位：relative  [‘relətɪv]<br>​    （1） 不会使元素脱离正常文档流<br>​    （2） 根据自身在正常文档流中的位置进行坐标的偏移<br>​    （3） 根据left right top bottom    [‘bɒtəm]<br>​    fixed：固定定位   [fɪkst]<br>​    （1） 会使元素脱离正常文档流<br>​    （2） 根据窗口进行定位<br>​    （3） 根据left right top bottom<br>​    stiky：粘性定位<br>​     （1）在窗口范围内，定位效果像相对定位，当移动浏览器滚动条，盒子距离窗口的位置=设置的像素数时，盒子位置不发生改变，像固定定位<br>​    static：默认的定位效果，没有任务特殊的定位，在正常文档流中显示<br>z-index：设置元素的堆叠顺序；<br>​    auto：跟父元素的堆叠顺序相同<br>​    number：数字越大，顺序越高，数字越小，顺序越低<br>注意：必须结合position：absolute，relative，fixed，不能是static<br>包含块的概念：为绝对定位的元素提供坐标偏移的参照物<br>设置元素为包含块：给元素添加position：absolute，relative ，fixed 不能是static（推荐使用相对定位，因为不会使用元素脱离正常文档流）</li></ol><p>锚点：（1）a href = “#锚点名”<br>​           在同一页面的不同位置进行跳转<br>​      （2） a href =“文件路径#锚点名”<br>​           跳转到另外一个页面的锚点元素所在的位置<br>overflow-x，y：设置某个方向上内容溢出如何显示，属性值跟overflow相同</p></li></ol><ol start="5"><li><p>宽高自适应：<br>   概念，优势<br>   伪元素选择符：5个 after[‘ɑːftə]<br>   元素的高度如何自适应窗口的高度<br>   清除浮动的三种方式：3种     overflow:hidden<br>   ​                           [ə(ʊ)’pæsɪtɪ]<br>   隐藏元素：display：none    opacity：0-1     visibility：visible hidden<br>   一组属性；min/max-width/height ming max</p></li><li><p>属性选择符：权重是10；      </p></li><li><p>图片整合的概念（精灵图 图片精灵）</p></li><li>图片整合的优势（1）减少请求次数，提高加载速度  （2）减小图片的体积</li><li><p>兼容</p><p>五大浏览器采用的都是单内核，而随着浏览器的发展现在也出现了双内核。360浏览器、QQ浏览器都是采用双内核。 </p><p>   1、IE浏览器内核：Trident内核，也是俗称的IE内核；<br>   2、Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核；<br>   3、Firefox浏览器内核：Gecko内核，俗称Firefox内核；<br>   4、Safari浏览器内核：Webkit内核；<br>   5、Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是Blink内核；<br>   6、360浏览器、猎豹浏览器内核：IE+Chrome双内核；<br>   7、搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）；<br>   8、百度浏览器、世界之窗内核：IE内核；<br>   9、2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核；</p><p>常见的兼容问题：<br>​    双倍边界<br>​    默认高度<br>​    图片间隙<br>​    cursor属性：设置鼠标指针的形状；<br>​    png：ie支持png8位图片的背景透明，不支持其他的位数；</p></li></ol><h3 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h3><p>特点：<br>添加 语意标签   canvas画布 多媒体交互标签 (video src )  mack(高亮显示文字)</p><ul><li>骨架更简单</li></ul><p><img src="/2019/06/18/HTML+css 基础语法/HTML笔记/TIM截图20190403093923.png" alt=""></p><p>header nav section aside(侧边栏) footer figcaption </p><p> email<br> url 检测地址<br> number 专门用来输入数字<br>     max min<br>     step:默认1<br> range:<br>     max min step<br> search: 比文本框多了x<br> color: 调色板<br> tel: 和文本框没区别 兼容性很大  </p><p> date：<br> month  年月<br> week  年周<br> time 小时分钟<br> datetime 没显示 世界统一时<br> datetime-local   北京时间<br> output：输出框</p><p> 属性<br> required:内容空白不能提交<br> placeholder:<br> pattern:正则表达式<br> autofocus: 页面刚加载自动获得焦点<br> list:（datalistId）与datalist标签&gt;option 配合使用 类似select<br> autocomplete:自动完成功能-name历史记录<br> min max step<br> novalidate: 规定在提交表单，取消验证内容<br> multiple: 输入可以输入多个内容，用 ， 分开<br> form(fomrId值):控件链接idfrom</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">浏览器模式</span><br><span class="line"></span><br><span class="line">标准模式：ie高版本浏览器 chrome safari </span><br><span class="line"></span><br><span class="line">怪异模式：ie6 ie7</span><br><span class="line"></span><br><span class="line">什么情况下会在怪异模式下解析：</span><br><span class="line"></span><br><span class="line">​- 文档声明不正确，或者不存在</span><br><span class="line"></span><br><span class="line">​-h5中只有一种文档声明 &lt;!DOCTYPE html&gt;</span><br><span class="line"></span><br><span class="line">​html4中文不能中</span><br><span class="line"></span><br><span class="line">  1. 过渡版本</span><br><span class="line"></span><br><span class="line">     标签的使用：不能使用框架标签</span><br><span class="line"></span><br><span class="line">2. 严格版本</span><br><span class="line"></span><br><span class="line">      不能使用弃用标签，不能使用表现性标签，不能使用框架标签</span><br><span class="line"></span><br><span class="line">盒模型在不同浏览器中的解释</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### css3</span><br><span class="line"></span><br><span class="line">渐进增强</span><br><span class="line"></span><br><span class="line">优雅降级</span><br><span class="line"></span><br><span class="line">![](HTML笔记/css3.png)</span><br><span class="line"></span><br><span class="line">基本选选择符</span><br><span class="line"></span><br><span class="line">层级选择符</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">属性选择符：</span><br><span class="line"></span><br><span class="line">​input[type=&quot;e&quot;]//e开头</span><br><span class="line"></span><br><span class="line">​input[type=&quot;$e&quot;]//以e结尾的input标签</span><br><span class="line"></span><br><span class="line">​input[ytpe=&quot;*=e&quot;] //包含e的input标签</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">伪元素选择器</span><br><span class="line"></span><br><span class="line">::first-letter</span><br><span class="line"></span><br><span class="line">::firset-line</span><br><span class="line"></span><br><span class="line">::before</span><br><span class="line"></span><br><span class="line">::after</span><br><span class="line">::selection </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">伪类选择器</span><br><span class="line"></span><br><span class="line">:target  //目标伪类选择器：某个目标元素被触发的时候</span><br><span class="line"></span><br><span class="line">​锚点</span><br><span class="line"></span><br><span class="line">e:not(f) 否定伪类选择器</span><br><span class="line"></span><br><span class="line">结构伪类选择器</span><br><span class="line"></span><br><span class="line">e:mpty  // ：当元素内容为空时</span><br><span class="line"></span><br><span class="line">结构</span><br><span class="line"></span><br><span class="line">:root  // 给根元素(html)添加有</span><br><span class="line"></span><br><span class="line">:nth-child(n)  匹配父元素中的第n个子元素</span><br><span class="line"></span><br><span class="line">​n:表达式：2n+1=odd, 2n=even</span><br><span class="line"></span><br><span class="line">​数字 表达式 关键字  n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:nth-last(n) </span><br><span class="line"></span><br><span class="line">:nth-of-type(n)://先看类型在看个数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:only-child :看个数再看来下</span><br><span class="line"></span><br><span class="line">:only-of-type //来类型再看数字</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:first-child </span><br><span class="line"></span><br><span class="line">:last-child </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:first-of-type</span><br><span class="line"></span><br><span class="line">:last-of-type</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UI元素状态伪类选择器</span><br><span class="line"></span><br><span class="line">:hover</span><br><span class="line"></span><br><span class="line">:active</span><br><span class="line"></span><br><span class="line">:focus</span><br><span class="line"></span><br><span class="line">E:disabled //设置该元素处于不可用状态的样式</span><br><span class="line"></span><br><span class="line">E:enabled //设置元素处于可用状态的样式</span><br><span class="line"></span><br><span class="line">E:read-only //元素处于只读状态</span><br><span class="line"></span><br><span class="line">E:read-write //</span><br><span class="line"></span><br><span class="line">E:checked  //表单中radio or checkbox 处于选中状态</span><br><span class="line"></span><br><span class="line">E:default  //页面打开时 默认处于选中状态 （一直执行）</span><br><span class="line"></span><br><span class="line">E:selection //指定当元素处于选中状态时的样式</span><br><span class="line"></span><br><span class="line">E:indeterminate //当页面打开时，如果一组单选框都没有选中才执行，如果用户选中了一个，则样式取消</span><br><span class="line"></span><br><span class="line">valid</span><br><span class="line"></span><br><span class="line">invalid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### 内核前缀</span><br><span class="line"></span><br><span class="line">Trident内核    -ms -ms-border-radius</span><br><span class="line"></span><br><span class="line">Gecko内核： -moz (火狐)</span><br><span class="line"></span><br><span class="line">Presto内核 -o</span><br><span class="line"></span><br><span class="line">Webkit内核:-webkit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### 文本属性   </span><br><span class="line"></span><br><span class="line">中文默认自动换行，字母</span><br><span class="line"></span><br><span class="line">word-break: </span><br><span class="line"></span><br><span class="line">​norm:默认</span><br><span class="line"></span><br><span class="line">​break-all：允许单词内换行</span><br><span class="line"></span><br><span class="line">​keep-all: - 字符才换行</span><br><span class="line"></span><br><span class="line">word-wrap: 允许长单词 or url 内部进行换行</span><br><span class="line"></span><br><span class="line">text-shadow: 向文本添加应用</span><br><span class="line"></span><br><span class="line">​               3px 3px  模糊 color,-3px -5px 模糊 color</span><br><span class="line"></span><br><span class="line">###### 边框</span><br><span class="line"></span><br><span class="line">border-radius: 20px 30px;  //对角线角   圆角边框</span><br><span class="line"></span><br><span class="line">border-image: //边框图片 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">border-top-left-radius:40px 90px 水平半径 垂直半径</span><br><span class="line"></span><br><span class="line">border-image-source    </span><br><span class="line"></span><br><span class="line">&amp;&amp;  border-image-slice: //裁剪</span><br><span class="line"></span><br><span class="line">border-image-repeat: 图片平铺</span><br><span class="line"></span><br><span class="line">border-image-width: 图片边框宽度</span><br><span class="line"></span><br><span class="line">border-image-outset</span><br><span class="line"></span><br><span class="line">brder-colors  //设置边框颜色</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">box-shadow:  //设置盒子的阴影</span><br><span class="line"></span><br><span class="line">​h-shadow: 0 </span><br><span class="line"></span><br><span class="line">​v-shadow ：0</span><br><span class="line"></span><br><span class="line">​blur： 模糊距离</span><br><span class="line"></span><br><span class="line">​[]: 阴影大小 默认和盒子一样大</span><br><span class="line"></span><br><span class="line">​color</span><br><span class="line"></span><br><span class="line">​inset: 内阴影</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">指定元素的的宽度与高度的计算方法</span><br><span class="line"></span><br><span class="line">box-sizing: content-box //width =盒子内容区域大小  =标准模式</span><br><span class="line"></span><br><span class="line">​    border-box // 边框盒子大小 （content+padding+border) =怪异模式</span><br><span class="line"></span><br><span class="line">![](HTML笔记/微信图片_20190405175634.png)</span><br><span class="line"></span><br><span class="line">##### 背景</span><br><span class="line"></span><br><span class="line">background 属性提升</span><br><span class="line"></span><br><span class="line">background-size: width height </span><br><span class="line"></span><br><span class="line">​%：盒子宽度的%  盒子的%</span><br><span class="line"></span><br><span class="line">​number:   会改变比例</span><br><span class="line"></span><br><span class="line">​cover:  等比例改变宽高，能覆盖 可能超出盒子</span><br><span class="line"></span><br><span class="line">​contain: 等比例改变宽高，按最小的放大</span><br><span class="line"></span><br><span class="line">默认情况下：</span><br><span class="line"></span><br><span class="line">如果盒子有内边距，背景图从内边距的padding开始显示</span><br><span class="line"></span><br><span class="line">如果没有padding,背景图从内容盒子的</span><br><span class="line"></span><br><span class="line">background-origin  // 规定图片的显示区域</span><br><span class="line"></span><br><span class="line">​border-box //背景图从边框盒子开始显示</span><br><span class="line"></span><br><span class="line">​padding-box //默认效果</span><br><span class="line"></span><br><span class="line">​conente-box //从内容位置开始显示 没有padding</span><br><span class="line"></span><br><span class="line">background-clip //背景图片的裁剪区域</span><br><span class="line"></span><br><span class="line">​border-box 背景裁剪到边框盒</span><br><span class="line"></span><br><span class="line">​padding-box  //</span><br><span class="line"></span><br><span class="line">​content-box  背景图裁剪到内容区可见</span><br><span class="line"></span><br><span class="line">​text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-webkit-text-fill-color: //文本填充颜色</span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line">颜色</span><br><span class="line"></span><br><span class="line">rgba()</span><br><span class="line"></span><br><span class="line">hsl(色调，饱和度，亮度) &#123;0,360&#125; &#123;0,100%&#125; &#123;0,100%&#125;</span><br><span class="line"></span><br><span class="line">hsal</span><br><span class="line"></span><br><span class="line">transparent</span><br><span class="line"></span><br><span class="line">##### 字体</span><br><span class="line"></span><br><span class="line">.ttf  eot woff otf svg </span><br><span class="line"></span><br><span class="line">定义字体 </span><br><span class="line"></span><br><span class="line">font-face规则</span><br></pre></td></tr></table></figure><p>字体定义规则<br>@font-face{<br>​    定义字体名称<br>​    font-family: “myfont”<br>​    字体路径<br>​    src:url(../font)<br>}<br>font-family: “myfont”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">作业 名鞋侧边栏</span><br><span class="line"></span><br><span class="line">​淘宝工具栏</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### css3弹性盒</span><br><span class="line"></span><br><span class="line">新的布局模式-flexible box布局，即收缩布局盒模型(弹性盒布局)</span><br><span class="line"></span><br><span class="line">![](HTML笔记/css3弹性.jpg)</span><br><span class="line"></span><br><span class="line">​![](HTML笔记/css3啊.jpg)</span><br><span class="line"></span><br><span class="line">​3个版本 旧版本 混合版本 新版本</span><br><span class="line"></span><br><span class="line">容器上：</span><br><span class="line"></span><br><span class="line">display   //设置元素为弹性盒</span><br><span class="line"></span><br><span class="line">​flex/line-flex  //块状弹性盒</span><br><span class="line"></span><br><span class="line">​        使内部元素获得弹性布局效果 ，原本垂直</span><br><span class="line"></span><br><span class="line">  块级弹性盒：</span><br><span class="line"></span><br><span class="line">​      父元素如果是弹性盒子，子元素作为弹性项目，在没有设置width 的情况下，width 与内容铜矿，</span><br><span class="line"></span><br><span class="line">​     子元素作为弹性项目，在主轴方向方向从主轴起点上一次排序</span><br><span class="line"></span><br><span class="line">  子元素在没有设置height的情况下，height会拉伸与父元素同高 ，如果设置了多高就多高</span><br><span class="line"></span><br><span class="line">行内弹性盒：</span><br><span class="line"></span><br><span class="line">​</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flex-direction  //规定灵活项目的方向</span><br><span class="line"></span><br><span class="line">​row:默认值，灵活的项目水平显示</span><br><span class="line"></span><br><span class="line">​row-reverse: 与fow相同，但是以相反的顺序排列</span><br><span class="line"></span><br><span class="line">​column: 灵活项目将垂直显示</span><br><span class="line"></span><br><span class="line">​        column-reverse: 主轴方向垂直，但是以相反的顺序排列</span><br><span class="line"></span><br><span class="line">flex-wrap  // 用于设置</span><br><span class="line"></span><br><span class="line">​nowrap: 默认 不换行不换列 改变width height</span><br><span class="line"></span><br><span class="line">​wrap :  规定灵活项目必要时换行，换列</span><br><span class="line"></span><br><span class="line">​wrap-reverse </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">简写：</span><br><span class="line"></span><br><span class="line">flex-flow：flex-flow: column-reverse wrap-reverse </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">justify-content  //设置子元素在主轴(水平方向的/垂直方向)上的对齐方式</span><br><span class="line"></span><br><span class="line">​flex-start //项目位于主轴的开头、</span><br><span class="line"></span><br><span class="line">​flex-end   //项目位于主轴的结尾</span><br><span class="line"></span><br><span class="line">​enter  //位于主轴的中心</span><br><span class="line"></span><br><span class="line">​space-between // 如果父元素的width大于子元素，留下的空白平均分给两个子元素之间</span><br><span class="line"></span><br><span class="line">​space-around: //平均分别分给每个元素的两边</span><br><span class="line"></span><br><span class="line">align-items //设置子元素在侧轴方向的对齐方式</span><br><span class="line">​stretch ： 拉伸到适应容器 父元素没有height </span><br><span class="line"></span><br><span class="line">​center: 元素位于容器中心</span><br><span class="line"></span><br><span class="line">​flex-start : 侧轴的起点开始</span><br><span class="line"></span><br><span class="line">​flex-end: </span><br><span class="line"></span><br><span class="line">​baseline </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">align-content // 设置多行子元素在侧轴上的对齐方式（多行时，属性才生效)</span><br><span class="line"></span><br><span class="line">​ stretch:   //元素拉伸以适应容器</span><br><span class="line"></span><br><span class="line">​center //元素位于容器的中心</span><br><span class="line"></span><br><span class="line">​ flex-start: //侧轴起点位置</span><br><span class="line"></span><br><span class="line">​flex-end //侧轴重点</span><br><span class="line"></span><br><span class="line">​space-between: //</span><br><span class="line"></span><br><span class="line">​space-around:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 视口（viewport）</span><br><span class="line"></span><br><span class="line">视口：初始视口980  考虑移动端访问pc端</span><br></pre></td></tr></table></figure></p><p>&lt;meta name=”viewport” content=”width=device-diwh，initial=scale=”1.0&gt;<br>                          视口的width=设备屏幕的width  （1 = 按页面实际尺寸显示 无缩放）</p><pre><code>2. minimum-scale 设定最小做小比例     (0-10，1=禁止用户缩小至实际尺寸之下)3. maximum-scale 这顶最大缩放比例     (0-10，1=禁止用户放大至实际尺寸之上)4. user-scalable=&quot;no/yes&quot;     (在实际尺寸之上用户是否可也缩放)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### </span><br><span class="line"></span><br><span class="line">#### css3媒体查询</span><br></pre></td></tr></table></figure><p>@media meatype and|not|only ((条件表达式){</p><pre><code>screen</code></pre><p>}<br>css3添加媒体属性<br>only： 限定某种设备执行媒体查询<br>ccs2：媒体只能查询设备，没有条件</p><p><code>`</code></p><p><img src="/2019/06/18/HTML+css 基础语法/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555054616210.png" alt="1555054616210"></p><p><img src="/2019/06/18/HTML+css 基础语法/C:/Users/meijuna/AppData/Roaming/Typora/typora-user-images/1555054647288.png" alt="1555054647288"></p><p>移动端适配 改变html-font-size<br>vw<br>js<br>@media 不精细,避免</p><h4 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h4><p><strong>常见布局方案</strong></p><p><strong>固定布局</strong>：以像素作为页面的基本单位，不管设备屏幕及浏览器宽度，只设计一套尺寸；</p><p><strong>可切换的固定布局：</strong>同样以像素作为页面单位，参考主流设备尺寸，设计几套不同宽度的布局。通过识别的屏幕尺寸或浏览器宽度，选择最合适的那套宽度布局；</p><p><strong>弹性布局：</strong>以百分比作为页面的基本单位，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果；</p><p><strong>混合布局</strong>：同弹性布局类似，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果；只是混合像素、和百分比两种单位作为页面单位。</p><p><strong>布局响应</strong>：对页面进行响应式的设计实现，需要对相同内容进行不同宽度的布局设计，有两种方式：pc优先（从pc端开始向下设计）；<br>​                      移动优先（从移动端向上设计）；</p><p>无论基于那种模式的设计，要兼容所有设备，布局响应时不可避免地需要对模块布局做一些变化（发生布局改变的临界点称之为断点）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、HTML&quot;&gt;&lt;a href=&quot;#一、HTML&quot; class=&quot;headerlink&quot; title=&quot;一、HTML&quot;&gt;&lt;/a&gt;一、HTML&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;什是么网站？&lt;/strong&gt;     &lt;/p&gt;
&lt;p&gt;​      网站(Website)
      
    
    </summary>
    
      <category term="HTML" scheme="http://meijuna.github.io/categories/HTML/"/>
    
    
      <category term="语法" scheme="http://meijuna.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="HTML" scheme="http://meijuna.github.io/tags/HTML/"/>
    
      <category term="css" scheme="http://meijuna.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + github 搭建个人博客</title>
    <link href="http://meijuna.github.io/2019/06/18/Hexo%20+%20github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://meijuna.github.io/2019/06/18/Hexo + github 搭建个人博客/</id>
    <published>2019-06-18T11:24:38.051Z</published>
    <updated>2019-06-21T12:22:41.222Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-博客维护"><a href="#1-博客维护" class="headerlink" title="1.博客维护"></a>1.博客维护</h3><h5 id="1-发布文章"><a href="#1-发布文章" class="headerlink" title="1.发布文章"></a>1.发布文章</h5><p>在站点文件夹中打开 git bash，输入如下命令部署和发布文章:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure><p><strong>建议</strong>：在使用 <code>hexo g</code> 部署之后，可以先使用 <code>hexo s</code> 运行本地站点，然后在浏览器输入地址 <a href="http://lacolhost:4000/" target="_blank" rel="noopener">http://lacolhost:4000/</a> 查看运行结果，检查无误后再使用 <code>hexo d</code> 发布</p><h5 id="2-新建博客时添加对应的图片文件夹"><a href="#2-新建博客时添加对应的图片文件夹" class="headerlink" title="2.新建博客时添加对应的图片文件夹"></a>2.新建博客时添加对应的图片文件夹</h5><p>将 站点配置文件 中的 post_asset_folde 选项的值设置为 true</p><p>在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件</p><p>这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p><p>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <img src="/2019/06/18/Hexo + github 搭建个人博客/title/example.PNG" alt="示例图片" title="示例图片"> 添加图片</p><h5 id="3-模板设置"><a href="#3-模板设置" class="headerlink" title="3.模板设置"></a>3.模板设置</h5><p>当我们使用命令 <code>hexo new &quot;title&quot;</code> 创建文章时，Hexo 会根据 <code>/scaffolds/post.md</code> 对新文章进行初始化</p><p>换言之，<code>/scaffolds/post.md</code> 就是新文章的 <strong>模板</strong>，所以我们可以修改它来适应自己的写作习惯</p><p>在每篇利用 Hexo 创建的文章的开头，都会有对文章进行说明的文字，叫做 <strong>文章头部</strong></p><p>文章的头部除了可以设置文章标题、发布日期等基础信息外，还可以为文章添加标签、分类等</p><p>一个简单的示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: Title</span><br><span class="line">date: YYYY-MM-DD HH:MM:SS</span><br><span class="line">tags: [tag1, tag2, ...]</span><br><span class="line">categories: category</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：属性和属性值之间必须有一个空格，否则会解析错误</p><h3 id="2-搭建博客"><a href="#2-搭建博客" class="headerlink" title="2.搭建博客"></a>2.搭建博客</h3><h4 id="1-搭建github博客"><a href="#1-搭建github博客" class="headerlink" title="1.搭建github博客"></a>1.搭建github博客</h4><p>1.github新建博客文件，库名要所有者名字一样，如：<strong>meijuna.github.io</strong> 的格式</p><p>2.Settings =&gt; 选择一个主题保存 就可以访问 meijuna.github.io 了 </p><h4 id="2-Hexo搭建本地博客"><a href="#2-Hexo搭建本地博客" class="headerlink" title="2.Hexo搭建本地博客"></a>2.Hexo搭建本地博客</h4><p><strong>hexo命令</strong></p><ul><li><p>hexo s(server)  –&gt; 启动本地服务</p></li><li><p>hexo  clean –&gt; 清除缓存</p></li><li><p>hexo g (generate) –&gt; 创建网页</p></li><li><p>hexo d (deploy) –&gt; 同步到github</p></li></ul><p>1.安装node.js + git </p><p>以Windows环境安装node.js为例，首先登录<a href="https://nodejs.org/en/" target="_blank" rel="noopener">node.js官网</a>，选择适合自己的版本进行下载，然后进行安装。</p><p>登录<a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a>选择版本进行下载，基本一路<strong>next</strong>下去即可轻松完成安装。</p><p>2.首先在本地磁盘中建立一个Hexo文件夹用于存储本地文件(做本地文件保存以及测试使用)</p><p>3.下载Hexo:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo   -g</span><br></pre></td></tr></table></figure><p>4.初始化博客空间，生成博客运作所需要的文件，接下来安装依赖包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>5.同步Github,允许公共访问</p><p>1.首先找到我们的博客仓库，并拷贝仓库地址：git clone 主题仓库地址 放到 <strong>themes</strong> 文件夹下</p><p>2.打开_config.yml 文件配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy: </span><br><span class="line">    type: git</span><br><span class="line">    repo: https://github.com/meijuna/meijuna.github.io</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure><p>3.最后执行控制台命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git —save //安装部署插件</span><br><span class="line"></span><br><span class="line">hexo d //部署到github</span><br></pre></td></tr></table></figure><p>就用 meijuna.github.io 访问博客了</p><h4 id="2-Hexo-的主题美化"><a href="#2-Hexo-的主题美化" class="headerlink" title="2.Hexo 的主题美化"></a>2.Hexo 的主题美化</h4><p>1.到 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo主题官网</a> 下载主题放到 <strong>themes</strong> 文件夹</p><p>2.配置根目录的 _config.yml 中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: pure //选择下载主体文件的名字</span><br></pre></td></tr></table></figure><p>3.hexo clean -&gt; hexo g -d 看效果</p><p>4.具体主题美化看下载的主题文档</p><h4 id="3-在Hexo博客上添加可爱的Live-2D模型"><a href="#3-在Hexo博客上添加可爱的Live-2D模型" class="headerlink" title="3.在Hexo博客上添加可爱的Live 2D模型"></a>3.在Hexo博客上添加可爱的Live 2D模型</h4><p>首先，安装npm包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>然后在hexo的根目录配置文件<code>_config.yml</code>中添加如下配置，详细配置可以参考<a href="https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.md" target="_blank" rel="noopener">文档</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-koharu</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br></pre></td></tr></table></figure><p>然后下载模型，模型名称可以到<a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">这里</a>参考，一些模型的预览可以在<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">这里</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install live2d-widget-model-koharu</span><br></pre></td></tr></table></figure><p>下载完之后，在 Hexo 根目录中新建文件夹 live2d_models，然后在node_modules文件夹中找到刚刚下载的live2d模型，将其复制到 live2d_models 中，然后编辑<code>_config.ym</code>l配置文件中的model.use项，将其修改为live2d_models文件夹中的模型文件夹名称。</p><p>一切就绪之后，用<code>hexo server</code>命令启动服务器，大功告成！</p><h4 id="4-阿里云解析域名"><a href="#4-阿里云解析域名" class="headerlink" title="4.阿里云解析域名"></a>4.阿里云解析域名</h4><p>1.<a href="https://dns.console.aliyun.com/?spm=5176.100251.111252.14.7e144f15jRG8mz&amp;accounttraceid=9e23cc47-c762-4c2b-af1a-0eac8eaaed46#/dns/domainList" target="_blank" rel="noopener">阿里云</a>购买域名  解析 -&gt; 添加记录  -&gt; A 类型  -&gt; www -&gt; 默认 -&gt; ping  meijuna.github.io 地址的值 -&gt;ttl 10</p><p>3.在根目录下的 source 文件夹 创建 CNAME 文件 ，内容为 <a href="http://www.meijuna.top" target="_blank" rel="noopener">www.meijuna.top</a> </p><h4 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h4><h5 id="1-hexo中添加图片的方法"><a href="#1-hexo中添加图片的方法" class="headerlink" title="1.hexo中添加图片的方法"></a>1.hexo中添加图片的方法</h5><p>1.下载插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save // hexo n &quot;文件&quot; 自动生成相同文件名的文件夹存放图片</span><br></pre></td></tr></table></figure><p>2.设置站点配置_config.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-博客维护&quot;&gt;&lt;a href=&quot;#1-博客维护&quot; class=&quot;headerlink&quot; title=&quot;1.博客维护&quot;&gt;&lt;/a&gt;1.博客维护&lt;/h3&gt;&lt;h5 id=&quot;1-发布文章&quot;&gt;&lt;a href=&quot;#1-发布文章&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="博客" scheme="http://meijuna.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="http://meijuna.github.io/tags/Hexo/"/>
    
      <category term="博客" scheme="http://meijuna.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Git 使用</title>
    <link href="http://meijuna.github.io/2019/06/18/Git-%E4%BD%BF%E7%94%A8/"/>
    <id>http://meijuna.github.io/2019/06/18/Git-使用/</id>
    <published>2019-06-18T11:24:38.002Z</published>
    <updated>2019-06-18T13:08:21.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-操作"><a href="#git-操作" class="headerlink" title="git 操作"></a>git 操作</h2><p><code>git checkout -- file</code>可以丢弃工作区的修改</p><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p><code>git status</code>命令看看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p><p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用<code>git diff</code>这个命令看看：</p><p>git diff 比较的是工作区文件与暂存区文件的区别（上次git add 的内容）<br>git diff –cached 比较的是暂存区的文件与仓库分支里（上次git commit 后的内容）的区别</p><p>———————–版本库——————————————–<br>|                           |<br>​        git diff –cached    （是只比较暂存区和版本库的区别）             |<br>|                           |<br>————-暂存区———————-       git diff HEAD   （只比较工作区和版本库（最后一次commit）的区别）<br>|<br>​            git diff  （工作区和暂存区（最后一次add））                             |<br>|                                                        |<br>—–工作区————————————————————–</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure><p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p><p>知道了对<code>readme.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><p>在Git中，我们用<code>git log</code>命令显示从最近到最远的提交日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure><p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure><p>还可以继续回退到上一个版本<code>wrote a readme file</code>，不过且慢，然我们用<code>git log</code>再看看现在版本库的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p> 最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p><p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 1094a</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><hr><p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>然后尝试提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m &quot;append GPL&quot;</span><br><span class="line">[master 1094adb] append GPL</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p><p>现在，我们回顾一下<code>readme.txt</code>文件一共有几个版本被提交到Git仓库里了：</p><p>版本1：wrote a readme file</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>版本2：add distributed</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>版本3：append GPL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span><br><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span><br><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span><br></pre></td></tr></table></figure><p>需要友情提示的是，你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907545599be4a60a0b5044447b47c8d8b805a25d2000/0" alt="git-log-timeline"></p><p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at e475afc add distributed</span><br></pre></td></tr></table></figure><p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p><p>看看<code>readme.txt</code>的内容是不是版本<code>add distributed</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure><p>果然被还原了。</p><p>还可以继续回退到上一个版本<code>wrote a readme file</code>，不过且慢，然我们用<code>git log</code>再看看现在版本库的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span><br><span class="line"></span><br><span class="line">    add distributed</span><br><span class="line"></span><br><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure><p>最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p><p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 1094a</span><br><span class="line">HEAD is now at 83b0afe append GPL</span><br></pre></td></tr></table></figure><p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p><p>再小心翼翼地看看<code>readme.txt</code>的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><p>果然，我胡汉三又回来了。</p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907584977fc9d4b96c99f4b5f8e448fbd8589d0b2000/0" alt="git-head"></p><p>改为指向<code>add distributed</code>：</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384907594057a873c79f14184b45a1a66b1509f90b7a000/0" alt="git-head-move"></p><p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span><br><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span><br><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span><br></pre></td></tr></table></figure><p>终于舒了口气，从输出可知，<code>append GPL</code>的commit id是<code>1094adb</code>，现在，你又可以乘坐时光机回到未来了。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>现在总结一下：</p><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><h4 id="撤销修改-git-checkout-–-file-可以丢弃工作区的修改："><a href="#撤销修改-git-checkout-–-file-可以丢弃工作区的修改：" class="headerlink" title="撤销修改 git checkout – file 可以丢弃工作区的修改："></a>撤销修改 git checkout – file 可以丢弃工作区的修改：</h4><hr><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在<code>readme.txt</code>中添加了一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure><p>在你准备提交前，一杯咖啡起了作用，你猛然发现了<code>stupid boss</code>可能会让你丢掉这个月的奖金！</p><p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></table></figure><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>现在，看看<code>readme.txt</code>的文件内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br></pre></td></tr></table></figure><p>文件内容果然复原了。</p><p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p><p>现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   readme.txt</span><br></pre></td></tr></table></figure><p><strong>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M    readme.txt</span><br></pre></td></tr></table></figure><p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p><p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">    modified:   readme.txt</span><br></pre></td></tr></table></figure><p>还记得如何丢弃工作区的修改吗？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>又到了小结时间。</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013744142037508cf42e51debf49668810645e02887691000" target="_blank" rel="noopener">版本回退</a>一节，不过前提是没有推送到远程库。</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><hr><p>当你要删除文件的时候，可以采用命令：rm test.txt</p><p>这个时候有两种情况</p><p>第一种情况:的确要把test.txt删掉，</p><p>那么可以执行                    git rm test.txt               </p><p>​                       git commit -m “remove test.txt”                   </p><pre><code>文件被删除，且删除记录上传本地库</code></pre><p>第二种情况:误删文件，想恢复，这时候还没有commit -m “remove test.txt”，</p><p>执行git checkout test.txt将文件恢复。</p><p>如果执行完git commit -m “remove test.txt”后就不能用checkout恢复了，得用git reset –hard HEAD^</p><p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong></p><h4 id="远程库"><a href="#远程库" class="headerlink" title="远程库"></a>远程库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:meijuna/learngit.git</span><br></pre></td></tr></table></figure><p>请千万注意，把上面的<code>meijuna</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (15/15), done.</span><br><span class="line">Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.</span><br><span class="line">Total 20 (delta 5), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (5/5), done.</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;.</span><br></pre></td></tr></table></figure><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>从现在起，只要本地作了提交，就可以通过命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p><h5 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h5><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href="https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/" target="_blank" rel="noopener">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p><h2 id="初次安装git配置用户名和邮箱"><a href="#初次安装git配置用户名和邮箱" class="headerlink" title="初次安装git配置用户名和邮箱"></a>初次安装git配置用户名和邮箱</h2><p>查看邮箱 和shh key是否设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name   //查看用户名&amp;邮箱</span><br><span class="line"></span><br><span class="line">$ git config user.email</span><br><span class="line"></span><br><span class="line">$ ssh -T git@github.com  //ssh</span><br></pre></td></tr></table></figure><p>用户名和邮箱的作用：</p><p>　　用户名和邮箱地址相当于你的身份标识，是本地Git客户端的一个变量，不会随着Git库而改变。</p><p>　　每次commit都会用用户名和邮箱纪录。</p><p>　　github的contributions跟你的邮箱是有关联的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;meijuna&quot;</span><br><span class="line"></span><br><span class="line">$ git config --global user.email &quot;1914623558@qq.com&quot;</span><br><span class="line"></span><br><span class="line">$ git config user.name   //查看用户名&amp;邮箱</span><br><span class="line"></span><br><span class="line">$ git config user.email</span><br><span class="line"></span><br><span class="line">$ git config --global user.name &quot;xxx&quot; //修改用户名邮箱</span><br><span class="line"></span><br><span class="line">$ git config --global user.email &quot;xxx&quot;</span><br></pre></td></tr></table></figure><h2 id="git使用ssh密钥"><a href="#git使用ssh密钥" class="headerlink" title="git使用ssh密钥"></a>git使用ssh密钥</h2><p>git支持https和git两种传输协议，github分享链接时会有两种协议可选：</p><p>1.git使用https协议，每次pull, push都会提示要输入密码</p><p>2.使用git协议，然后使用ssh密钥，这样免去每次都输密码的麻烦</p><hr><p><strong>初次使用git的用户要使用git协议大概需要三个步骤：</strong></p><p><strong>一、生成密钥对</strong></p><p><strong>二、设置远程仓库（本文以github为例）上的公钥</strong></p><p><strong>三、把git的 remote url 修改为git协议</strong>（以上两个步骤初次设置过以后，以后使用都不需要再次设置，此步骤视以后项目的remote url而定，如果以后其他项目的协议为https则需要此步骤）</p><hr><h3 id="一、生成密钥对"><a href="#一、生成密钥对" class="headerlink" title="一、生成密钥对"></a>一、生成密钥对</h3><p>大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥。</p><p>SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。进去看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">$ ls</span><br><span class="line">id_rsa  id_rsa.pub  key_backup/  known_hosts</span><br></pre></td></tr></table></figure><p>看一下有没有id_rsa和id_rsa.pub(或者是id_dsa和id_dsa.pub之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。</p><p>假如没有这些文件，甚至连 .ssh 目录都没有，可以用 ssh-keygen 来创建：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ssh-keygen -t rsa-C "your_email@youremail.com" //你的github绑定的邮箱</span><br></pre></td></tr></table></figure><p>直接按Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码)<br><img src="/2019/06/18/Git-使用/1.png" alt=""></p><p>如果之后你出现了这个界面之后，就说明你的密匙已经成功创建了。现在你就需要去他刚刚显示的存储位置打开它，把其中的内容复制出来。</p><p><strong>到此为止，你本地的密钥对就生成了。</strong></p><h3 id="二、添加公钥到你的远程仓库（github）"><a href="#二、添加公钥到你的远程仓库（github）" class="headerlink" title="二、添加公钥到你的远程仓库（github）"></a>二、添加公钥到你的远程仓库（github）</h3><hr><ol><li><p>查看你的公匙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0X6L1zLL4VHuvGb8aJH3ippTozmReSUzgntvk434aJ/v7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8vR3c8E7CjZN733f5AL8uEYJA+YZevY5UCvEg+umT7PHghKYaJwaCxV7sjYP7Z6V79OMCEAGDNXC26IBMdMgOluQjp6o6j2KAdtRBdCDS/QIU5THQDxJ9lBXjk1fiq9tITo/aXBvjZeD+gH/Apkh/0GbO8VQLiYYmNfqqAHHeXdltORn8N7C9lOa/UW3KM7QdXo6J0GFlBVQeTE/IGqhMS5PMln3 admin@admin-PC</span><br></pre></td></tr></table></figure></li><li><p>登陆你的github帐户。点击你的头像，然后 <code>Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key</code></p></li><li><p>然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，自己随便起个名字。</p></li><li>点击 Add key</li></ol><p><strong>完成以后，验证下这个key是不是正常工作：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果出现 HI XXX 说明设置成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi meijuna! You&apos;ve successfully authenticated, but GitHub does not provide shell access</span><br></pre></td></tr></table></figure></p><h3 id="三、修改git的remote-url"><a href="#三、修改git的remote-url" class="headerlink" title="三、修改git的remote url"></a>三、修改git的remote url</h3><hr><p>使用命令 git remote -v 查看你当前的 remote url (远程仓库)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin https://github.com/someaccount/someproject.git (fetch)</span><br><span class="line">origin https://github.com/someaccount/someproject.git (push)</span><br></pre></td></tr></table></figure><p>如果是以上的结果那么说明此项目是使用https协议进行访问的（如果地址是git开头则表示是git协议）</p><p>你可以登陆你的github，就像本文开头的图例，你在上面可以看到你的ssh协议相应的url</p><p>复制此ssh链接，然后使用命令 git remote set-url 来调整你的url。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:someaccount/someproject.git</span><br></pre></td></tr></table></figure><p>然后你可以再用命令 <code>git remote -v</code>查看一下，url是否已经变成了ssh地址。</p><p>然后你就可以愉快的使用git fetch, git pull , git push，再也不用输入烦人的密码了</p><h2 id="git-操作-1"><a href="#git-操作-1" class="headerlink" title="git 操作"></a>git 操作</h2><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add pb https://github.com/zhousg/letao.git</span><br></pre></td></tr></table></figure><h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">pb      https://github.com/zhousg/letao.git (fetch)</span><br><span class="line">pb      https://github.com/zhousg/letao.git (push)</span><br></pre></td></tr></table></figure><p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git fetch pb</span><br><span class="line">remote: Counting objects: 43, done.</span><br><span class="line">remote: Compressing objects: 100% (36/36), done.</span><br><span class="line">remote: Total 43 (delta 10), reused 31 (delta 5)</span><br><span class="line">Unpacking objects: 100% (43/43), done.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure><p>现在 Paul 的 master 分支可以在本地通过 <code>pb/master</code> 访问到 - 你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching" target="_blank" rel="noopener">Git 分支</a> 中详细介绍什么是分支以及如何使用分支。）</p><h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p><p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 <code>git fetch</code> 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作</p><p>Git 分支</p><h3 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h3><p>当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p><p><strong>现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）</strong></p><p><img src="/2019/06/18/Git-使用/commit-and-tree.png" alt=""></p><p><strong>做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针</strong>。</p><p><img src="https://git-scm.com/book/en/v2/images/commits-and-parents.png" alt="æäº¤å¯¹è±¡åå¶ç¶å¯¹è±¡ã"></p><p>Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 <code>git init</code> 命令默认创建它，并且大多数人都懒得去改动它。</p><h3 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查看分支：git branch</span><br><span class="line"></span><br><span class="line">创建分支：git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">切换分支：git checkout &lt;name&gt;</span><br><span class="line"></span><br><span class="line">创建+切换分支：git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除分支：git branch -d &lt;name&gt;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch testing  //创建testing分支</span><br></pre></td></tr></table></figure><p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 <code>HEAD</code> 想象为当前分支的别名）。 在本例中，你仍然在 <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 <em>创建</em> 一个新分支，并不会自动切换到新分支中去。</p><p><img src="https://git-scm.com/book/en/v2/images/head-to-master.png" alt="HEAD æåå½åæå¨çåæ¯ã"></p><h3 id="指向当前所在的分支"><a href="#指向当前所在的分支" class="headerlink" title="指向当前所在的分支"></a>指向当前所在的分支</h3><p>你可以简单地使用 <code>git log</code> 命令查看各个分支当前所指的对象。 提供这一功能的参数是 <code>--decorate</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --decorate</span><br><span class="line">f30ab (HEAD, master, testing) add feature #32 - ability to add new</span><br><span class="line">34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">98ca9 initial commit of my project</span><br></pre></td></tr></table></figure><p>正如你所见，当前 “master” 和 “testing” 分支均指向校验和以 <code>f30ab</code> 开头的提交对象。</p><h3 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h3><p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout testing</span><br></pre></td></tr></table></figure><p>这样 <code>HEAD</code> 就指向 <code>testing</code> 分支了。</p><p><img src="https://git-scm.com/book/en/v2/images/head-to-testing.png" alt="HEAD æåå½åæå¨çåæ¯ã"></p><h3 id="HEAD-指向当前所在的分支"><a href="#HEAD-指向当前所在的分支" class="headerlink" title="HEAD 指向当前所在的分支"></a>HEAD 指向当前所在的分支</h3><p>那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vim test.rb</span><br><span class="line"><span class="meta">$</span> git commit -a -m 'made other changes'</span><br></pre></td></tr></table></figure><p>现在，这个项目的提交历史已经产生了分叉（参见 <a href="https://git-scm.com/book/zh/v2/ch00/rdivergent_history" target="_blank" rel="noopener">项目分叉历史</a>）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 <code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p><p><img src="https://git-scm.com/book/en/v2/images/advance-testing.png" alt="HEAD åæ¯éçæäº¤æä½èªå¨ååç§&quot;å¨ã"></p><h3 id="HEAD-分支随着提交操作自动向前移动"><a href="#HEAD-分支随着提交操作自动向前移动" class="headerlink" title="HEAD 分支随着提交操作自动向前移动"></a>HEAD 分支随着提交操作自动向前移动</h3><p>如图所示，你的 <code>testing</code> 分支向前移动了，但是 <code>master</code> 分支却没有，它仍然指向运行 <code>git checkout</code> 时所指的对象。 这就有意思了，现在我们切换回 <code>master</code> 分支看看：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/checkout-master.png" alt="æ£åºæ¶ HEAD éä¹ç§&quot;å¨ã"></p><p>这条命令做了两件事。 一是使 HEAD 指回 <code>master</code> 分支，二是将工作目录恢复成 <code>master</code> 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 <code>testing</code>分支所做的修改，以便于向另一个方向进行开发。</p><p>分支切换会改变你工作目录中的文件</p><p>在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。</p><p>我们不妨再稍微做些修改并提交：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> vim test.rb</span><br><span class="line"><span class="meta">$</span> git commit -a -m 'made other changes'</span><br></pre></td></tr></table></figure><p>现在，这个项目的提交历史已经产生了分叉（参见 <a href="https://git-scm.com/book/zh/v2/ch00/rdivergent_history" target="_blank" rel="noopener">项目分叉历史</a>）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 <code>branch</code>、<code>checkout</code> 和 <code>commit</code>。</p><p><img src="https://git-scm.com/book/en/v2/images/advance-master.png" alt="é¡¹ç®åååå²ã"></p><h3 id="项目分叉历史"><a href="#项目分叉历史" class="headerlink" title="项目分叉历史"></a>项目分叉历史</h3><p>可以简单地使用 <code>git log</code> 命令查看分叉历史。 运行 <code>git log --oneline --decorate --graph --all</code> ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git log --oneline --decorate --graph --all</span><br><span class="line">* c2b9e (HEAD, master) made other changes</span><br><span class="line">| * 87ab2 (testing) made a change</span><br><span class="line">|/</span><br><span class="line">* f30ab add feature #32 - ability to add new formats to the</span><br><span class="line">* 34ac2 fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">* 98ca9 initial commit of my project</span><br></pre></td></tr></table></figure><h2 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h2><p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：</p><ol><li>开发某个网站。</li><li>为实现某个新的需求，创建一个分支。</li><li>在这个分支上开展工作。</li></ol><p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：</p><ol><li>切换到你的线上分支（production branch）。</li><li>为这个紧急任务新建一个分支，并在其中修复它。</li><li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li><li>切换回你最初工作的分支上，继续工作。</li></ol><h3 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h3><p>首先，我们假设你正在你的项目上工作，并且已经有一些提交。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-1.png" alt="ä¸ä¸ªç®åçæäº¤åå²ã"></p><p>一个简单提交历史</p><p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 <code>-b</code> 参数的 <code>git checkout</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout -b iss53</span><br><span class="line">Switched to a new branch "iss53"</span><br></pre></td></tr></table></figure><p>它是下面两条命令的简写：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch iss53</span><br><span class="line"><span class="meta">$</span> git checkout iss53</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-2.png" alt="åå&quot;ºä¸ä¸ªæ°åæ¯æéã"></p><h3 id="创建一个新分支指针"><a href="#创建一个新分支指针" class="headerlink" title="创建一个新分支指针"></a>创建一个新分支指针</h3><p>你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，<code>iss53</code> 分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的 <code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-3.png" alt="iss53 åæ¯éçå·¥ä½çè¿å±ååæ¨è¿ã"></p><p>现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 <code>iss53</code> 的修改混在一起，你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 <code>master</code> 分支。</p><p>但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit amending）），我们会在 <a href="https://git-scm.com/book/zh/v2/ch00/r_git_stashing" target="_blank" rel="noopener">储藏与清理</a> 中看到关于这两个命令的介绍。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 <code>master</code> 分支了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout master</span><br></pre></td></tr></table></figure><p>这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p><p>接下来，你要修复这个紧急问题。 让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout -b hotfix</span><br><span class="line">Switched to a new branch 'hotfix'</span><br><span class="line"><span class="meta">$</span> vim index.html</span><br><span class="line"><span class="meta">$</span> git commit -a -m 'fixed the broken email address'</span><br><span class="line">[hotfix 1fb7853] fixed the broken email address</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://git-scm.com/book/en/v2/images/basic-branching-4.png" alt="åºäº `master` åæ¯çç´§æ¥é®é¢åæ¯ï¼hotfix branchï¼ã"></h3><h3 id="基于-master-分支的紧急问题分支-hotfix-branch"><a href="#基于-master-分支的紧急问题分支-hotfix-branch" class="headerlink" title="基于 master 分支的紧急问题分支 hotfix branch"></a>基于 <code>master</code> 分支的紧急问题分支 <code>hotfix branch</code></h3><p>你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的 <code>master</code> 分支来部署到线上。 你可以使用 <code>git merge</code> 命令来达到上述目的：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout master</span><br><span class="line"><span class="meta">$</span> git merge hotfix</span><br><span class="line">Updating f42c576..3a0874c</span><br><span class="line">Fast-forward</span><br><span class="line"> index.html | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure><p>在合并的时候，你应该注意到了”快进（fast-forward）”这个词。 由于当前 <code>master</code> 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。</p><p>现在，最新的修改已经在 <code>master</code> 分支所指向的提交快照中，你可以着手发布该修复了。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-5.png" alt="`master` è¢&quot;å¿&quot;è¿å° `hotfix`ã"></p><p>关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 <code>hotfix</code>分支，因为你已经不再需要它了 —— <code>master</code> 分支已经指向了同一个位置。 你可以使用带 <code>-d</code> 选项的 <code>git branch</code> 命令来删除分支：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch -d hotfix</span><br><span class="line">Deleted branch hotfix (3a0874c).</span><br></pre></td></tr></table></figure><p>现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout iss53</span><br><span class="line">Switched to branch "iss53"</span><br><span class="line"><span class="meta">$</span> vim index.html</span><br><span class="line"><span class="meta">$</span> git commit -a -m 'finished the new footer [issue 53]'</span><br><span class="line">[iss53 ad82d7a] finished the new footer [issue 53]</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p><img src="https://git-scm.com/book/en/v2/images/basic-branching-6.png" alt="ç&quot;§ç&quot;­å¨ `iss53` åæ¯ä¸çå·¥ä½ã"></p><p>你在 <code>hotfix</code> 分支上所做的工作并没有包含到 <code>iss53</code> 分支中。 如果你需要拉取 <code>hotfix</code> 所做的修改，你可以使用 <code>git merge master</code> 命令将 <code>master</code> 分支合并入 <code>iss53</code> 分支，或者你也可以等到 <code>iss53</code> 分支完成其使命，再将其合并回 <code>master</code> 分支。</p><h3 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h3><p>假设你已经修正了 #53 问题，并且打算将你的工作合并入 <code>master</code> 分支。 为此，你需要合并 <code>iss53</code> 分支到 <code>master</code> 分支，这和之前你合并 <code>hotfix</code> 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 <code>git merge</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout master</span><br><span class="line">Switched to branch 'master'</span><br><span class="line"><span class="meta">$</span> git merge iss53</span><br><span class="line">Merge made by the 'recursive' strategy.</span><br><span class="line">index.html |    1 +</span><br><span class="line">1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>这和你之前合并 <code>hotfix</code> 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，<code>master</code> 分支所在提交并不是 <code>iss53</code> 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（<code>C4</code> 和 <code>C5</code>）以及这两个分支的工作祖先（<code>C2</code>），做一个简单的三方合并。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-merging-1.png" alt="ä¸æ¬¡å¸ååå¹¶ä¸­æç¨å°çä¸ä¸ªå¿&quot;ç§ã"></p><p>​    和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。</p><p><img src="https://git-scm.com/book/en/v2/images/basic-merging-2.png" alt="ä¸ä¸ªåå¹¶æäº¤ã"></p><p>需要指出的是，Git 会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础；这和更加古老的 CVS 系统或者 Subversion （1.5 版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。 Git 的这个优势使其在合并操作上比其他系统要简单很多。</p><p>既然你的修改已经合并进来了，你已经不再需要 <code>iss53</code> 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch -d iss53</span><br></pre></td></tr></table></figure><h3 id="遇到冲突时的分支合并"><a href="#遇到冲突时的分支合并" class="headerlink" title="遇到冲突时的分支合并"></a>遇到冲突时的分支合并</h3><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 <code>hotfix</code> 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git merge iss53</span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict in index.html</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 <code>git status</code> 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run "git commit")</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use "git add &lt;file&gt;..." to mark resolution)</span><br><span class="line"></span><br><span class="line">    both modified:      index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><p>任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span>contact : email.support@github.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">=======</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span></span><br><span class="line"> please contact us at support@github.com</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br></pre></td></tr></table></figure><p>上述的冲突解决方案仅保留了其中一个分支的修改，并且 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> , <code>=======</code> , 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 <code>git add</code> 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p><p>如果你想使用图形化工具来解决冲突，你可以运行 <code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git mergetool</span><br><span class="line"></span><br><span class="line">This message is displayed because 'merge.tool' is not configured.</span><br><span class="line">See 'git mergetool --tool-help' or 'git help config' for more details.</span><br><span class="line">'git mergetool' will now attempt to use one of the following tools:</span><br><span class="line">opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge</span><br><span class="line">Merging:</span><br><span class="line">index.html</span><br><span class="line"></span><br><span class="line">Normal merge conflict for 'index.html':</span><br><span class="line">  &#123;local&#125;: modified file</span><br><span class="line">  &#123;remote&#125;: modified file</span><br><span class="line">Hit return to start merge resolution tool (opendiff):</span><br></pre></td></tr></table></figure><p>等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 <code>git status</code> 来确认所有的合并冲突都已被解决：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git status</span><br><span class="line">On branch master</span><br><span class="line">All conflicts fixed but you are still merging.</span><br><span class="line">  (use "git commit" to conclude merge)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line"></span><br><span class="line">    modified:   index.html</span><br></pre></td></tr></table></figure><p>如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 <code>git commit</code> 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Merge branch 'iss53'</span><br><span class="line"></span><br><span class="line">Conflicts:</span><br><span class="line">    index.html</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> It looks like you may be committing a merge.</span><br><span class="line"><span class="meta">#</span> If this is not correct, please remove the file</span><br><span class="line"><span class="meta">#</span>.git/MERGE_HEAD</span><br><span class="line"><span class="meta">#</span> and try again.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Please enter the commit message for your changes. Lines starting</span><br><span class="line"><span class="meta">#</span> with '#' will be ignored, and an empty message aborts the commit.</span><br><span class="line"><span class="meta">#</span> On branch master</span><br><span class="line"><span class="meta">#</span> All conflicts fixed but you are still merging.</span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span> Changes to be committed:</span><br><span class="line"><span class="meta">#</span>modified:   index.html</span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class="line">Merge made by the &apos;recursive&apos; strategy.</span><br><span class="line"> readme.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><p>合并后，我们用<code>git log</code>看看分支历史：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   e1e9c68 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\  </span><br><span class="line">| * f52c633 (dev) add merge</span><br><span class="line">|/  </span><br><span class="line">*   cf810e4 conflict fixed</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p><p><img src="https://cdn.liaoxuefeng.com/cdn/files/attachments/001384909222841acf964ec9e6a4629a35a7a30588281bb000/0" alt="git-no-ff-mode"></p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。</p><p><code>git branch</code> 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>注意 <code>master</code> 分支前的 <code>*</code> 字符：它代表现在检出的那一个分支（也就是说，当前 <code>HEAD</code> 指针所指向的分支）。 这意味着如果在这时候提交，<code>master</code> 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 <code>git branch -v</code> 命令：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch -v</span><br><span class="line">  iss53   93b412c fix javascript issue</span><br><span class="line">* master  7a98805 Merge branch 'iss53'</span><br><span class="line">  testing 782fd34 add scott to the author list in the readmes</span><br></pre></td></tr></table></figure><p><code>--merged</code> 与 <code>--no-merged</code> 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 <code>git branch --merged</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch --merged</span><br><span class="line">  iss53</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>因为之前已经合并了 <code>iss53</code> 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 <code>*</code> 号的分支通常可以使用 <code>git branch -d</code> 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。</p><p>查看所有包含未合并工作的分支，可以运行 <code>git branch --no-merged</code>：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch --no-merged</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 <code>git branch -d</code> 命令删除它时会失败：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch -d testing</span><br><span class="line">error: The branch 'testing' is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run 'git branch -D testing'.</span><br></pre></td></tr></table></figure><p>如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 <code>-D</code> 选项强制删除它。</p><h4 id="git-stash保留现场"><a href="#git-stash保留现场" class="headerlink" title="git stash保留现场"></a>git stash保留现场</h4><p>git stash </p><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了</p><p>先说几个名词<br>未被追踪的文件:指的是新建的文件或文件夹且还没加入到暂存区(新建的还没有被git add 过得)<br>未加入到暂存区的文件:指的是已经被追踪过，但是没有加入到暂存区(已经执行过git add/commit的但是这次修改后还没有git add)<br>举例:<br>readme.md  已经被git add/git commit过，但是呢 我这次只是修改了，而且没有修改完，不能commit<br>test    新建的文件夹,没有被git add/git commit过<br>有个急事需要处理,这时候我需要切换分支，去处理紧急任务,比如文中的举例去修改bug，<br>正确的步骤:<br>git add test（让git去追踪这个新文件）<br>git stash保留现场<br>如果我不执行这两个命令，那么我在修改BUG完成之后<br>git status，就会发现readme.md 没有添加到暂存区，同时又多了个test文件,但是自己的readme.md没有完成，万万不可以提交，这样导致bug的修改代码也提交不了。所以你需要<br>git stash，这样你在提交修改bug代码的时候 ，就不会看见readme.md 和 test。可以安心提交修改bug的代码。</p><h4 id="Feature分支-没有被合并过的分支，可以通过git-branch-D-lt-name-gt-强行删除"><a href="#Feature分支-没有被合并过的分支，可以通过git-branch-D-lt-name-gt-强行删除" class="headerlink" title="Feature分支 没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除"></a>Feature分支 没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除</h4><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p><p>于是准备开发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature-vulcan</span><br><span class="line">Switched to a new branch &apos;feature-vulcan&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git add vulcan.py</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch feature-vulcan</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   vulcan.py</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add feature vulcan&quot;</span><br><span class="line">[feature-vulcan 287773e] add feature vulcan</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 vulcan.py</span><br></pre></td></tr></table></figure><p>切回<code>dev</code>，准备合并：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p><p><code>git branch -D feature-vulcan</code> 强制删除未合并的分支</p><h4 id="查看远程库的信息，用git-remote"><a href="#查看远程库的信息，用git-remote" class="headerlink" title="查看远程库的信息，用git remote"></a>查看远程库的信息，用<code>git remote</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p><h2 id="分支开发工作流"><a href="#分支开发工作流" class="headerlink" title="分支开发工作流"></a>分支开发工作流</h2><p><img src="http://s3.51cto.com/wyfs02/M02/12/44/wKiom1MA0v-horoSAAS4v41ef_U068.jpg" alt="img"></p><h3 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h3><p>因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。</p><p>许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 <code>master</code> 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 <code>develop</code> 或者 <code>next</code> 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 <code>master</code> 分支了。 这样，在确保这些已完成的特性分支（短期分支，比如之前的 <code>iss53</code> 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。</p><p>事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。</p><p><img src="https://git-scm.com/book/en/v2/images/lr-branches-1.png" alt="æ¸è¿ç¨³å®åæ¯ççº¿æ§å¾ã"></p><p>通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。</p><p><img src="https://git-scm.com/book/en/v2/images/lr-branches-2.png" alt="æ¸è¿ç¨³å®åæ¯çå·¥ä½æµï¼âsiloâï¼è§å¾ã"></p><p>你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 <code>proposed</code>（建议） 或 <code>pu: proposed updates</code>（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 <code>next</code> 或者 <code>master</code> 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。</p><h3 id="特性分支"><a href="#特性分支" class="headerlink" title="特性分支"></a>特性分支</h3><p>你已经在上一节中你创建的 <code>iss53</code> 和 <code>hotfix</code> 特性分支中看到过这种用法。 你在上一节用到的特性分支（<code>iss53</code> 和 <code>hotfix</code> 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。</p><p>考虑这样一个例子，你在 <code>master</code> 分支上工作到 <code>C1</code>，这时为了解决一个问题而新建 <code>iss91</code> 分支，在 <code>iss91</code>分支上工作到 <code>C4</code>，然而对于那个问题你又有了新的想法，于是你再新建一个 <code>iss91v2</code> 分支试图用另一种方法解决那个问题，接着你回到 <code>master</code> 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 <code>C10</code>的时候新建一个 <code>dumbidea</code> 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：</p><p><img src="https://git-scm.com/book/en/v2/images/topic-branches-1.png" alt="æ¥æå¤ä¸ªç¹æ§åæ¯çæäº¤åå²ã"></p><p>现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 <code>iss91v2</code> 分支中方案；另外，你将 <code>dumbidea</code> 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 <code>iss91</code> 分支（即丢弃 <code>C5</code> 和 <code>C6</code> 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：</p><p><img src="https://git-scm.com/book/en/v2/images/topic-branches-2.png" alt="åå¹¶äº `dumbidea` å `iss91v2` åæ¯ä¹åçæäº¤åå²ã"></p><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><ul><li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签。</li></ul><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure><p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure><p>可以用命令<code>git tag</code>查看所有标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline --abbrev-commit</span><br><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 add merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line">5dc6824 &amp; simple</span><br><span class="line">14096d0 AND simple</span><br><span class="line">b17d20e branch test</span><br><span class="line">d46f35e remove test.txt</span><br><span class="line">b84166e add test.txt</span><br><span class="line">519219b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line">1094adb append GPL</span><br><span class="line">e475afc add distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure><p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v0.9 f52c633</span><br></pre></td></tr></table></figure><p>再用命令<code>git tag</code>查看标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure><p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.1</span><br><span class="line">tag v0.1</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 22:48:43 2018 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line"></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p> 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p><h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><p>如果标签打错了，也可以删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br><span class="line">Deleted tag &apos;v0.1&apos; (was f15b0dd)</span><br></pre></td></tr></table></figure><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag &apos;v0.9&apos; (was f52c633)</span><br></pre></td></tr></table></figure><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/v0.9</span><br><span class="line">To github.com:michaelliao/learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;git-操作&quot;&gt;&lt;a href=&quot;#git-操作&quot; class=&quot;headerlink&quot; title=&quot;git 操作&quot;&gt;&lt;/a&gt;git 操作&lt;/h2&gt;&lt;p&gt;&lt;code&gt;git checkout -- file&lt;/code&gt;可以丢弃工作区的修改&lt;/p&gt;
&lt;p&gt;命令&lt;
      
    
    </summary>
    
      <category term="前端" scheme="http://meijuna.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="git" scheme="http://meijuna.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>开发工具</title>
    <link href="http://meijuna.github.io/2019/06/18/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    <id>http://meijuna.github.io/2019/06/18/开发工具/</id>
    <published>2019-06-18T11:17:05.236Z</published>
    <updated>2019-06-26T13:57:50.312Z</updated>
    
    <content type="html"><![CDATA[<h3 id="VsCode"><a href="#VsCode" class="headerlink" title="VsCode"></a>VsCode</h3><h2 id="subline-Text3"><a href="#subline-Text3" class="headerlink" title="subline Text3"></a>subline Text3</h2><h3 id="1-插件下载安装方法"><a href="#1-插件下载安装方法" class="headerlink" title="1.插件下载安装方法"></a>1.插件下载安装方法</h3><p>快捷键<code>ctrl + shift + p</code>, 打开sublime命令工具，输入 <code>Install Package</code></p><h3 id="2-插件"><a href="#2-插件" class="headerlink" title="2.插件"></a>2.插件</h3><h5 id="1-格式化代码：html-css-js-Prettify"><a href="#1-格式化代码：html-css-js-Prettify" class="headerlink" title="1.格式化代码：html/css/js Prettify"></a>1.格式化代码：html/css/js Prettify</h5><p> 格式化代码快捷键   <code>Ctrl + Shift + H</code></p><h5 id="2-vue语法高亮：-vue-syntax-highlight"><a href="#2-vue语法高亮：-vue-syntax-highlight" class="headerlink" title="2.vue语法高亮： vue-syntax-highlight"></a>2.vue语法高亮： <strong>vue-syntax-highlight</strong></h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;VsCode&quot;&gt;&lt;a href=&quot;#VsCode&quot; class=&quot;headerlink&quot; title=&quot;VsCode&quot;&gt;&lt;/a&gt;VsCode&lt;/h3&gt;&lt;h2 id=&quot;subline-Text3&quot;&gt;&lt;a href=&quot;#subline-Text3&quot; class=&quot;he
      
    
    </summary>
    
      <category term="开发工具" scheme="http://meijuna.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://meijuna.github.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>npm 包管理工具</title>
    <link href="http://meijuna.github.io/2019/06/18/npm%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://meijuna.github.io/2019/06/18/npm包管理工具/</id>
    <published>2019-06-18T11:17:05.214Z</published>
    <updated>2019-06-26T13:59:49.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="npm-包管理工具"><a href="#npm-包管理工具" class="headerlink" title="npm 包管理工具"></a>npm 包管理工具</h1><h2 id="1-什么是-npm"><a href="#1-什么是-npm" class="headerlink" title="1. 什么是 npm ?"></a>1. 什么是 npm ?</h2><ul><li>npm是 Node 的包管理工具 ，是全球最大的开源库生态系统</li><li>官网 <a href="https://www.npmjs.com/" target="_blank" rel="noopener">https://www.npmjs.com/</a></li></ul><h2 id="2-常见命令"><a href="#2-常见命令" class="headerlink" title="2. 常见命令"></a>2. 常见命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">初始化项目</span><br><span class="line">    $ npm init</span><br><span class="line">    $ npm init --yes 默认配置</span><br><span class="line"> </span><br><span class="line">下载命令:</span><br><span class="line">    npm init 初始化包管理文件</span><br><span class="line">    npm install 包名  下载</span><br><span class="line">    npm install 包名 -g 下载到全局</span><br><span class="line">    npm install 包名 --save-dev--    包管理文件生成开发依赖 devDependencies:&#123;xxx:xxx&#125;</span><br><span class="line">    npm install 包名 -d    --save-dev--的简写</span><br><span class="line">    npm config ls 查看npm的默认配置</span><br><span class="line">    </span><br><span class="line">    //开发环境使用 devDepencies</span><br><span class="line">    -D  === --save--dev  </span><br><span class="line">    // 生产环境使用  </span><br><span class="line">    -S  ==  --save</span><br><span class="line">   </span><br><span class="line">卸载命令:</span><br><span class="line">    npm uninstall 包名卸载本地包</span><br><span class="line">    npm unpublish 包名@版本号  卸载发布后的远程包 发布1小时内有效</span><br></pre></td></tr></table></figure><h2 id="3-上传包"><a href="#3-上传包" class="headerlink" title="3. 上传包"></a>3. 上传包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">上传包:</span><br><span class="line">    1) 登入npm官方网站 www.npmjs.com</span><br><span class="line">    2) 注册 设置好邮箱</span><br><span class="line">    3) 在dos命令窗口登入npm adduser (注意密码输入不显示)</span><br><span class="line">    4) 发布包 npm publish</span><br><span class="line">    5) package.json中必备两个字段 name(包名) version(版本号)</span><br><span class="line">    ps:如果发布的包名与npm官网重复会导致发布失败</span><br></pre></td></tr></table></figure><h2 id="2-设置淘宝镜像"><a href="#2-设置淘宝镜像" class="headerlink" title="2.  设置淘宝镜像"></a>2.  设置淘宝镜像</h2>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//1. 安装 cnpm 设置淘宝镜像</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">//2. 下载 nrm 用于切换源</span><br><span class="line">  cnpm install nrm -g </span><br><span class="line">  nrm ls 查看当前源</span><br><span class="line">  nrm use xx 切换源</span><br></pre></td></tr></table></figure><h2 id="3-npm脚本"><a href="#3-npm脚本" class="headerlink" title="3. npm脚本"></a>3. npm脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">npm run build = node build.js </span><br><span class="line">为什么使用npm 脚本： 命令会记录在build</span><br><span class="line">1. 集中存放当前项目的所有脚本命令</span><br><span class="line">2. 外接口，用户不同项目的脚本命令，只要功能相同，就可以是同样的</span><br><span class="line">3. 提供很多辅助功能（多个脚本执行(&amp;|$$) 通配符 *.js </span><br><span class="line"></span><br><span class="line">以下npm 脚本可以简写</span><br><span class="line">    npm start </span><br><span class="line">    np stop</span><br><span class="line">    npm test</span><br><span class="line">    npm restart </span><br><span class="line">    </span><br><span class="line">默认提供脚本：</span><br><span class="line">1. &quot;start&quot;: &quot;node server.js&quot;</span><br><span class="line">2. &quot;install&quot;: &quot;node-gyp rebuild&quot;</span><br><span class="line">3. &quot;build&quot;: &quot;node build.js&quot;</span><br><span class="line"></span><br><span class="line">钩子： pre和pst两个钩子</span><br></pre></td></tr></table></figure><h2 id="4-nvm-node版本管理"><a href="#4-nvm-node版本管理" class="headerlink" title="4.  nvm node版本管理"></a>4.  nvm node版本管理</h2><p>下载安装 nvm  <a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">nvm-setup.zip</a> </p><ul><li><p>nvm 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nvm list #查看本地所有node版本</span><br><span class="line"></span><br><span class="line">nvm install 4.2.2 #安装 4.2.2 版本</span><br><span class="line"></span><br><span class="line">nvm use 4.2.2 #切换至 4.2.2 版本</span><br><span class="line"></span><br><span class="line">nvm uninstall 4.2.2 #卸载4.2.2 版本</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;npm-包管理工具&quot;&gt;&lt;a href=&quot;#npm-包管理工具&quot; class=&quot;headerlink&quot; title=&quot;npm 包管理工具&quot;&gt;&lt;/a&gt;npm 包管理工具&lt;/h1&gt;&lt;h2 id=&quot;1-什么是-npm&quot;&gt;&lt;a href=&quot;#1-什么是-npm&quot; class
      
    
    </summary>
    
      <category term="Node" scheme="http://meijuna.github.io/categories/Node/"/>
    
    
      <category term="npm" scheme="http://meijuna.github.io/tags/npm/"/>
    
      <category term="Node" scheme="http://meijuna.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Node 基础语法</title>
    <link href="http://meijuna.github.io/2019/06/18/Node%E5%9F%BA%E7%A1%80%E8%A6%81%E7%82%B9/"/>
    <id>http://meijuna.github.io/2019/06/18/Node基础要点/</id>
    <published>2019-06-18T11:17:05.191Z</published>
    <updated>2019-06-26T14:00:20.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-基础语法"><a href="#Node-基础语法" class="headerlink" title="Node 基础语法"></a>Node 基础语法</h1><ul><li><p>浏览器Javascript 不能做什么？</p><ol><li>访问数据库</li><li>不能对文件进行操作</li><li>不能对系统进行操作</li></ol><p>原因是为了安全，和浏览器的运行机制有关</p></li><li><p>在开发人员能力相同的情况下编程语言的能力取决于什么？</p><p>取决于平台，</p><ul><li>cordova hbuilder    平台  platform</li><li>java   java虚拟机        （运行平台）</li><li>php    php虚拟机</li><li>+c#     .net framework   mono</li><li>+js     解析内核  chrome v8 </li></ul></li></ul><h2 id="1-node-特点"><a href="#1-node-特点" class="headerlink" title="1.  node 特点"></a>1.  node 特点</h2><h3 id="什么是node"><a href="#什么是node" class="headerlink" title="什么是node ?"></a>什么是node ?</h3><ul><li><p>Node.js 是一个运行在Chrome V8 引擎的JavaScript 的一个运行环境 </p></li><li><p>Node.js使用了一个事件驱动、非阻塞式I/O的模型,使其轻量又高效</p><ul><li><p>事件驱动： 任务执行，发布者，订阅者，事件驱动 （  on  emit  ）</p></li><li><p>非阻塞： 执行某一个任务的同时也可以执行其他任务</p></li><li><p>阻塞： 执行某一个任务，这个任务如果没有执行完成，其他任务必须等待</p><ul><li>同步</li><li>异步</li></ul></li><li><p>I/O: 输入/输出（ 数据库，文件系统操作等操作  ）</p><ul><li>非阻塞I/O模型： 当我们使用Node.js来实现数据库操作、文件系统等操作时，要进行的异步操作，异步操作的核心传统实现方式就是回调函数</li></ul></li></ul></li></ul><h2 id="2-服务器："><a href="#2-服务器：" class="headerlink" title="2. 服务器："></a>2. 服务器：</h2><ul><li><p>定义： 可以运行在服务端的一个网站（站点）</p></li><li><p>种类：</p><ol><li><p>web服务器（ 静态服务器 ），可以运行在浏览器中的服务器</p></li><li><p>api 服务器（ 后端接口 )，后端语言暴露一个数据接口，用于前端的请求</p></li></ol></li></ul><h4 id="1-http-创建web服务器："><a href="#1-http-创建web服务器：" class="headerlink" title="1. http 创建web服务器："></a>1. http 创建web服务器：</h4><ul><li><p>http 模块</p><ul><li>createServer( callback(request, response, [next]){ })</li><li>listen(port, host, callback)  //监听服务器 （ 反馈服务器状态）</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">// 1. 引入http模块(对象)</span></span><br><span class="line"> <span class="keyword">const</span> http = reqiure(<span class="string">'http'</span>);</span><br><span class="line"> <span class="comment">//2. 通过httpP模块上的 createServer 这个api 创建一个函数</span></span><br><span class="line"> <span class="comment">//3. 创建服务器端口和域名</span></span><br><span class="line"> <span class="keyword">const</span> port = <span class="number">8888</span>;</span><br><span class="line"> <span class="keyword">const</span> host = <span class="string">'localhost'</span>;<span class="comment">//127.0.0.1</span></span><br><span class="line"> <span class="keyword">const</span> server = http.createServer( <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">     response.writeHead(<span class="number">200</span>, &#123;   <span class="comment">//设置响应头</span></span><br><span class="line">         <span class="string">'Content-Type'</span>: <span class="string">'text/html;charset=UTFf8'</span></span><br><span class="line"> &#125;)</span><br><span class="line"> response.write(<span class="string">'返回给客户端的数据'</span>);<span class="comment">//向前台发送信息</span></span><br><span class="line">     response.end(); <span class="comment">//发送已经结束</span></span><br><span class="line"> &#125;).listen( port, host, () =&gt; &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">`The server running at:http://<span class="subst">$&#123; host &#125;</span> : <span class="subst">$&#123; port &#125;</span> `</span>)</span><br><span class="line"> &#125;);</span><br><span class="line"> </span><br><span class="line">ps:因为浏览器在请求时会默认发送favicon.ico图标请求,如需阻止在http回调函数里环境里判断阻止</span><br><span class="line">代码示例:</span><br><span class="line">    <span class="keyword">if</span>(request.url.indexOf(<span class="string">"favicon.ico"</span>) === <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">ps:关于设置响应头解析类型的设置</span><br><span class="line">    <span class="string">"Content-type"</span>:<span class="string">"text/html;charset=utf-8"</span>解析HTML标签以及属性</span><br><span class="line">                    <span class="string">"text/plain"</span>纯文本</span><br><span class="line">                    <span class="string">"text/css"</span>解析css</span><br><span class="line">                    <span class="string">"text/javascript"</span>解析js</span><br><span class="line">                    <span class="string">"text/png"</span>解析图片</span><br><span class="line">                    <span class="string">"text/json"</span>json数据</span><br><span class="line">                    <span class="string">"......"</span></span><br></pre></td></tr></table></figure><h4 id="2-express-来创建api服务器"><a href="#2-express-来创建api服务器" class="headerlink" title="2. express 来创建api服务器"></a>2. express 来创建api服务器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(路由路径，(路由回调函数(路由中间件),next) =&gt; &#123; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express() <span class="comment">//创建了一个app对象</span></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res, next)  =&gt; &#123;&#125;)</span><br><span class="line">app.listen(port, hostname, () =&gt; &#123;  <span class="comment">//创建一个服务器</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`The server is runinng at:http://<span class="subst">$&#123; hostname&#125;</span>:<span class="subst">$&#123; port &#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-Node-中文乱码问题解决："><a href="#3-Node-中文乱码问题解决：" class="headerlink" title="3. Node 中文乱码问题解决："></a>3. Node 中文乱码问题解决：</h2><h4 id="1-设置请求头"><a href="#1-设置请求头" class="headerlink" title="1. 设置请求头"></a>1. 设置请求头</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line"> <span class="string">'Content-Type'</span>: <span class="string">'text/html;charset=UTF8'</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><h4 id="2-发送-response-write"><a href="#2-发送-response-write" class="headerlink" title="2. 发送 response.write()"></a>2. 发送 response.write()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.write(<span class="string">'&lt;meta charset=UTF-8&gt;'</span>)</span><br></pre></td></tr></table></figure><h4 id="3-toString"><a href="#3-toString" class="headerlink" title="3. toString()"></a>3. toString()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对二进制有效：将二进制 -》 toSrgin()</span><br></pre></td></tr></table></figure><h2 id="4-Node-实时监听-自动刷新"><a href="#4-Node-实时监听-自动刷新" class="headerlink" title="4. Node 实时监听(自动刷新)"></a>4. Node 实时监听(自动刷新)</h2><p>借助第三方工具：</p><ul><li>nodemon [ 推荐 ]</li><li>supervisor</li></ul><h2 id="5-commonJS规范"><a href="#5-commonJS规范" class="headerlink" title="5. commonJS规范"></a>5. commonJS规范</h2><ul><li>CommonJs 规范的提出，主要是为了弥补 javascript 没有标准的缺陷，希望javascript 能在任何地方运行，能向java和Python具有开发大型应用的基础能力，可不是停留在脚本程序的阶段。</li><li>commonJS规范思想 是单独的文件就是一个模块,每一个模块都是一个独立的作用域</li><li>每个文件对外接口都是module.exports对象</li></ul><h3 id="1-CommonJs的模块规范"><a href="#1-CommonJs的模块规范" class="headerlink" title="1. CommonJs的模块规范"></a>1. CommonJs的模块规范</h3><p>CommonJS对模块的定义主要分为：</p><h4 id="1-模块定义"><a href="#1-模块定义" class="headerlink" title="1. 模块定义"></a>1. 模块定义</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 模块定义</span></span><br><span class="line"><span class="keyword">const</span> student = &#123;   <span class="comment">//可以是对象(可以传多个)、函数、字符串</span></span><br><span class="line">    name: <span class="string">'meijuna'</span>,</span><br><span class="line">    jineng () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'I cn fly'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-模块导出"><a href="#2-模块导出" class="headerlink" title="2. 模块导出"></a>2. 模块导出</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 模块导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = student; <span class="comment">//安全性不高，只能到处多个</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;  <span class="comment">//更安全，批量导出</span></span><br><span class="line">student,</span><br><span class="line">fn</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-模块引用"><a href="#3-模块引用" class="headerlink" title="3. 模块引用"></a>3. 模块引用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 模块引用</span></span><br><span class="line"><span class="keyword">const</span> student = <span class="built_in">require</span>(<span class="string">'./xx.js'</span>); <span class="comment">// or</span></span><br><span class="line"><span class="keyword">const</span> &#123; student, fn &#125; = requie(<span class="string">'./xx.js); //可以按需引用</span></span><br></pre></td></tr></table></figure><h3 id="2-模块标识符主要分类："><a href="#2-模块标识符主要分类：" class="headerlink" title="2. 模块标识符主要分类："></a>2. 模块标识符主要分类：</h3><h4 id="1-内置模块-（http、fs"><a href="#1-内置模块-（http、fs" class="headerlink" title="1. 内置模块 （http、fs)"></a>1. 内置模块 （http、fs)</h4><h6 id="1）url-模块：处理-url"><a href="#1）url-模块：处理-url" class="headerlink" title="1）url 模块：处理 url"></a>1）url 模块：处理 url</h6><p>URL模块提供了三种处理path的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 将path字符类型转成对象</span><br><span class="line">left url = <span class="string">"http://user:pass@host.com:8080/p/a/t/h?query=string#hash"</span>;</span><br><span class="line">url.parse(url,[可选布尔值],[可选项布尔值]);</span><br><span class="line">    &#123;</span><br><span class="line">        单词解释解析属性属性解释</span><br><span class="line">        协议protocol:<span class="string">"http:"</span>,协议</span><br><span class="line">        斜线slashes:<span class="literal">true</span>,是否有<span class="comment">//</span></span><br><span class="line">        认证auth:<span class="string">"user:pass"</span>,用户名与密码</span><br><span class="line">        主机host:<span class="string">"host.com:8080"</span>,主机</span><br><span class="line">        接口port:<span class="string">"8080"</span>,端口</span><br><span class="line">        主机名hostname:<span class="string">"host.com"</span>,域名</span><br><span class="line">        搞砸hash:<span class="string">"#hash"</span>, 片段标识符,指向html页面某个dom元素的id</span><br><span class="line">        搜索search:<span class="string">"?query=string"</span>,? + 查询字符串</span><br><span class="line">        查询query:<span class="string">"query=string"</span>,查询字符</span><br><span class="line">        路径名pathname:<span class="string">"/p/a/t/h"</span>,端口号和?之间的 路径那部分</span><br><span class="line">        路径path:<span class="string">"/p/a/t/h?query=string"</span>,pathname + search </span><br><span class="line">        水平基准href:全路径url 原始路径</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="number">2</span>) 将对象转成url字符串</span><br><span class="line">url.format(obj)</span><br><span class="line">ps:参考结合parse方法;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) 替换或者替换(未验证)</span><br><span class="line">url.resolve(<span class="keyword">from</span>,to)</span><br><span class="line"><span class="keyword">from</span> 源地址</span><br><span class="line">to需要添加或替换的标签</span><br><span class="line">ps:form源地址末尾有/就是添加  没有就是替换 具体待验证</span><br></pre></td></tr></table></figure><h6 id="2-fs-模块"><a href="#2-fs-模块" class="headerlink" title="2) fs 模块"></a>2) fs 模块</h6><p>fs 模块是专门处理操作磁盘文件,特点每个方法都有同步和异步两种 (需注意:同步以sync结尾)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">读取文件:</span><br><span class="line">fs.readFile(<span class="string">"文件路径"</span>,&#123;opt&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">&#123;opt&#125;:可选项</span><br><span class="line">encoding:<span class="string">"utf-8"</span>以utf<span class="number">-8</span>国际编码读取文件内容</span><br><span class="line">flag:<span class="string">"r+"</span>read的简称,只读取文件,不存在即报错</span><br><span class="line">flag:<span class="string">"w+"</span>write的简称,读写文件,不存在则自动创建</span><br><span class="line"></span><br><span class="line">err:errorObject报错机制 一般用<span class="keyword">if</span>判断用<span class="keyword">throw</span>抛出错误</span><br><span class="line">列:</span><br><span class="line"><span class="keyword">if</span>(err)&#123;</span><br><span class="line"><span class="keyword">throw</span> err</span><br><span class="line">&#125;</span><br><span class="line">ps:<span class="built_in">console</span>.error()抛出错误,不影响程序执行</span><br><span class="line"></span><br><span class="line">data:成功读取的数据,是以buffer数据二进制存储格式存在</span><br><span class="line">ps:data.toString()可以转成UTF<span class="number">-8</span>格式,等价于可选项中的encoding:<span class="string">"utf-8"</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">写入文件:</span><br><span class="line">fs.writeFile(<span class="string">"写入路径"</span>,<span class="string">"内容数据"</span>,&#123;opt&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line">追加内容:</span><br><span class="line">fs.appendFile(<span class="string">"追加文件路径"</span>,<span class="string">"内容数据"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line">读取文件夹:</span><br><span class="line">fs.readdir(<span class="string">"文件夹路径"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,paths</span>)</span>&#123;</span><br><span class="line">ps:readdir是directory的缩写</span><br><span class="line">paths:成功读取文件夹 用数组存储文件内容</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">创建文件夹:</span><br><span class="line">fs.mkdir(<span class="string">"文件夹路径,同时也是文件夹名称"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><h6 id="3）path-模块"><a href="#3）path-模块" class="headerlink" title="3）path 模块"></a>3）path 模块</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">拼接路径:</span><br><span class="line">join(xx,xx,xxx,.）使用平台特定的分隔符,将所有给定的段连接在一起</span><br><span class="line">ps:常用到的路径</span><br><span class="line">__dirname当前执行文件所在的绝对路径</span><br></pre></td></tr></table></figure><h6 id="4）querystring-模块"><a href="#4）querystring-模块" class="headerlink" title="4）querystring 模块"></a>4）querystring 模块</h6><p>querystring模块一般是对 http 请求的 URL 所带的数据进行解析处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 格式数据格式化为字符串:stringify </span><br><span class="line">    <span class="keyword">let</span> objData = &#123;</span><br><span class="line">        name:<span class="string">"skye"</span>,</span><br><span class="line">        url:<span class="string">"http://skyelovedj.com"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> querystring = <span class="built_in">require</span>(<span class="string">"querystring"</span>);</span><br><span class="line">    querystring.stringify(objData,<span class="string">"分隔符"</span>,<span class="string">"分配符"</span>)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>) 将参数字符格式为对象:</span><br><span class="line">    <span class="keyword">let</span> strData = <span class="string">"name:skye&amp;age=18"</span></span><br><span class="line">    <span class="keyword">let</span> querystring = <span class="built_in">require</span>(<span class="string">"querystring"</span>);</span><br><span class="line">    querystring.parse(strData,<span class="string">"分隔符"</span>,<span class="string">"分配符"</span>)</span><br><span class="line">    ps:分隔符和分配符是可选项</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>) 编码:</span><br><span class="line">    querystring.escape(<span class="string">"data"</span>)只对符号与中文编码</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>) 解码:</span><br><span class="line">    querystring.Unescape(<span class="string">"data"</span>)只对符号与中文解码</span><br></pre></td></tr></table></figure><h6 id="5-zlib"><a href="#5-zlib" class="headerlink" title="5) zlib"></a>5) zlib</h6><p>制作压缩包的模块</p><p>流</p><p> *     可读的流： 可以通过文件系统读取的流 （ 数据流 ）</p><p> *     可写的流： 可以通过文件系统写入的流</p><p> *   管道流 ： 连通两个文件的通道 pipe</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>( <span class="string">'fs'</span> );</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>( <span class="string">'zlib'</span>); <span class="comment">//制作压缩包的模块</span></span><br><span class="line"><span class="comment">//创建可读的流</span></span><br><span class="line"><span class="keyword">const</span> readStream = fs.createReadStream(<span class="string">'./a.txt'</span> );</span><br><span class="line"><span class="comment">//创建空压缩包</span></span><br><span class="line"><span class="keyword">const</span> gzib = zlib.createGzip();</span><br><span class="line"><span class="comment">//创建可写的流</span></span><br><span class="line"><span class="keyword">const</span> writeStream  = fs.createWriteStream(<span class="string">'./b.text.gz'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建流程</span></span><br><span class="line">readStream</span><br><span class="line">  .pipe( gzib )</span><br><span class="line">  .pipe( writeStream );</span><br></pre></td></tr></table></figure><h4 id="2-第三方模块"><a href="#2-第三方模块" class="headerlink" title="2. 第三方模块"></a>2. 第三方模块</h4><h4 id="3-自定义模块"><a href="#3-自定义模块" class="headerlink" title="3. 自定义模块"></a>3. 自定义模块</h4><h2 id="6-发送数据请求："><a href="#6-发送数据请求：" class="headerlink" title="6. 发送数据请求："></a>6. 发送数据请求：</h2><ol><li>http.request</li><li>request(封装 http-request 的第三方包)</li><li>http.get(options, (res) =&gt;{ })</li></ol><h2 id="7-前端模块化"><a href="#7-前端模块化" class="headerlink" title="7.   前端模块化"></a>7.   前端模块化</h2><p>为什么前端要使用模块化：</p><p>模块化：具有特定功能的一个对象(广义理解)</p><p>模块定义的流程：</p><pre><code>1. 定义模块2.  导出模块3.  应用模块</code></pre><p>好处： </p><pre><code>1. 可以存储多个独立的功能块2.  复用性高</code></pre><p>种类：</p><pre><code>1.  ADM （ require.js )</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(&#123;</span><br><span class="line">     a:<span class="number">1</span>,</span><br><span class="line">     b:<span class="number">2</span></span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="built_in">require</span>([./a.js], <span class="function"><span class="keyword">function</span>(<span class="params"> moduleA </span>) </span>&#123;</span><br><span class="line"> <span class="comment">//moduleA指的是</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li>CMD ( sea.js )</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module </span>)</span>&#123;</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="built_in">require</span>(<span class="string">'./b.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> moduleB </span>)</span>&#123;</span><br><span class="line">     <span class="comment">//moduleB就是b模块中导出的内容</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>Common.js （ require.js ）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node 使用了 Common.js 的规范</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*目录结构： name.js index.js */</span></span><br><span class="line"><span class="comment">//模块定义 name.js</span></span><br><span class="line"><span class="keyword">const</span> nameObj = &#123;</span><br><span class="line">    name: <span class="string">'MeiJuna'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模块导出</span></span><br><span class="line"><span class="built_in">module</span>.exports = nameObj;</span><br><span class="line"><span class="comment">//模块引用</span></span><br><span class="line"><span class="keyword">const</span> nameObj = <span class="built_in">require</span>(<span class="string">'./nameObj)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Node中Common.规范使用的三种类型：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> 1. 内置模块 (指的是挂载在Node全局对象身上的 api )</span></span><br><span class="line"><span class="string"> 2. 自定义模块</span></span><br><span class="line"><span class="string"> 3. 第三方模块</span></span><br></pre></td></tr></table></figure><h2 id="7-跨域问题"><a href="#7-跨域问题" class="headerlink" title="7. 跨域问题"></a>7. 跨域问题</h2><h4 id="前端跨域"><a href="#前端跨域" class="headerlink" title="前端跨域"></a>前端跨域</h4><h5 id="1-jsonp"><a href="#1-jsonp" class="headerlink" title="1. jsonp"></a>1. jsonp</h5><h5 id="2-反向代理"><a href="#2-反向代理" class="headerlink" title="2. 反向代理"></a>2. 反向代理</h5><p>（前端创建一个虚拟后端服务器，后台服务器帮助我们跨域）</p><h4 id="后端跨域"><a href="#后端跨域" class="headerlink" title="后端跨域"></a>后端跨域</h4><h5 id="1-设置响应头"><a href="#1-设置响应头" class="headerlink" title="1. 设置响应头"></a>1. 设置响应头</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(&apos;Access-Control-Allow-Origin&apos;, req.headers.origin);</span><br><span class="line">// req.headers.origin = http://127.0.0.1:5500/</span><br></pre></td></tr></table></figure><h5 id="2-使用第三方中间件-cors"><a href="#2-使用第三方中间件-cors" class="headerlink" title="2. 使用第三方中间件 (cors)"></a>2. 使用第三方中间件 (cors)</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.use( cors(&#123;</span><br><span class="line"> <span class="string">"origin"</span>: <span class="string">"*"</span>,</span><br><span class="line"> <span class="string">"methods"</span>: <span class="string">"GET,HEAD,PUT,PATCH,POST,DELETE"</span>,</span><br><span class="line"> <span class="string">"preflightContinue"</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="string">"optionsSuccessStatus"</span>: <span class="number">200</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><ul><li>中间件: 就是具有一定功能的函数</li></ul><h2 id="8-前端的异步流程"><a href="#8-前端的异步流程" class="headerlink" title="8. 前端的异步流程"></a>8. 前端的异步流程</h2><p>异步流程的任务是放在异步队列中的，</p><ol><li><p>传统的原始异步</p><ul><li>异步函数</li><li>事件</li></ul></li><li><p>使用异步流程工具 （ 别人封装好的东西 )</p><p>es6 Promise 对象  </p><p>all :依次执行完再执行</p><p>race: 谁快谁执行</p><p>es6 generator 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">在function 关键字后加一个 * </span><br><span class="line"> * 通过 yield关键字定义任务</span><br><span class="line"> * fn().next() 来执行任务</span><br><span class="line"> 结果返回一个对象 &#123;value: &apos;任务结果&apos;, done: false &#125;</span><br><span class="line">   value表示 yield关键字有任务执行的结果</span><br><span class="line">   done 表示当前定义的所有的任务十分执行完整的一种状态</span><br><span class="line"> * 理解：</span><br><span class="line">   -多任务的定义，多任务执行</span><br><span class="line">   -让自己定义的多个任务一次执行，上一个任务如果没有完成，下一个任务就不会开始</span><br><span class="line"></span><br><span class="line"> function* fn() &#123;</span><br><span class="line">   yield &apos;任务1&apos;</span><br><span class="line">   yield &apos;任务2&apos;</span><br><span class="line">   return &apos;任务&apos;</span><br><span class="line"> &#125;</span><br><span class="line"> console.log( a.next())</span><br><span class="line"> console.log( a.next());</span><br></pre></td></tr></table></figure><p>es6(7) async 函数  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">es6,7</span><br><span class="line"> * 配合关键字 await表示等待，await 任务1 执行结束才会 执行任务2</span><br><span class="line"> * 使用场景： 数据先请求，然后把结果赋值到变量</span><br><span class="line"> async function fn() &#123;</span><br><span class="line"> const result = await &apos;任务1&apos;;</span><br><span class="line"> console.log( &apos;任务二&apos; );</span><br><span class="line">&#125;</span><br><span class="line">2. 箭头函数的写法</span><br><span class="line">const fn1 = async () =&gt; &#123;</span><br><span class="line">const res = await &apos;任务3&apos;;</span><br><span class="line">console.log( res );</span><br><span class="line">cosnole.log( &apos;任务4&apos; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   node中的 nextTick() 和 setImmediate()</p></li></ol><p>​<br>​        nextTIck<br>​        <em> setImmediate<br>​        </em><br>​        <em> 轮询： 一个事件往复执行，那么每一次执行完成，我们就认为是个轮询<br>​        </em> 事件轮询前， 使用nextTick<br>​        <em> 事件轮询后， 使用setImmediate<br>​        </em><br>​        * nextTick &gt; () =&gt;  &gt; setImmediate </p><p>​     </p><p> 第三方的 async.js 库</p><p>文档： <a href="http://caolan.github.io/async/v3/index.html" target="_blank" rel="noopener">async</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   cnpm i  yarn -g</span><br><span class="line">   yarn add <span class="keyword">async</span> -D</span><br><span class="line"></span><br><span class="line">- parallel: 并行</span><br><span class="line">- series ：串行,<span class="keyword">return</span> 数组，任务都是完整正确的，如果一个任务失败，后面的任务也会失败</span><br><span class="line"></span><br><span class="line">   主线程</span><br><span class="line">   并行 parallel &#123; <span class="attr">two</span>: <span class="number">2</span>, <span class="attr">one</span>: <span class="number">1</span> &#125;</span><br><span class="line">   串行 series &#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span> &#125;</span><br><span class="line">   结论： 主线程先执行，然后 parallel (谁快谁先走),最后 series 并行 (上个运行完，在运行下一个)</span><br></pre></td></tr></table></figure><h2 id="9-socket-通信"><a href="#9-socket-通信" class="headerlink" title="9.  socket 通信"></a>9.  socket 通信</h2><h4 id="1-基于后端的通信-pc"><a href="#1-基于后端的通信-pc" class="headerlink" title="1. 基于后端的通信  ( pc )"></a>1. 基于后端的通信  ( pc )</h4><ul><li>node 中的 net 模块</li></ul><p>服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>( <span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hostname = <span class="string">"localhost"</span>;</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">9000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clients = &#123;&#125;; <span class="comment">//存储每一个客户端</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;      <span class="comment">//给客户端编号</span></span><br><span class="line"><span class="comment">//1. 创建服务器</span></span><br><span class="line"><span class="keyword">const</span> server = <span class="keyword">new</span> net.createServer()</span><br><span class="line"><span class="comment">//2. 连接客户端</span></span><br><span class="line">server.on( <span class="string">'connection'</span>, client =&gt; &#123;</span><br><span class="line">  client.name = ++count; <span class="comment">///每个客户端起个名字</span></span><br><span class="line">  clients[ client.name ] = client; <span class="comment">//将每一个客户端 都存储在 clients 中，key:client.name</span></span><br><span class="line">  <span class="comment">//3. 获取客户端发来的数据</span></span><br><span class="line">  client.on( <span class="string">'data'</span>, msg =&gt; &#123;</span><br><span class="line">    boardcast( client, msg.toString() );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">`用户 <span class="subst">$&#123; client.name &#125;</span> 说: <span class="subst">$&#123; msg.toString()&#125;</span>`</span> )</span><br><span class="line"> </span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//监听客户端的异常</span></span><br><span class="line">  client.on( <span class="string">'error'</span>, error =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`error is <span class="subst">$&#123; error &#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//监听客户端的下线行为</span></span><br><span class="line">  client.on( <span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">//将下线的客户端清除 --清除 clents 对象</span></span><br><span class="line">    <span class="keyword">delete</span> clients[ client.name ]</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`客户端<span class="subst">$&#123; client.name &#125;</span> closed~~`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//4. 将客户端发来的信息展示到自己终端上( 广播 )  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boardcast</span>(<span class="params"> client, msg</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 客户端  客户端发来的消息</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> clients) &#123;</span><br><span class="line">    clients[ key ].write( msg );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 监听服务器</span></span><br><span class="line">server.listen( port, hostname, () =&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`The srerver is ruuing at:http://<span class="subst">$&#123;hostname&#125;</span>:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  客户端：</span></span><br><span class="line"><span class="comment">    1. 创建socket</span></span><br><span class="line"><span class="comment">    2. socket连接服务器</span></span><br><span class="line"><span class="comment">    3. 给服务器发送信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建socket</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> net = <span class="built_in">require</span>( <span class="string">'net'</span> );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> socket = <span class="keyword">new</span> net.Socket();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> port = <span class="number">9000</span>;</span><br><span class="line">  <span class="keyword">const</span> hostname = <span class="string">'localhost'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> readline = <span class="built_in">require</span>( <span class="string">'readline'</span> );<span class="comment">//这是用来做命令行读取</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rl = readline.createInterface(&#123;</span><br><span class="line">    input: process.stdin,</span><br><span class="line">    output: process.stdout</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2. socket连接服务器</span></span><br><span class="line"></span><br><span class="line">  socket.connect( port,hostname, () =&gt; &#123;</span><br><span class="line">    <span class="comment">//当我第一次连接好服务器之后，我给服务器发送一个我连接好的信息</span></span><br><span class="line">    socket.write( <span class="string">'欢迎xxx来到xxx的直播间'</span> )</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//客户端监听自己的异常</span></span><br><span class="line"></span><br><span class="line">  socket.on( <span class="string">'error'</span>, error =&gt;  &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">`socket error is <span class="subst">$&#123; error &#125;</span>`</span> )</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  socket.on( <span class="string">'close'</span> , () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">`socket connection closed ~~~`</span> )</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 给服务器发送信息</span></span><br><span class="line"></span><br><span class="line">  socket.on( <span class="string">'data'</span>, msg =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( msg.toString() )<span class="comment">//客户端自己显示写的内容</span></span><br><span class="line">    say()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">say</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    rl.question(<span class="string">'请输入: '</span>, ( answer ) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span>( answer === <span class="string">'bye'</span> )&#123;</span><br><span class="line">        <span class="comment">//要进行命令行的结束</span></span><br><span class="line">        socket.destroy() <span class="comment">//清除连接</span></span><br><span class="line">        rl.close()<span class="comment">// 关闭命令行读取</span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        socket.write( answer )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-基于H5的-webSocket-来完成-应用于移动端"><a href="#2-基于H5的-webSocket-来完成-应用于移动端" class="headerlink" title="2. 基于H5的 webSocket 来完成  ( 应用于移动端 )"></a>2. 基于H5的 webSocket 来完成  ( 应用于移动端 )</h4><p>服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  主服务器</span></span><br><span class="line"><span class="comment">    1. 通过ws模块来创建服务器</span></span><br><span class="line"><span class="comment">    2. 服务器连接客户端</span></span><br><span class="line"><span class="comment">      - 给客户端编号</span></span><br><span class="line"><span class="comment">    3. 接收客户端发来的信息</span></span><br><span class="line"><span class="comment">    4. 监听客户端下线</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 通过 ws模块 来创建服务器</span></span><br><span class="line">  <span class="keyword">const</span> webSocket = <span class="built_in">require</span>( <span class="string">'ws'</span> );</span><br><span class="line">  <span class="keyword">const</span> ws = <span class="keyword">new</span> webSocket.Server(&#123;</span><br><span class="line">    port: <span class="number">8000</span>,</span><br><span class="line">    host: <span class="string">'10.31.161.48'</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 服务器连接客户端</span></span><br><span class="line">  <span class="keyword">const</span> clients = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ws.on( <span class="string">'connection'</span>, client =&gt; &#123;</span><br><span class="line">    <span class="comment">//   - 给客户端编号</span></span><br><span class="line">    client.name = ++count;</span><br><span class="line">    clients[ client.name ] = client </span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端发来的数据</span></span><br><span class="line"></span><br><span class="line">    client.on( <span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">`客户端 <span class="subst">$&#123; client.name &#125;</span>说：<span class="subst">$&#123; msg &#125;</span>`</span>)</span><br><span class="line">      boardcast( client,msg )</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 监听客户端下线</span></span><br><span class="line">    client.on( <span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">delete</span> clients[ client.name ]</span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">`客户端 <span class="subst">$&#123; client.name &#125;</span> closed~~`</span> )</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">boardcast</span> (<span class="params"> client,msg </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> key <span class="keyword">in</span> clients )&#123;</span><br><span class="line">      clients[ key ].send( msg )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  客户端连接服务器文件</span></span><br><span class="line"><span class="comment">    \(^o^)/~          h5 提供了一个 Socket  的全局对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket( <span class="string">'ws://10.31.161.48:8000'</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ws.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ws.send( <span class="string">'欢迎来到xxx的直播间'</span> )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ws.onmessage = <span class="function">(<span class="params"> msg </span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> content = <span class="built_in">document</span>.querySelector( <span class="string">'#content'</span> );</span><br><span class="line">    content.innerHTML += msg.data + <span class="string">'&lt;br/&gt;'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ws.onerror = <span class="function">(<span class="params"> error </span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( error )&#123;</span><br><span class="line">      <span class="built_in">console</span>.log( error )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ws.onclose = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">`xxx下线了`</span> )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="3-低版本浏览器使用的-socket-io"><a href="#3-低版本浏览器使用的-socket-io" class="headerlink" title="3. 低版本浏览器使用的 socket.io"></a>3. 低版本浏览器使用的 socket.io</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Node-基础语法&quot;&gt;&lt;a href=&quot;#Node-基础语法&quot; class=&quot;headerlink&quot; title=&quot;Node 基础语法&quot;&gt;&lt;/a&gt;Node 基础语法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;浏览器Javascript 不能做什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li
      
    
    </summary>
    
      <category term="Node" scheme="http://meijuna.github.io/categories/Node/"/>
    
    
      <category term="Node" scheme="http://meijuna.github.io/tags/Node/"/>
    
      <category term="知识点" scheme="http://meijuna.github.io/tags/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>express Node 核心框架</title>
    <link href="http://meijuna.github.io/2019/06/17/express%E6%A1%86%E6%9E%B6/"/>
    <id>http://meijuna.github.io/2019/06/17/express框架/</id>
    <published>2019-06-17T13:50:29.972Z</published>
    <updated>2019-06-18T05:40:34.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="express-Node-核心框架"><a href="#express-Node-核心框架" class="headerlink" title="express Node 核心框架"></a>express Node 核心框架</h1><p>express是一个功能极简, 完全是由路由和中间件构成的一个web开发框架,是非侵入式的框架</p><h2 id="1-为什么要学习-express"><a href="#1-为什么要学习-express" class="headerlink" title="1. 为什么要学习 express ?"></a>1. 为什么要学习 express ?</h2><pre><code>- express 是 Node 的核心框架- express 可以帮助我们快速构建 web 服务器 / api 服务器- express 提供了一个快速生成工具 express-generator   - 快速生成工具： 帮助我们快速创建一个项目的工具</code></pre><h2 id="2-安装方式"><a href="#2-安装方式" class="headerlink" title="2. 安装方式"></a>2. 安装方式</h2><h3 id="1-全局安装"><a href="#1-全局安装" class="headerlink" title="1. 全局安装"></a>1. 全局安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> npm i express-generator -g  </span><br><span class="line">or </span><br><span class="line"><span class="meta">$</span> yarn add express-generator -g</span><br></pre></td></tr></table></figure><h3 id="2-npx-安装"><a href="#2-npx-安装" class="headerlink" title="2. npx 安装"></a>2. npx 安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(如果npm版本在 5.2+，那可以不用全局，用npx)</span><br><span class="line"></span><br><span class="line">$ npx express -e express_demo</span><br><span class="line"></span><br><span class="line">-e : 指的是我们使用一个叫 ejs 的模板（ejs.js 可以兼容html标签, 可以在标签中写 js ）</span><br></pre></td></tr></table></figure><h2 id="3-项目目录"><a href="#3-项目目录" class="headerlink" title="3. 项目目录"></a>3. 项目目录</h2><ul><li><p>bin </p><ul><li>www 启动了一个静态服务器 （ web服务器 ）</li></ul></li><li><p>node_modules 这个项目的依赖包</p></li><li><p>public 静态资源文件 ( html，css，images)</p></li><li><p>routes 路由文件夹</p></li><li><p>view</p><ul><li>xxx.ejs （ 项目模板 )</li></ul></li></ul><ul><li>app.js  ( 这个项目的入口文件 )</li></ul><h2 id="4-app-js-文件代码解读"><a href="#4-app-js-文件代码解读" class="headerlink" title="4. app.js 文件代码解读"></a>4. app.js 文件代码解读</h2><pre><code>- app对象的功能  1.  通过app.use来使用具有特定功能的函数 ( 又叫中间件 )- 中间件分类  1.  应用中间件 （ cors )  2.  路由中间件 app.get( &apos;/&apos; , (req, res, next ) =&gt; { } )   3.  错误处理中间件 function( err, req, res, next ) { }</code></pre><h2 id="5-express-创建-api-服务器-（-创建接口-）"><a href="#5-express-创建-api-服务器-（-创建接口-）" class="headerlink" title="5. express 创建 api 服务器 （ 创建接口 ）"></a>5. express 创建 api 服务器 （ 创建接口 ）</h2><ul><li>api  服务器是给前端提供接口数据</li><li>api 服务器需要使用的给测试工具来测试，不能用浏览器展示</li><li>注意： 后端个前端发送的数据类型是 JSON 字符串，前端需要 JSON.parse() 转换成对象</li></ul><h2 id="6-restful-api-规则"><a href="#6-restful-api-规则" class="headerlink" title="6. restful api 规则"></a>6. restful api 规则</h2><p>​    restful aip 规则 是一个暴露接口的规则 ，实现是一个接口使用不同的数据请求方式来实现不同的功能</p><h2 id="7-数据请求格式"><a href="#7-数据请求格式" class="headerlink" title="7. 数据请求格式"></a>7. 数据请求格式</h2><h3 id="1-get"><a href="#1-get" class="headerlink" title="1. get"></a>1. get</h3><ul><li>发送数据时，携带的参数时，形式是 Query string Parameters</li><li><p>后端 req.query 获取前端传来的数据</p><h3 id="2-post"><a href="#2-post" class="headerlink" title="2. post"></a>2. post</h3></li><li><p>发送数据时，携带的参数时，形式是 Form Data</p></li><li>前端 req.body 获取前端传来的数据</li></ul><h2 id="8-ecj-模板"><a href="#8-ecj-模板" class="headerlink" title="8. ecj 模板"></a>8. ecj 模板</h2><p><a href="https://ejs.bootcss.com/" target="_blank" rel="noopener">ecj 官网</a></p><p>EJS 是一套简单的模板语言，帮你利用 JavaScript 代码生成 HTML 页面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ejs模板语法:</span><br><span class="line"></span><br><span class="line">    &lt;% jsCode %&gt;执行正常js代码</span><br><span class="line">    &lt;% =data %&gt;转移输出</span><br><span class="line">    &lt;% -&quot;data&quot; %&gt;非转义输出</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;express-Node-核心框架&quot;&gt;&lt;a href=&quot;#express-Node-核心框架&quot; class=&quot;headerlink&quot; title=&quot;express Node 核心框架&quot;&gt;&lt;/a&gt;express Node 核心框架&lt;/h1&gt;&lt;p&gt;express是一个
      
    
    </summary>
    
      <category term="express" scheme="http://meijuna.github.io/categories/express/"/>
    
    
      <category term="Node" scheme="http://meijuna.github.io/tags/Node/"/>
    
      <category term="框架" scheme="http://meijuna.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
