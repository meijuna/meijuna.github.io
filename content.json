{"meta":{"title":"MeiJuna","subtitle":"一行代码 一行诗","description":null,"author":"MeiJuna","url":"http://meijuna.github.io"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-12-24T12:20:30.995Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"/404.html","permalink":"http://meijuna.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2018-12-25T02:31:36.149Z","updated":"2018-12-25T02:31:36.149Z","comments":false,"path":"about/index.html","permalink":"http://meijuna.github.io/about/index.html","excerpt":"","text":"12345678910111213141516171819202122232425262728293031&#123; name: &apos;梅伟军&apos; age: 22, gender: &apos;男&apos;, profession: &apos;Web Developer&apos;, experience: &apos;应届毕业生&apos;, address: &apos;浙江省丽水市&apos;, education: &apos;专科&apos;, github: &apos;https://github.com/meijuna&apos;, blog: &apos;http://blog.meijuna.com&apos;, email: &apos;1914623558@qq.com&apos;, description: &apos;致力于网站建设与前端用户体验设计&apos;, skills: [ [&apos;Html&apos;, &apos;Javascript&apos;, &apos;jQuery&apos;, &apos;CSS&apos;, &apos;ES6&apos;, &apos;Node&apos;], [&apos;Webpack&apos;, &apos;Gulp&apos;], [&apos;Less&apos;,&apos;Sass&apos;], [&apos;Git&apos;], [&apos;Vue&apos;], [&apos;Bootstrap&apos;, &apos;SUI Mobile&apos;, &apos;light7&apos;], [&apos;平面设计&apos;] ], devTools: [ [&apos;Sublime Text&apos;, &apos;Visual Studio Code&apos;, &apos;Notepad++&apos;], [&apos;Chrome DevTools&apos;, &apos;Fiddler&apos;], [&apos;SourceTree&apos;, &apos;TortoiseSVN&apos;], [&apos;SwitchHosts&apos;], [&apos;Navicat&apos;], ] &#125;"},{"title":"书单","date":"2018-12-25T02:07:47.632Z","updated":"2018-12-25T02:07:47.632Z","comments":false,"path":"books/index.html","permalink":"http://meijuna.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-12-24T12:20:31.015Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"categories/index.html","permalink":"http://meijuna.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-12-24T12:20:31.015Z","updated":"2018-10-04T14:11:17.000Z","comments":true,"path":"links/index.html","permalink":"http://meijuna.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-12-24T12:20:31.025Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"repository/index.html","permalink":"http://meijuna.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-12-24T12:20:31.025Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"tags/index.html","permalink":"http://meijuna.github.io/tags/index.html","excerpt":"","text":""},{"title":"Node 基础语法","date":"2019-06-18T05:41:20.999Z","updated":"2019-06-18T05:41:20.999Z","comments":true,"path":"categories/笔记/Node基础要点.html","permalink":"http://meijuna.github.io/categories/笔记/Node基础要点.html","excerpt":"","text":"Node 基础语法 浏览器Javascript 不能做什么？ 访问数据库 不能对文件进行操作 不能对系统进行操作 原因是为了安全，和浏览器的运行机制有关 在开发人员能力相同的情况下编程语言的能力取决于什么？ 取决于平台， cordova hbuilder 平台 platform java java虚拟机 （运行平台） php php虚拟机 +c# .net framework mono +js 解析内核 chrome v8 1. node 特点什么是node ? Node.js 是一个运行在Chrome V8 引擎的JavaScript 的一个运行环境 Node.js使用了一个事件驱动、非阻塞式I/O的模型,使其轻量又高效 事件驱动： 任务执行，发布者，订阅者，事件驱动 （ on emit ） 非阻塞： 执行某一个任务的同时也可以执行其他任务 阻塞： 执行某一个任务，这个任务如果没有执行完成，其他任务必须等待 同步 异步 I/O: 输入/输出（ 数据库，文件系统操作等操作 ） 非阻塞I/O模型： 当我们使用Node.js来实现数据库操作、文件系统等操作时，要进行的异步操作，异步操作的核心传统实现方式就是回调函数 2. 服务器： 定义： 可以运行在服务端的一个网站（站点） 种类： web服务器（ 静态服务器 ），可以运行在浏览器中的服务器 api 服务器（ 后端接口 )，后端语言暴露一个数据接口，用于前端的请求 1. http 创建web服务器： http 模块 createServer( callback(request, response, [next]){ }) listen(port, host, callback) //监听服务器 （ 反馈服务器状态） 123456789101112131415161718192021222324252627282930 // 1. 引入http模块(对象) const http = reqiure('http'); //2. 通过httpP模块上的 createServer 这个api 创建一个函数 //3. 创建服务器端口和域名 const port = 8888; const host = 'localhost';//127.0.0.1 const server = http.createServer( (request, response) =&gt; &#123; response.writeHead(200, &#123; //设置响应头 'Content-Type': 'text/html;charset=UTFf8' &#125;) response.write('返回给客户端的数据');//向前台发送信息 response.end(); //发送已经结束 &#125;).listen( port, host, () =&gt; &#123; console.log(`The server running at:http://$&#123; host &#125; : $&#123; port &#125; `) &#125;); ps:因为浏览器在请求时会默认发送favicon.ico图标请求,如需阻止在http回调函数里环境里判断阻止代码示例: if(request.url.indexOf(\"favicon.ico\") === -1)&#123; return false; &#125;;ps:关于设置响应头解析类型的设置 \"Content-type\":\"text/html;charset=utf-8\" 解析HTML标签以及属性 \"text/plain\" 纯文本 \"text/css\" 解析css \"text/javascript\" 解析js \"text/png\" 解析图片 \"text/json\" json数据 \"......\" 2. express 来创建api服务器12345678app.get(路由路径，(路由回调函数(路由中间件),next) =&gt; &#123; &#125;)const express = require('express');const app = express() //创建了一个app对象app.get('/', (req, res, next) =&gt; &#123;&#125;)app.listen(port, hostname, () =&gt; &#123; //创建一个服务器 console.log(`The server is runinng at:http://$&#123; hostname&#125;:$&#123; port &#125;`)&#125;) 3. Node 中文乱码问题解决：1. 设置请求头123response.writeHead(200, &#123; 'Content-Type': 'text/html;charset=UTF8' &#125;) 2. 发送 response.write()1response.write('&lt;meta charset=UTF-8&gt;') 3. toString()1对二进制有效：将二进制 -》 toSrgin() 4. Node 实时监听(自动刷新)借助第三方工具： nodemon [ 推荐 ] supervisor 5. commonJS规范 CommonJs 规范的提出，主要是为了弥补 javascript 没有标准的缺陷，希望javascript 能在任何地方运行，能向java和Python具有开发大型应用的基础能力，可不是停留在脚本程序的阶段。 commonJS规范思想 是单独的文件就是一个模块,每一个模块都是一个独立的作用域 每个文件对外接口都是module.exports对象 1. CommonJs的模块规范CommonJS对模块的定义主要分为： 1. 模块定义1234567//1. 模块定义const student = &#123; //可以是对象(可以传多个)、函数、字符串 name: 'meijuna', jineng () &#123; console.log('I cn fly'); &#125;&#125; 2. 模块导出123456//2. 模块导出module.exports = student; //安全性不高，只能到处多个module.exports = &#123; //更安全，批量导出 student, fn&#125;; 3. 模块引用123//3. 模块引用const student = require('./xx.js'); // orconst &#123; student, fn &#125; = requie('./xx.js); //可以按需引用 2. 模块标识符主要分类：1. 内置模块 （http、fs)1）url 模块：处理 urlURL模块提供了三种处理path的方法 123456789101112131415161718192021222324252627281) 将path字符类型转成对象left url = \"http://user:pass@host.com:8080/p/a/t/h?query=string#hash\";url.parse(url,[可选布尔值],[可选项布尔值]); &#123; 单词解释 解析属性 属性解释 协议 protocol:\"http:\", 协议 斜线 slashes:true, 是否有// 认证 auth:\"user:pass\", 用户名与密码 主机 host:\"host.com:8080\", 主机 接口 port:\"8080\", 端口 主机名 hostname:\"host.com\", 域名 搞砸 hash:\"#hash\", 片段标识符,指向html页面某个dom元素的id 搜索 search:\"?query=string\", ? + 查询字符串 查询 query:\"query=string\", 查询字符 路径名 pathname:\"/p/a/t/h\", 端口号和?之间的 路径那部分 路径 path:\"/p/a/t/h?query=string\", pathname + search 水平基准 href:全路径url 原始路径 &#125; 2) 将对象转成url字符串 url.format(obj) ps:参考结合parse方法; 3) 替换或者替换(未验证) url.resolve(from,to) from 源地址 to 需要添加或替换的标签 ps:form源地址末尾有/就是添加 没有就是替换 具体待验证 2) fs 模块fs 模块是专门处理操作磁盘文件,特点每个方法都有同步和异步两种 (需注意:同步以sync结尾) 123456789101112131415161718192021222324252627282930313233读取文件: fs.readFile(\"文件路径\",&#123;opt&#125;,function(err,data)&#123; &#123;opt&#125;:可选项 encoding:\"utf-8\" 以utf-8国际编码读取文件内容 flag:\"r+\" read的简称,只读取文件,不存在即报错 flag:\"w+\" write的简称,读写文件,不存在则自动创建 err:errorObject 报错机制 一般用if判断用throw抛出错误 列: if(err)&#123; throw err &#125; ps:console.error() 抛出错误,不影响程序执行 data:成功读取的数据,是以buffer数据二进制存储格式存在 ps:data.toString()可以转成UTF-8格式,等价于可选项中的encoding:\"utf-8\"; &#125;); 写入文件: fs.writeFile(\"写入路径\",\"内容数据\",&#123;opt&#125;,function(err)&#123;&#125;); 追加内容: fs.appendFile(\"追加文件路径\",\"内容数据\",function()&#123;&#125;); 读取文件夹: fs.readdir(\"文件夹路径\",function(err,paths)&#123; ps:readdir是directory的缩写 paths:成功读取文件夹 用数组存储文件内容 &#125;) 创建文件夹: fs.mkdir(\"文件夹路径,同时也是文件夹名称\",function(err)&#123;&#125;) 3）path 模块1234拼接路径: join(xx,xx,xxx,.）使用平台特定的分隔符,将所有给定的段连接在一起 ps:常用到的路径 __dirname 当前执行文件所在的绝对路径 4）querystring 模块querystring模块一般是对 http 请求的 URL 所带的数据进行解析处理 123456789101112131415161718191) 格式数据格式化为字符串:stringify let objData = &#123; name:\"skye\", url:\"http://skyelovedj.com\" &#125; let querystring = require(\"querystring\"); querystring.stringify(objData,\"分隔符\",\"分配符\")2) 将参数字符格式为对象: let strData = \"name:skye&amp;age=18\" let querystring = require(\"querystring\"); querystring.parse(strData,\"分隔符\",\"分配符\") ps:分隔符和分配符是可选项3) 编码: querystring.escape(\"data\") 只对符号与中文编码 4) 解码: querystring.Unescape(\"data\") 只对符号与中文解码 5) zlib制作压缩包的模块 流 * 可读的流： 可以通过文件系统读取的流 （ 数据流 ） * 可写的流： 可以通过文件系统写入的流 * 管道流 ： 连通两个文件的通道 pipe 12345678910111213const fs = require( 'fs' );const zlib = require( 'zlib'); //制作压缩包的模块//创建可读的流const readStream = fs.createReadStream('./a.txt' );//创建空压缩包const gzib = zlib.createGzip();//创建可写的流const writeStream = fs.createWriteStream('./b.text.gz');//创建流程readStream .pipe( gzib ) .pipe( writeStream ); 2. 第三方模块3. 自定义模块6. 发送数据请求： http.request request(封装 http-request 的第三方包) http.get(options, (res) =&gt;{ }) 7. 前端模块化为什么前端要使用模块化： 模块化：具有特定功能的一个对象(广义理解) 模块定义的流程： 1. 定义模块 2. 导出模块 3. 应用模块 好处： 1. 可以存储多个独立的功能块 2. 复用性高 种类： 1. ADM （ require.js ) 1234567define(&#123; a:1, b:2 &#125;) require([./a.js], function( moduleA ) &#123; //moduleA指的是 &#125;) CMD ( sea.js ) 12345define(function(require, exports, module )&#123; &#125;) require('./b.js', function( moduleB )&#123; //moduleB就是b模块中导出的内容 &#125;) Common.js （ require.js ） 12345678910111213141516171819Node 使用了 Common.js 的规范/*目录结构： name.js index.js *///模块定义 name.jsconst nameObj = &#123; name: 'MeiJuna'&#125;//模块导出module.exports = nameObj;//模块引用const nameObj = require('./nameObj)Node中Common.规范使用的三种类型： 1. 内置模块 (指的是挂载在Node全局对象身上的 api ) 2. 自定义模块 3. 第三方模块 7. 跨域问题前端跨域1. jsonp2. 反向代理（前端创建一个虚拟后端服务器，后台服务器帮助我们跨域） 后端跨域1. 设置响应头12res.setHeader(&apos;Access-Control-Allow-Origin&apos;, req.headers.origin);// req.headers.origin = http://127.0.0.1:5500/ 2. 使用第三方中间件 (cors)123456app.use( cors(&#123; \"origin\": \"*\", \"methods\": \"GET,HEAD,PUT,PATCH,POST,DELETE\", \"preflightContinue\": false, \"optionsSuccessStatus\": 200&#125;)) 中间件: 就是具有一定功能的函数 8. 前端的异步流程异步流程的任务是放在异步队列中的， 传统的原始异步 异步函数 事件 使用异步流程工具 （ 别人封装好的东西 ) es6 Promise 对象 all :依次执行完再执行 race: 谁快谁执行 es6 generator 函数 1234567891011121314151617在function 关键字后加一个 * * 通过 yield关键字定义任务 * fn().next() 来执行任务 结果返回一个对象 &#123;value: &apos;任务结果&apos;, done: false &#125; value表示 yield关键字有任务执行的结果 done 表示当前定义的所有的任务十分执行完整的一种状态 * 理解： -多任务的定义，多任务执行 -让自己定义的多个任务一次执行，上一个任务如果没有完成，下一个任务就不会开始 function* fn() &#123; yield &apos;任务1&apos; yield &apos;任务2&apos; return &apos;任务&apos; &#125; console.log( a.next()) console.log( a.next()); es6(7) async 函数 12345678910111213es6,7 * 配合关键字 await表示等待，await 任务1 执行结束才会 执行任务2 * 使用场景： 数据先请求，然后把结果赋值到变量 async function fn() &#123; const result = await &apos;任务1&apos;; console.log( &apos;任务二&apos; );&#125;2. 箭头函数的写法const fn1 = async () =&gt; &#123; const res = await &apos;任务3&apos;; console.log( res ); cosnole.log( &apos;任务4&apos; );&#125; node中的 nextTick() 和 setImmediate() ​​ nextTIck​ setImmediate​ ​ 轮询： 一个事件往复执行，那么每一次执行完成，我们就认为是个轮询​ 事件轮询前， 使用nextTick​ 事件轮询后， 使用setImmediate​ ​ * nextTick &gt; () =&gt; &gt; setImmediate ​ 第三方的 async.js 库 文档： async 12345678910 cnpm i yarn -g yarn add async -D- parallel: 并行- series ：串行,return 数组，任务都是完整正确的，如果一个任务失败，后面的任务也会失败 主线程 并行 parallel &#123; two: 2, one: 1 &#125; 串行 series &#123; one: 1, two: 2 &#125; 结论： 主线程先执行，然后 parallel (谁快谁先走),最后 series 并行 (上个运行完，在运行下一个) 9. socket 通信1. 基于后端的通信 ( pc ) node 中的 net 模块 服务器 123456789101112131415161718192021222324252627282930313233343536373839404142const net = require( 'net');const hostname = \"localhost\";const port = 9000;const clients = &#123;&#125;; //存储每一个客户端let count = 0; //给客户端编号//1. 创建服务器const server = new net.createServer()//2. 连接客户端server.on( 'connection', client =&gt; &#123; client.name = ++count; ///每个客户端起个名字 clients[ client.name ] = client; //将每一个客户端 都存储在 clients 中，key:client.name //3. 获取客户端发来的数据 client.on( 'data', msg =&gt; &#123; boardcast( client, msg.toString() ); console.log( `用户 $&#123; client.name &#125; 说: $&#123; msg.toString()&#125;` ) &#125;); //监听客户端的异常 client.on( 'error', error =&gt; &#123; console.log(`error is $&#123; error &#125;`); &#125;); //监听客户端的下线行为 client.on( 'close', () =&gt; &#123; //将下线的客户端清除 --清除 clents 对象 delete clients[ client.name ] console.log(`客户端$&#123; client.name &#125; closed~~`) &#125;)&#125;)//4. 将客户端发来的信息展示到自己终端上( 广播 ) function boardcast( client, msg) &#123; // 客户端 客户端发来的消息 for(var key in clients) &#123; clients[ key ].write( msg ); &#125;&#125;//5. 监听服务器server.listen( port, hostname, () =&gt;&#123; console.log(`The srerver is ruuing at:http://$&#123;hostname&#125;:$&#123;port&#125;`)&#125;) 客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* 客户端： 1. 创建socket 2. socket连接服务器 3. 给服务器发送信息*/// 1. 创建socket const net = require( 'net' ); const socket = new net.Socket(); const port = 9000; const hostname = 'localhost'; const readline = require( 'readline' );//这是用来做命令行读取 const rl = readline.createInterface(&#123; input: process.stdin, output: process.stdout &#125;); // 2. socket连接服务器 socket.connect( port,hostname, () =&gt; &#123; //当我第一次连接好服务器之后，我给服务器发送一个我连接好的信息 socket.write( '欢迎xxx来到xxx的直播间' ) &#125;) //客户端监听自己的异常 socket.on( 'error', error =&gt; &#123; console.log( `socket error is $&#123; error &#125;` ) &#125;) socket.on( 'close' , () =&gt; &#123; console.log( `socket connection closed ~~~` ) &#125;)// 3. 给服务器发送信息 socket.on( 'data', msg =&gt; &#123; console.log( msg.toString() )//客户端自己显示写的内容 say() &#125;) function say () &#123; rl.question('请输入: ', ( answer ) =&gt; &#123; if( answer === 'bye' )&#123; //要进行命令行的结束 socket.destroy() //清除连接 rl.close()// 关闭命令行读取 &#125;else&#123; socket.write( answer ) &#125; &#125;); &#125; 2. 基于H5的 webSocket 来完成 ( 应用于移动端 )服务器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 主服务器 1. 通过ws模块来创建服务器 2. 服务器连接客户端 - 给客户端编号 3. 接收客户端发来的信息 4. 监听客户端下线*/// 1. 通过 ws模块 来创建服务器 const webSocket = require( 'ws' ); const ws = new webSocket.Server(&#123; port: 8000, host: '10.31.161.48' &#125;)// 2. 服务器连接客户端 const clients = &#123;&#125;; let count = 0; ws.on( 'connection', client =&gt; &#123; // - 给客户端编号 client.name = ++count; clients[ client.name ] = client //接收客户端发来的数据 client.on( 'message', msg =&gt; &#123; console.log( `客户端 $&#123; client.name &#125;说：$&#123; msg &#125;`) boardcast( client,msg ) &#125;) // 4. 监听客户端下线 client.on( 'close', () =&gt; &#123; delete clients[ client.name ] console.log( `客户端 $&#123; client.name &#125; closed~~` ) &#125;) &#125;) function boardcast ( client,msg ) &#123; for( var key in clients )&#123; clients[ key ].send( msg ) &#125; &#125; 客户端 1234567891011121314151617181920212223242526/* 客户端连接服务器文件 \\(^o^)/~ h5 提供了一个 Socket 的全局对象*/ const ws = new WebSocket( 'ws://10.31.161.48:8000' ) ws.onopen = () =&gt; &#123; ws.send( '欢迎来到xxx的直播间' ) &#125; ws.onmessage = ( msg ) =&gt; &#123; const content = document.querySelector( '#content' ); content.innerHTML += msg.data + '&lt;br/&gt;' &#125; ws.onerror = ( error ) =&gt; &#123; if( error )&#123; console.log( error ) &#125; &#125; ws.onclose = () =&gt; &#123; console.log( `xxx下线了` ) &#125; 3. 低版本浏览器使用的 socket.io"}],"posts":[{"title":"知识点","slug":"知识点","date":"2019-06-21T13:40:26.000Z","updated":"2019-06-21T13:40:26.246Z","comments":true,"path":"2019/06/21/知识点/","link":"","permalink":"http://meijuna.github.io/2019/06/21/知识点/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"理解原型链和继承","slug":"理解原型链和继承","date":"2019-06-20T14:23:11.000Z","updated":"2019-06-20T14:45:24.383Z","comments":true,"path":"2019/06/20/理解原型链和继承/","link":"","permalink":"http://meijuna.github.io/2019/06/20/理解原型链和继承/","excerpt":"","text":"理解原型对象 只要创建了一个函数，就会创建一个 prototyep 属性，这个属性是一个指针，指向这个函数的原型对象，这个原型对这个象保存着所有示例共享的属性和方法。这个原型对象也会获得一个 constructor 属性，这个属性也是一个指针，指向其相关联的构造函数。 12345678910function Person() &#123; &#125;Person.prototype.name = \"meijun\";Person.prototype.age = \"22\";Person.prototype.sayName = function() &#123; alert(this.name)&#125;var person1 = new Person();var person2 = new Person();console.lconsole.log(person1.sayName === person2.sayName) //true","categories":[],"tags":[]},{"title":"执行环境及作用域链","slug":"执行环境和作用域","date":"2019-06-20T12:59:48.000Z","updated":"2019-06-21T00:27:31.275Z","comments":true,"path":"2019/06/20/执行环境和作用域/","link":"","permalink":"http://meijuna.github.io/2019/06/20/执行环境和作用域/","excerpt":"","text":"执行环境及作用域链​ 执行环境定义了变量或函数有权访问的其他数据，确定了它们各自的行为。每个执行执行环境都有一个与之关联的变量对象，这个变量变量对象保存着环境中定义的所有变量和函数。 ​ 全局执行环境就是最外围的一个执行环境。根据 ECMAScript 实现，所在的环境不同，表示的执行环境的对象页不一样。在浏览器中，全局执行环境被认为 window 对象。因此，在全局声明的属性和方法都是 window 对象的属性和方法。 1234var a = 1;console.log( window.a ) //1window.b = 2;console.log( b ) //2 ​ 在某个执行环境中的所有代码执行后，改环境被销毁，保存其中的所有变量和函数定义也随之销毁（ 全局执行直到应用退出——退出浏览器是才会被销毁）。 ​ 当代码在一个环境中执行时，会创建变量对象的一个作用域链。 ​ 作用域链的作用： 保证对有权访问的所有变量和函数进行有序的访问。 ​ 在作用域的前端，始终是当前执行的代码所在的 变量对象。如果这个环境是函数，活动对象就是变量对象。活动对象最开始只包含一个变量，即 （ arguments ) 对象（这个对象在全局环境是不存在的）。作用域链中的下一个变量对象来自包含环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局环境；全局执行环境的变量对象始终是最后一个对象。 12345678910var color = &quot;blue&quot;;function changeColor() &#123; if( color === &quot;blue&quot;) &#123; color = &quot;red&quot;; &#125; else &#123; color = &quot;blue&quot;; &#125;&#125;changeColor();alert() 在上面的例子中， 函数 changeColor() 的作用域链包含两个对象：它自己的变量对象（其中定义这 arguments 对象 ）和全局环境的变量对象。所以可以在函数内部访问变量 color。 2. 查找标识符 查找标识符的过程从作用于链的前端开始，向上逐级查找给定名字匹配的标识符。如果在局部环境中找到了该标识符，则查找停止，变量就绪。如果在局部环境没有找到该标识符，则沿作用域上查找。查找过程将一直追溯到全局的变量的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量为声明。 12345var color = &quot;blue&quot;;function getColor() &#123; return color;&#125;alert(getColo()); // blue 上面例子中调用了 getColor() 函数会引用变量 color 。为了确定 color 的值。就会沿着作用链向上搜索。 ​ 首先，搜索 getColor() 的变量对象，查找其中是否有个名叫color 的标识符。在没有找到的情况下，继续搜索下一个变量对象（全局环境的变量对象），在全局变量对象中搜索到了color，搜索结束。 ​ 在搜索过程中，如果存在一个局部变量的定义，则搜索会自动停止，不在进入另一个变量对象。换句话说，如果局部环境中存在着同名的标识符，就不会使用位于父环境中的标识符。例子： 123456var color = &quot;blue&quot;;function getColor() &#123; var color = red; return color;&#125;alert(getColo()); // red 内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和对象。每个环境都可以上搜索作用域链，已查询变量和遍历和函数名。但任何环境都不能通过向下搜索作用域链。","categories":[{"name":"知识点","slug":"知识点","permalink":"http://meijuna.github.io/categories/知识点/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://meijuna.github.io/tags/javaScript/"}]},{"title":"ECMAScript6 基础语法","slug":"ECMAScript6 基础语法","date":"2019-06-19T11:26:15.000Z","updated":"2019-06-21T13:22:36.760Z","comments":true,"path":"2019/06/19/ECMAScript6 基础语法/","link":"","permalink":"http://meijuna.github.io/2019/06/19/ECMAScript6 基础语法/","excerpt":"","text":"let 声明的变量只有在代码块内有效，在代码块外面调用会出错 相同的作用域内 不允许重复声明 123456789101112function()&#123; //报错 let a = &quot;1&quot; var a = &quot;2&quot;&#125;function func(age) &#123; //报错 不能再函数内部重新声明参数 let arg&#125;function func(age) &#123; //不报错 &#123; let arg &#125;&#125; let 定义的变量，不会发生变量提升( 在声明前使用，值为 undenfined ) 暂时性死区： 只要在块级作用域 let 和 const 命令，它所声明的变量就会绑定这个区域，不在受外部的影响。 这个区块对这些命令声明的变量从一开始就形成了封闭作用域。只要在声明之间就是用这些变量，就会报错。 2.2 块级作用域 2.2.1 为什么需要块级作用域？ 因为 es5 只用全局作用域和块级作用域，倒是很多场景不合理 内层变量可能覆盖外层变量 12345678var temp = new Date();function fn() &#123; console.log(temp); if (false) &#123; var temp = &apos;hello&apos; &#125;&#125;fn() //undefined 应为内部变量temp的提升导致覆盖外层 temp 变量 用来计数的循环边聊泄露为全局变量 12345var s = \"hello\"for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]); //h e l l o&#125;console.log(i) //5 i 只是来控制循环就，当是循环结束后，它并没有消失，而是变成了 全局变量 let 为Javascript 新增了块级作用域 1234567function fn() &#123; let = 5; if (true) &#123; let n = 10; &#125; console.log(n); //5 外层代码块不受内层代码块的影响&#125; 块级作用域的出现，使得应用广泛应用的立即执行匿名不在必要了： 1234567（function()&#123; var temp = &quot;&quot;&#125;)()&#123; let temp = &quot;&quot; &#125; const 声明一个常量 ，一旦声明，常量的值就不能改变 和 let 命令一样，只在声明所在的块级作用域内有效，声明的变量不会提升，同样存在暂死区，只能在声明后使用。 不可重复声明。 12const PI = 3.1415PI = 3.14 这就意味着 const 声明的常量在声明的时候，就必须初始化，不能留到以后赋值 12const PI;//SyntaxError const 的本质 const 实质上保证的并不是变量的值不改变，而是变量指向的那个内存不会改变。对于基本数据类型，值保存在变量只要的内存地址中，因此等于常量。但是对于引用类型来说，变量指向的内存地址保存的是一个指针。const 只能保证这个指针是固定，它指向的数据结构是不是可变的，这个是不能控制的，因此，将一个对象声明为常量必须非常小心。 12345678910const obj = &#123;&#125;;obj.prop = 123;obj.prop //123obj = &#123;&#125; // error 给变量 obj 赋值一个新的对象const a = [] ;a.push('hello') //可执行a.legth = 0 //可执行a = ['Dave'] //error常量 a 是一个数组，这个数组本身是可写的，当是如果将另一个数组赋值给 a， 就会报错 2.3.3 es6 声明变量的 6 中方法 1234声明变量方法:es5 ：var functiones6 : let const import class 所以共 6 种 2.4 顶层对象的属性 12345678910全局对象在浏览器环境： window 对象全局对象在 node 环境中： global 对象全局对象的属性和全局变量相关window.a = 1;console.log( a ) // 1a = 2 ;console.log( window.a ) //2 全局对象的属性和全局变量相关，被认为是 javascript 语言中最大的败笔之一。 回带来以下一个很大的问题： 无法在编译时就提示变量声明错误的提示，只有在运行时才知道。 源代码需要被编译成机器可以识别的程序，这个编译过程被称为编译时。 用户可以运行编译过的程序，程序运行的过程被称为运行时。 不知不觉就会创建全局变量 全局的属性导出都是可读写的，不利于模块化编程 es 6 为了改变这点，保持了兼容性，var 和 function 命令的全局依旧是顶层对象的属性；let 和 const 命令、class命令声明的全局变量不属于顶层函数的属性，也就是说 ES6开始，全局变量逐步与顶层对象的属性隔离。 12let b =1;window.b //undefined 第3章 变量的解构赋值 es 6 允许按照一定模式从数据和对象中提取值，然后对变量进行赋值，这被称为解构赋值。 1234567891011121314151617181920//只要左边的变量就会被赋予对应的值let [a, b, c ] = [1, 2, 3] let [foo, [ [bar], baz ] ] = [ 1, [2], 3] ]// 1 2 3let [, , third] = [\"foo\", \"bar\", \"baz\"] // baz //如果解构解构不成功，变量的值就等于 undefined let [foo] = [];let [bar, foo] = [1];//以上都解构都不成功，foot值都为 undefined//不完全解构 ：左边的模式只匹配了一部分的等号右边的数组let [x,y] = [1,2,3] //1 2let [a, [b], d] = [1, [2, 3], 4] 1 2 3 默认值: 解构赋值允许指定默认值 1let [x, y = 1 ] = [ &apos;a&apos; ] // x = a , y =1 对象的解构赋值 1234567let &#123; foo, bar &#125; = &#123; foo: &quot; aaa &quot;, bar: &quot; bbb &quot;&#125;; //aaa bbb对象的解构与数组的解构有一个重要的不同，数组的元素按次序排列的，变量的取值由它的位置确定的，而对象的属性没有次序，变量必须与属性同名才能取到正确的值let &#123; baz &#125; = &#123; foo: &quot;aaa&quot; ,bar : &quot; bbb &quot;&#125; undefined kn 如果等号右边的值不是对象或数组，就先将其转换为对象。由于undefinedd 和null 无法转换对象，所以进行结构赋值时会出错。 用途 12345678910111213141516171819let x = 1;let y = 2;[x, y ] = [y, x] //交换变量的 x y值从函数返回多个值由于函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了结构赋值，取出这些值就很方便function fn () &#123; return [1, 2,3]&#125;let [a, b, c] = fn()function obj () &#123; return &#123; a: 1, b: 2, c: 3 &#125;&#125;let [a, b, c] = obj ()","categories":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"http://meijuna.github.io/categories/ECMAScript6/"}],"tags":[{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"http://meijuna.github.io/tags/ECMAScript6/"}]},{"title":"浅谈MVC、MVP、MVVM架构模式的区别和联系","slug":"浅谈MVC、MVP、MVVM架构模式的区别和联系","date":"2019-06-18T13:48:08.823Z","updated":"2019-06-21T13:08:51.226Z","comments":true,"path":"2019/06/18/浅谈MVC、MVP、MVVM架构模式的区别和联系/","link":"","permalink":"http://meijuna.github.io/2019/06/18/浅谈MVC、MVP、MVVM架构模式的区别和联系/","excerpt":"","text":"MVC、MVP、MVVM这些模式是为了解决开发过程中的实际问题而提出来的，目前作为主流的几种架构模式而被广泛使用。 一、MVC（Model-View-Controller） MVC 是最常见的软件架构之一，它与衍生的 MVP 和 MVVM 架构 MVC模式的意思是，软件可以分成三个部分。 1234567891011121314- 视图（View）：用户界面。- 控制器（Controller）：业务逻辑处理- 模型（Model）：数据保存1. 视图 View 传送指令到 控制器 Controller2. 控制器 Controller 完成业务逻辑后，要求 模型 Model 改变状态2. 模型 Model 将新的数据发送到 视图 Vie 、、、、w，用户得到反馈MVC是比较直观的架构模式，用户操作-&gt;View（负责接收用户的输入操作）-&gt;Controller（业务逻辑处理）-&gt;Model（数据持久化）-&gt;View（将结果反馈给View）。所有通信都是单向的。 123456789优点模型与视图完全分离，我们可以修改视图而不影响模型可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁。如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑（单元测试）缺点由于对视图的渲染放在了Presenter中，所以视图和Presenter的交互会过于频繁。还有一点需要明白，如果Presenter过多地渲染了视图，往往会使得它与特定的视图的联系过于紧密。一旦视图需要变更，那么Presenter也需要变更了。比如说，原本用来呈现Html的Presenter现在也需要用于呈现Pdf了，那么视图很有可能也需要变更 二、MVP （Model-View-Presenter） MVP是把MVC中的Controller换成了Presenter（呈现），目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离。 123456781. 各部分之间的通信，都是双向的。2. View 与 Model 不发生联系，都通过 Presenter 传递。3. View 非常薄，不部署任何业务逻辑，称为&quot;被动视图&quot;（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。.NET程序员熟知的ASP.NET webform、winform基于事件驱动的开发技术就是使用的MVP模式。控件组成的页面充当View，实体数据库操作充当Model，而View和Model之间的控件数据绑定操作则属于Presenter。控件事件的处理可以通过自定义的IView接口实现，而View和IView都将对Presenter负责。 三、MVVM（Model-View-ViewModel） MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。 如果说MVP是对MVC的进一步改进，那么MVVM则是思想的完全变革。它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。 这方面典型的应用有.NET的WPF，js框架Knockout、AngularJS等。 原文地址：https://www.cnblogs.com/guwei4037/p/5591183.html","categories":[{"name":"express","slug":"express","permalink":"http://meijuna.github.io/categories/express/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://meijuna.github.io/tags/框架/"},{"name":"Node","slug":"Node","permalink":"http://meijuna.github.io/tags/Node/"}]},{"title":"MongoDB数据库","slug":"mongodb数据库","date":"2019-06-18T11:24:38.081Z","updated":"2019-06-21T13:09:51.463Z","comments":true,"path":"2019/06/18/mongodb数据库/","link":"","permalink":"http://meijuna.github.io/2019/06/18/mongodb数据库/","excerpt":"","text":"MongoDBMongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 常用命令1234567891011121314151617181920212223242526272829303132333435363738show dbs 查看数据库use dbname 创建数据库 如果不存在创建数据库，否则切换到数据库show collections 显示数据库集合1.添加数据 db.web.save(&#123;&quot;name&quot;: &quot;meiejuna&quot;&#125;) 创建了名称为 web 的名称，名 db.web.insert(&#123;&quot;name&quot;: &quot;meijuna&quot;&#125;) 插入相同的数据，sava 覆盖，insert 报错 2.删除数据 db.students.remove( &#123;&#125; ) 删除 students 集合下的所有数据 db.students.remove(&#123;&quot;name&quot;: &quot;meijuna&quot; &#125;) 删除 students 集合为 name 为 meijuna 的数据 db.students.drop() or db.runCommand(&#123;&quot;&quot;&#125;)删除 students 集合 db.runCommand( &#123; dropDaatabase: 1 &#125; ) 删除当前数据库 3.修改数据db.students.updata(&#123;&quot;name&quot;: &quot;meijuna&quot;&#125;,set:&#123;&quot;sex&quot;:&quot;women&quot;&#125;) 单行修改db.students.updata(&#123;&quot;name&quot;: &quot;meijuna&quot;&#125;,&#123;$set:&#123;&quot;sex&quot;:&quot;women&quot;&#125;&#125;, true, true) 多行修改 //&#123;查找条件&#125; , &#123; 修改内容 &#125; 匹配所有条件数据 修改所有匹配项4.查找数据 db.students.find() 查找 students 集合中的 所有 数据 db.students.findONe() 查找 students 集合中的 第一条 数据 db.students.find().pretty() 可视化查询 5.排序 db.students.find().sort(&#123;&quot;age&quot;: 1&#125;) 1 升 -1 降序6.截取db.students.find().skip(2) 下标为 2 开始截取db.students.find().limit(2) 截取 2 条数据7.筛选显示db.students.find(&#123;age:20&#125;,&#123;_id:0,age:1,name:1&#125;) 0,筛选的结果不显示，1筛选结果显示 SQL简介 关系型数据库 以行和列的形式存储数据，以便于用户理解。这一系列的行和列被称为表，一组表组成了数据库。表与表之间的数据记录有关系。 关系型数据库有：mySql oracle SqlServer Access db2 等 NoSQL简介 NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。 NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 非关系型数据库: MongoDB，Redis，HBase，CouchDB 等 非关系型数据库与关系型数据库区别关系型数据库的优势：1. 复杂查询 可以用SQL语句方便的在多个表之间做非常复杂的数据查询。 2. 事务支持 使得对于安全性能很高的数据访问要求得以实现。 非关系型数据库的优势：1. 性能 NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。 2. 可扩展性 同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 MongoDB优点它的特点是高性能、易部署、易使用，存储数据非常方便。 主要功能特性有： 面向集合存储，易存储对象类型的数据。 模式自由。 支持动态查询。 支持完全索引，包含内部对象。 支持查询。 支持复制和故障恢复。 使用高效的二进制数据存储，包括大型对象（如视频等）。 自动处理碎片，以支持云计算层次的扩展性 支持RUBY，PYTHON，JAVA，C++，PHP等多种语言。 文件存储格式为BSON（一种JSON的扩展） #### BSON 存储格式BSON是一种类似json的二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，**如Date和BinData类型。 BSON有三个特点：轻量性、可遍历性、高效性。 非关系型数据库文件存储格式为 BSON（一种JSON的扩展）。 MongoDB下载与安装1. MongoDB下载：https://www.mongodb.com/download-center#community&gt; 2. 设置环境变量在环境变量窗口中一般有两个变量，一个是你当前所使用的用户独有的环境变量，另一个是所有用户都可以访问的系统变量。其实如果在你的电脑上你只使用一个用户的话，那么不管你修改的用户的环境变量还是系统变量，效果都是一样的。为了以防未来会新建其他用户，那么我建议你修改系统变量而不是某个用户独有的环境变量。 3. 测试连接 管理员身份运行 cmd 输入 mongo 启动 mongdb 服务 net start mongdb 关闭 mongdb 服务 net stop MongoDB 4. 安装可视化工具(Robo 3T)https://robomongo.org/download node 使用 MongoDB 连接 MongoDB 123456789101112131415//1. 下载 mongoose cnpm i mongoose -D //2. 引入 mongoose const mongoose = require( 'mongoose');//3. 连接 mongoose // 连接本地mongodb ，本机的ip 127.0.0.1，端口：27017 数据库：studentmongoose.connect(\"mongodb://127.0.0.1:27017/student\",function(err)&#123; if(!err)&#123; console.log(\"connected to Mongodb\"); //连接成功 &#125;else&#123; throw err;//如果连接失败，则抛出异常 &#125;&#125;); 存储数据 Schema不仅定义了文档结构和使用性能，还可以有扩展插件、实例方法、静态方法、复合索引、文档生命周期钩子。 12345Schema ： 一种以文件形式存储的数据库模型骨架，不具备数据库的操作能力Model ： 由Schema发布生成的模型，具有抽象属性和行为的数据库操作对Entity ： 由Model创建的实体，他的操作也会影响数据库 存储数据步骤：定义Schema (骨架) &gt; 创建model（模型）&gt; Entity实例化方法。 1234567891011121314151617181920212223242526272829const mongoose = require( 'mongoose');const Schema = mongoose.Schema;mongoose.connect( 'mongodb://127.0.0.1:27017/meijuna',(error) =&gt; &#123; if ( error ) &#123; throw error &#125; else &#123; console.log( 'database is connected~') &#125;&#125;)const userSchema = new Schema(&#123; //定义数据模型 username: String, password: String&#125;)//通过模式studentSchema 创建一个模型studentModel var studentModel = mongoose.model(\"students\",studentSchema );var instance1 = new studentModel (); instance1.name=\"tangyan\";instance1.age=\"18\";instance1.save(function(err)&#123; //通过save方法保存 if (err) &#123; console.log('保存失败'); return; &#125; &#125;); 查询数据 12345// 查userModel.find(&#123;&#125;, ( error, result ) =&gt; &#123; if ( error ) throw error console.log ( result )&#125;) 修改数据 12345678910111213141516userModel.find(&#123; username: 'aaa'&#125;, ( error, result) =&gt;&#123; if (error) throw error const _id = result[0]._id userModel.findById(_id, ( error, doc ) =&gt; &#123; // 修改 if (error ) throw error console.log( doc ); doc.username = \"meijuna\"; doc.save ( (error) =&gt; &#123; throw error console.log(\"数据修改成功\") &#125;) &#125;)&#125;) 删除数据 1234567891011121314userModel.find(&#123; username: 'aaa'&#125;, ( error, result) =&gt;&#123; if (error) throw error const _id = result[0]._id userModel.findById(_id, ( error, doc ) =&gt; &#123; // 删除 if (error ) throw error doc.remove( (error) =&gt; &#123; if (error) throw error console.log('数据删除成功！') &#125;) &#125;)&#125;) 注册 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const mongoose = require('mongoose');const Schema = mongoose.Schema;mongoose.connect('mongodb://127.0.0.1:27017/meijuna', (error) =&gt; &#123; if (error) &#123; throw error &#125; else &#123; console.log('database is connected !!!') &#125;&#125;)const userSchema = new Schema(&#123; //定义数据模型 username: String, password: String&#125;)const userModel = mongoose.model('users', userSchema) //模型创建const user = new userModel(); //创建实体router.get('/', (req, res, next) =&gt; &#123; const &#123; username, password &#125; = req.query; console.log(username,password); userModel.find(&#123;&#125;, (error, result) =&gt; &#123; var flag = result.some((item) =&gt; &#123; return item.username === username &#125;) if (flag) &#123; //用户名存在 res.render('register', &#123; data: JSON.stringify(&#123; ret: true, //身份验证 权限验证 status: 2 //0 表示失败 1：成功 2： &#125;) &#125;) &#125; else &#123; user.username = username; user.password = password; user.save(); res.render('register', &#123; data: JSON.stringify(&#123; ret : true, status: 1 &#125;) &#125;) &#125; &#125;)&#125;)","categories":[{"name":"数据库","slug":"数据库","permalink":"http://meijuna.github.io/categories/数据库/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://meijuna.github.io/tags/Node/"},{"name":"mongoDB","slug":"mongoDB","permalink":"http://meijuna.github.io/tags/mongoDB/"},{"name":"数据库","slug":"数据库","permalink":"http://meijuna.github.io/tags/数据库/"}]},{"title":"Mackdown 基本语法","slug":"Mackdown语法","date":"2019-06-18T11:24:38.075Z","updated":"2019-06-18T05:41:05.814Z","comments":true,"path":"2019/06/18/Mackdown语法/","link":"","permalink":"http://meijuna.github.io/2019/06/18/Mackdown语法/","excerpt":"","text":"1、Markdown 简介但是，在我们正式写下第一个文字前，我们需要了解一下究竟什么是 Markdown？ Markdown 是一种可以使用普通文本编辑器编写的 标记语言，通过简单的 标记语法，它可以使普通文本内容具有一定的格式 基于 Markdown 语法的简洁性，它已经成为目前世界上最流行的用于书写博客的语言 2、Markdown 语法2、Markdown 语法在编写 Markdown 时，博主强烈的推荐给大家一款简洁易用的 Markdown 编辑器 —— Typora 按照官方的说法就是 简单而强大，它不仅支持原生的语法，也支持对应的快捷键，更重要的是它还可以 实时预览 这里附上 Typora 的下载地址：https://www.typora.io/，有兴趣的朋友可以下载来试试 好，下面开始进入正题，介绍一些常用的 Markdown 语法 （1）标题Markdown 语法： 1234567891011# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 Typora 快捷键： Ctrl+1：一级标题 Ctrl+2：二级标题 Ctrl+3：三级标题 Ctrl+4：四级标题 Ctrl+5：五级标题 Ctrl+6 ：六级标题 Ctrl+0：段落 （2）粗体、斜体、删除线和下划线Markdown 语法： 1234*斜体***粗体*****加粗斜体***~~删除线~~ Typora 快捷键： Ctrl+I：斜体 Ctrl+B：粗体 Ctrl+U：下划线 Alt+Shift+5：删除线 （3）引用块Markdown 语法： 12文字引用：&gt;Typora 快捷键： Ctrl+Shift+Q （4）代块Markdown 语法： 行内代码： 1234567行内代码多行代码：多行代码多行代码多行代码 Typora 快捷键： 行内代码：Ctrl+Shift+` 多行代码：Ctrl+Shift+K （5）公式块Markdown 语法： 123$$数学公式$$ Typora 快捷键： Ctrl+Shift+M （6）分割线Markdown 语法： 12345方法一：---方法二：+++方法三：*** （7）列表Markdown 语法： 12345671. 有序列表项* 无序列表项+ 无序列表项- 无序列表项 Typora 快捷键： 有序列表项：Ctrl+Shift+[ 无序列表项：Ctrl+Shift+] （8）表格Markdown 语法： 1234表头1|表头2-|-|-内容11|内容12内容21|内容22 表头1 表头2 内容11 内容12 内容21 内容22 Typora 快捷键： Ctrl+T （9）超链接Markdown语法： 12345方法一：[链接文字](链接地址 &quot;链接描述&quot;)例如：[示例链接](https://www.example.com/ &quot;示例链接&quot;)方法二：&lt;链接地址&gt;例如：&lt;https://www.example.com/&gt; Typora快捷键： Ctrl+K （10）图片Markdown语法： 12![图片文字](图片地址 &quot;图片描述&quot;)例如：![示例图片](https://www.example.com/example.PNG &quot;示例图片&quot;) Typora快捷键： Ctrl+Shift+I 说明：在 Hexo中 插入图片时，请按照以下的步骤进行设置 将 站点配置文件 中的 post_asset_folde 选项的值设置为 true 在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件 这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可 例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 ![示例图片](title/example.PNG &quot;示例图片&quot;) 添加图片","categories":[{"name":"前端","slug":"前端","permalink":"http://meijuna.github.io/categories/前端/"}],"tags":[{"name":"Mackdown","slug":"Mackdown","permalink":"http://meijuna.github.io/tags/Mackdown/"}]},{"title":"HTML+css 基础语法","slug":"HTML+css 基础语法","date":"2019-06-18T11:24:38.055Z","updated":"2019-06-21T13:19:30.298Z","comments":true,"path":"2019/06/18/HTML+css 基础语法/","link":"","permalink":"http://meijuna.github.io/2019/06/18/HTML+css 基础语法/","excerpt":"","text":"一、HTML什是么网站？ ​ 网站(Website)开始是指在因特网上根据一定的规则，使用HTML等工具制作的用于展示特定内容相关网页的集合 什么是网页？ ​ 网页是一个包含HTML标签的纯文本文件，它可以存放在世界某个角落的某一台计算机中，是超文本标记语言格式文件扩展名为.html。 文字与图片是构成一个网页的两个最基本的元素。 1. WEB标准的概念及组成 结构： HTML- 超文本标记语言 (Hyper Text Markup Language) XHTML-可扩展超文本标记语言(EXtensible HyperText Markup Language) 表现： CSS-层叠样式表（Cascading Style Sheets） 行为： JavaScript-是轻量级的脚本语言 2. XHTM基本语法1、常规标记/双标记1&lt;标记 属性=“属性值” 属性=“属性值”&gt;&lt;/标记&gt; 2、空标记/单标记&lt;标记 属性=“属性值” /&gt; 说明： ​ 写在&lt;&gt;中的第一个单词叫做标记、标签、元素名。 ​ 标记和属性用空格隔开，属性和属性值用等号连接，属性值必须放在“”号内。 ​ 一个标记可以没有属性也可以有多个属性，属性和属性之间不分先后顺序。 ​ 空标记没有单独的结束标签，用“/”代替。 3. HTML5 基本结构123456789101112&lt;!doctype html&gt;文档类型声明&lt;html&gt;&lt;/html&gt;说明文档写的是标记语言 ，根标签&lt;head&gt;&lt;/head&gt;文件头部&lt;title&gt;&lt;/title&gt;文件标题（显示在状态栏上的内容）&lt;meta charset=\"utf-8\" /&gt;['metə]编码格式--meta标记用于定义文件信息，对网页文件进行说明，便于搜索引擎查找设置关键字等 &lt;body&gt;&lt;/body&gt;文件主体(所有要写的内容) 4. 标签(&lt;&gt;)（1）标签单双分类（根据有无单独的结束标签）：​ 1. 双标签（常规标签）：有单独的结束标签 ​ h1~h6 p b strong i em del sup sub s strike ul ol dl dt dd li a table tr td ​ div span ​ 2. 单标签（空标签）：没有单独结束标签 ​ br hr img ​ （2）元素行块分类（根据有没有自占一行进行分类的）：​ 1. 块状元素：自占一行： ​ h1~h6 p hr ul ol dl dt dd li table div del ​ 2.行内元素：宽度跟内容大小一致，并且可以跟其他的行内元素在一行内并列显示的： ​ b strong i em del s strike sup sub br img a imput buttom span （3）标签作用12345678910111213141516171819202122232425加粗：&lt;b&gt;定义粗体的文本&lt;/b&gt; //没有语义强调的意思，一般称为物理字体格式化标签&lt;strong&gt;把文本定义为语气更强的强调的内容&lt;/strong&gt; //有语意 强调倾斜：&lt;i&gt;显示斜体文本效果&lt;/i&gt; //没有语义强调的意思，一般称为物理字体格式化标签&lt;em&gt;把文本定义为强调的内容&lt;/em&gt; //有语意 强调删除标记：&lt;del&gt;&lt;s&gt;元素，已废弃，用来给文本加删除线(在HTML 4.01中废除)HTML5 重定义了 &lt;s&gt; 元素，现在是被用来定义那些不正确的文本。&lt;strike&gt; 定义加删除线文本(html5不推荐使用)sup ：上标文本 sub：下标文本**注：**语义强调作用的```&lt;strong&gt;&lt;em&gt;```比```&lt;b&gt;&lt;i&gt;```更容易引起搜索引擎的注意，但是如果只是为了加粗样式，建议在css样式表里面实现 **div标记** (division-部分)可定义文档中的分区或节,可以把文档分割为独立的、不同的部分作用：文档区域，文档布局对象**span标记**文本结点：用来组合文档中的行内元素 5. 列表（ul, ol, dl）HTML中有三种列表，分别是：无序列表(ul)，有序列表(ol)，自定义列表(dl) 1234567891011121314151617无序列表&lt;ul&gt;--unordered List &lt;li&gt;列表项内容&lt;/li&gt; … …&lt;/ul&gt;有序列表&lt;ol&gt;-ordered List &lt;li&gt;列表项内容&lt;/li&gt; … …&lt;/ol&gt;自定义列表 &lt;dl&gt;Definition List &lt;dt&gt;名词&lt;/dt&gt;Definition term &lt;dd&gt;解释&lt;/dd&gt;Definition Description&lt;/dl&gt; 6. 图片(img)1&lt;img src=\"目标文件路径及全称\" alt=\"图片替换文本\" title=\"图片标题\" /&gt; 1. src属性：规定显示图像的 URL 2. title属性: 在你鼠标悬停在该图片上时显示一个小提示，鼠标离开就没有了，HTML的绝大多数标签都支持title属性，title属性就是专门做提示信息的; 3. alt属性: 规定图像的替代文本。[ælt] olt 注:所要插入的的图片必须放在站点下 src==source所用图片的来源(路径) 7. 超链接(a)1&lt;a href=\"\" title=\"\" target=\"_blank\"&gt; 链接文本/图片&lt;/a&gt; 1. href属性：设置目标文件路径 2. title属性：超链接标题 3. target属性：设置超链接的打开方式 [‘tɑrɡɪt] 属性值：_blank-新窗口打开 [blæŋk] ​ _self-默认的打开方式（本窗口打开） ​ _top 在顶层WINDOW对象中打开,一般用于多层框架嵌套的情况​ _parent 在父窗口打开,一般用于框架内的窗口改变父窗口页面 [‘peər(ə)nt] Href== Hypertext Reference的缩写，意思是超文本引用 8. 表单(from) 作用：用来收集用户信息的： 123456&lt;form action=\"test.html\" method=\"post\" name=\"myFomr\"&gt; &lt;p&gt;&lt;input type=\"text\" name=\"userName\" maxlength=\"50\" placeholder=\"邮箱账号或手机账号\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"password\" name=\"userPassword\" placeholder=\"密码\"&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;input type=\"reset\" value=\"reset\"&gt;&lt;/form&gt; action属性：规定当提交表单时，向何处发送表单数据。’ækʃ(ə)n] method属性：规定如何发送表单数据（表单数据发送到 action 属性所规定的页面）浏览器使用method属性设置的方法将表单中的数据传送给服务器进行处理。共有两种方法：POST 方法和 GET 方法。[‘meθəd] 1.文本框(input)1&lt;input type=\"text\" name=\"uername\" value=\"内容\" placeholder=\"提示\" maxlength=\"20\"/&gt; type属性： 规定 input 元素的类型；（password，email，button）。 value属性: 为 input 元素设定值； name属性：规定 input 元素的名称。name 属性用于对提交到服务器后的表单数据进行标识，或者在客户端通过 JavaScript 引用表单数据，只有设置了name属性的表单元素才能在提交表单时传递它们的值。 placeholder属性：规定帮助用户填写输入字段的提示 maxlength属性：规定输入字段中的字符的最大长度 2. 按钮(button)1&lt;input type=&quot;button&quot; name=&quot;&quot; value=&quot;按钮内容&quot; /&gt; button和submit的区别： submit是提交按钮起到提交信息的作用，button只是一个按钮 3. 9. 表格(table)作用：显示数据 123456789&lt;table width=\"600px\" height=\"400px\" border=\"3\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td rowspan=\"4\"&gt;第一个单元格&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=\"2\" rowspan=\"4\"&gt;&lt;/td&gt; &lt;td rowspan=\"4\"&gt;&lt;/td&gt; &lt;td rowspan=\"4\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; table: 标签定义HTML表格 tr: 元素定义表格行(table row) td: 元素定义表格单元(table data数据) border: “表格的边框” bordercolor:“表格边框颜色” cellspacing=0: 单元格与单元格之间的间距 cellpadding: 单元格与内容之间的空隙 ​ 水平对齐方式：align=”left/center/right”; ​ 垂直对齐方式： vertical-align=”top/middle/bottom”; ​ 注：对其方式在td,tr上使用 colspan: 所要合并的单元格的列数” 横向合并; rowspan: 所要合并单元格的行数” 纵向合并; 10. HTML和XHTML的语法区别123456XHTML 要求标签正确嵌套XHTML 所有标签必须关闭 /XHTML 区分大小写 XHTML 属性值要用双引号XHTML 用 id 属性代替 name 属性XHTML 特殊字符的处理 &amp;nbsp; &amp;lt; &amp;gt; 二、CSS基础1234white-space:pre nowrap //文本不进行换行知道text-overflow: //设置单行文本溢出是否显示省略号 clip 修剪文本 CSS (cascading style sheets)WEB标准中的表现标准语言,表现标准语言在网页中主要对网页信息的显示进行控制，简单说就是如何修饰网页的显示样式。—级联样式表、层叠样式表 语法：选择符 { 属性：属性值；属性：属性值 } 1.样式表分类(内部、外部、内嵌)1. 内部样式(style)1&lt;style type=\"text/css\"&gt;选择符 &#123; 属性：属性值；属性：属性值 &#125; &lt;/style&gt; 2. 外部样式(link)1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"目标文件路径\" /&gt; rel: 规定当前文档与被连接文档之间的关系 stylesheet: 样式表 type: 规定被链接文档的类型 href: 规定被链接文档的位置 3.外部样式表的导入-2(@import)123&lt;style type=\"text/css\"&gt; @import url(目标文件的路径就文件全称);&lt;/style&gt; 注：@和import之间没有空格 url和小括号之间也没有空格；必须结尾以分号结束 3.外部样式对比两种导入样式表的方法比较： link 属于 HTML 标签，而 @import 是 CSS 提供的。 页面被加载时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载。 @import 只在 IE 5 以上才能识别，而 link 是 HTML 标签，无兼容问题。 link 方式的样式的权重高于 @import 权重。 一般推荐使用 link 导入样式表的方法，@import 可以作为补充方法使用。 2. 选择器（选择符）1. 元素选择器/类型选择器（标签 )123语法：元素名称&#123;属性：属性值；&#125;说明：元素选择符就是以文档语言对象类型作为选择符，即使用结构中元素名称作为选择符。例如body、div、p,img,em,strong,span等。 2. id选择器 (#)123456语法：#id名&#123; &#125;&#123;属性：属性值;&#125; &lt;标记 id=\"名称1 名称2\" &gt;&lt;/标记&gt;说明：1） id属性值，在一个html文档中，必须是唯一的，不可重复，不能用关键字(所有的标记和属性都是关键字)2）一个id名称只能对应文档中一个具体的元素对象，因为id只能定义页面中某一个唯一的元素对象。3) 最大的用处：创建网页的外围结构 3. css选择器(.)1234567语法：.class名&#123;属性：属性值;&#125; &lt;标记 class=\"名称1 名称2\" &gt;&lt;/标记&gt;说明：1）class选择符更适合定义一类样式； 2） 一个标记可以设置多个class名3）class名可以重复4）限定标签类型 4. 群组选择器(,)123语法：选择器1，选择器2，选择器3&#123;属性：属性值;&#125;说明：当有多个选择符应用相同的样式时，可以将选择符用“，”分隔的方式，合并为一组 5. 后代选择器/包含选择器1234语法：选择器1 选择器2&#123;属性：属性值;&#125;说明：包含选择器选择器1和选择器2用空格隔开，含义就是选择符1中包含的所有选择器2; 6. 子选择器(&gt;)1234语法： 选择器1&gt;选择器2&#123;属性：属性值;&#125;说明：选择符1和选择符2用&gt;链接，选择符2必须是选择符1的子类 7. 伪类选择器(:hover)123456789语法 ： :link&#123;属性：属性值;&#125; //超链接的初始状态; :visited&#123;属性：属性值;&#125; //超链接被访问后的状态; ['vɪzɪtɪd] :hover&#123;属性：属性值;&#125; //鼠标悬停，即鼠标划过超链接时的状态; :active&#123;属性：属性值;&#125; //超链接被激活时的状态，即鼠标按下时超链接的状态; ['æktɪv] :focus //元素获得焦点的样式 ['fəʊkəs] 说明：1）当这4个超链接伪类选择符联合使用时，应注意他们的顺序，正常顺序为：a:link,a:visited,a:hover,a:active,错误的顺序有时会使超链接的样式失效； 2）使用与超链接相关的伪类选择符时，应为a元素定义href属性; 8. 通配符(*)1234567语法：*&#123;属性：属性值；&#125;说明：通配选择符的写法是“*”，其含义就是所有元素。用法：常用来重置样式全局样式*&#123;margin:0;padding:0;&#125;margin:0 auto; 让子元素相对父元素水平居中显示 3. 选择器的权重 12345678910111213内联 id class 标签 1 0 0 0# css中用四位数字表示权重，权重的表达方式如：0，0，0，0# id 0100# class选择器 （伪类选择符 :focus,:hover以及&lt;a&gt;:link） 0010 # 属性选择符的权重为 0010# 元素a 伪元素 :before、:after 0001# 后代选择符：1 2 = 1 + 2 # 子选择器 1 &gt; 2 = 1 + 2# 群组看选择符类型# *&#123;&#125;(通配符) 0 # 继承 0# 权重相同时，根据书写顺序而定，后书写的会把县书写的覆盖掉，会显示后书写的代码效果 4. CSS特性：(层叠性和继承性)层叠性：一个元素可能同时被多个css选择器选中，每个选择器都有一些css规则，这就是层叠。 CSS的处理原则是： 1）如果多个选择器定义的规则不发生冲突，则元素将应用所有选择器定义的样式。 2）如果多个选择器定义的规则发生了冲突，则CSS按选择器的特殊性(权重)让元素应用特殊性(权重)高的选择器定义的样式。 继承：所谓继承，就是父元素的规则也会适用于子元素。比如给body设置为color:Red;那么他内部的元素如果没有其他的规则设置，也都会变成红色。继承得来的规则没有特殊性。 多数边框类属性，比如Padding（补白），Margin（边界），背景和边框的属性都是不能继承的。(border属性是用来设置元素的边框的，它没有继承性) 块状、内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font-family、font-size、font-style、font-weight、text-decoration、text-transform. 块状元素可继承：text-indent和text-align。 列表元素可继承： list-style、list-style-type、list-style-position、list-style-image。 表格元素可继承：border-collapse。 css层叠性：​ 使用不同的选择符作用于同一个对象，每个选择符都有一些css声明/规则​ 如果规则没有发生冲突，这些样式都可以被执行​ 如果规则发生了冲突，根据选择符的权重/特殊性而定，执行权重高的选择符设置的样式​ 权重：​ 内联：1000​ id：100​ class 伪类：10​ 类型：1​ 群组：根据具体对象而定​ 包含：将使用的选择符相加=和​ 子：子结合符&gt; = 0 其他选择符相加=和​ 通配父，继承的样式 子结合符：权重为0​ css继承性： 子类可以继承父类的css样式​ 可以利用css继承，节省代码量，提高代码的可读性 5. 颜色(color)可以用以下方法来规定 CSS 中的颜色： 十六进制色 ：十六进制颜色是这样规定的：#RRGGBB，其中的 RR（红色）、GG（绿色）、BB（蓝色）十六进制整数规定了颜色的成分。所有值必须介于 0 与 FF 之间。举例说，#0000ff 值显示为蓝色，这是因为蓝色成分被设置为最高值（ff），而其他成分被设置为 0。 RGB 颜色：RGB 颜色值是这样规定的：rgb(red, green, blue)。每个参数 (red、green 以及 blue) 定义颜色的强度，可以是介于 0 与 255 之间的整数，或者是百分比值（从 0% 到 100%）。举例说，rgb(0,0,255) 值显示为蓝色，这是因为 blue 参数被设置为最高值（255），而其他被设置为 0。 RGBA 颜色：颜色值是 RGB 颜色值的扩展，带有一个 alpha 通道 - 它规定了对象的不透明度。 RGBA 颜色值是这样规定的：rgba(red, green, blue, alpha)。alpha 参数是介于 0.0（完全透明）与 1.0（完全不透明）的数字。 HSL 颜色：颜色值是这样规定的：hsl(hue, saturation, lightness)。 Hue 是色盘上的度数（从 0 到 360） - 0 (或 360) 是红色，120 是绿色，240 是蓝色。Saturation 是百分比值；0% 意味着灰色，而 100% 是全彩。Lightness 同样是百分比值；0% 是黑色，100% 是白色。 HSLA 颜色 ：颜色值是这样规定的：hsla(hue, saturation, lightness, alpha)，其中的 alpha 参数定义不透明度。alpha 参数是介于 0.0（完全透明）与 1.0（完全不透明）的数字。 预定义/跨浏览器颜色名 6. 浮动(float)123456789101112131415161718192021222324252627282930313233343536373839404142margin:0 auto/margin:auto;放置在一个标签上，可以使此标签在父元素中水平居中float:left/right/none A. 给元素添加浮动之后，会脱离正常文档流 B. 子元素浮动了，父元素在没有设置高度的情况下，会高度塌陷 C. 给元素添加浮动之后，元素会产生块级框，而不论本身是什么元素类型块状元素： 默认： width:auto - 与父元素同宽 height:auto - 与内容的高度相同 加浮动之后： width:auto - 与内容同宽 height:auto - 与内容的高度相同 设置具体的宽度和高度,设置的属性为多少，显示的大小就是多少 width:300px;height:300px 行内元素： 默认：不能设置宽度和高度，设置了显示无效 所以行内元素的显示大小，根据内容多少而定 加浮动之后：变成块状元素； width:auto; =不设宽度 A. 对于块状元素而言,浏览器自动计算，，会与父元素同宽， B. 对于块状元素而言，如果盒子浮动了，宽度与内容同宽 C. 如果给盒子设置具体的width:value，设置的多少，显示多宽2. 浮动对盒子宽度的影响： 标签的宽度为：width:auto; A. 对于块状元素而言,浏览器自动计算，，会与父元素同宽， B. 对于块状元素而言，如果盒子浮动了，宽度与内容同宽 盒子的宽度为：width:value； 如果给盒子设置具体的width:value，设置的多少，显示多宽 3. 浮动对盒子文档流的影响 添加了浮动的盒子，会脱离正常文档流； 4. 父元素的高度塌陷 父元素在没有设置具体高度的情况下，子元素全部浮动了，父元素的高度为0； 5. 浮动的图片应用：以往这个属性总应用于图像，使文本围绕在图像周围 6. 浮动元素会生成一个块级框，而不论它本身是何种元素。 width:height固定宽度时，除了padding 不管里面有多少内容 width height不变 解决flaot父元素高度塌陷 1.overflow: 块状元素，当width的属性值为auto/没写时，浏览器自动计算宽度，宽度是与父元素同宽 ​ 宽度：width:auto; ​ 高度：400px ​ 行内元素：不能设置宽度和高度，设置无效 7. backgroundbackground-image:url(../img/mao.gif);background-repeat:no-repeat;background-position:100px 100px; 起始点时左上角 [pəˈzɪʃn] background-position:100% 100% 起始点时中心background-position:center;background-position:227px 99px; 背景颜色：background-color​ 背景图片：background-image​ 背景重复：background-repeat [rɪ’piːt] 重复​ 背景定位：background-position [pəˈzɪʃən] 位置​ 背景状态：background-attachment [ə’tætʃm(ə)nt] e ta xu ment​ background：color url repeat position attachment; [‘kʌlə(r)] 单位 123456绝对长度单位、相对长度单位 绝对：cm mm in 等等 相对： ex - 字符x的高度 1ex=x的高度 em - 当前元素/父元素的文本大小 1em=font-size px - 设备上能显示的最小单位 css相对长度单位 8. 文本(font)[fɒnt]123456789101112131415161718192021222324252627282930313233343536373839404142434445font-size: &#123; none:[nʌn] norm:[nɔːm] px：设定固定值 %:基于父元素的一个百分比值&#125;font-family: &#123;//规定元素的字体系列 (1)此属性设置几个字体名称作为一种&quot;后备&quot;机制，如果浏览器不支持第一种字体，将尝试下一种字体。 (2) 如果字体系列的名称超过一个字，它必须用引号，如Font Family：&quot;宋体&quot;&quot;Times New Roman&quot;。 (3) 多个字体系列是用一个逗号分隔指明;&#125;font-weight:设置显示元素的文本中所用的字体加粗 &#123; [weɪt] 1-500=normal ,600-900=bold [bəʊld] bolder 更粗&#125;font-style: //设置文本倾斜&#123; italic [ɪ&apos;tælɪk] oblique [ə&apos;bliːk]&#125;text-indent&#123; %&#125;text-align:设置文本水平对齐&#123; [ə&apos;laɪn] left right center [ˈsentə(r)] justify 行内元素和文本是一样的 文本和行内元素都有作用对 块元素水平居中(0 auto)&#125;text-decoration: 文本修饰 [dekə&apos;reɪʃ(ə)n]&#123; // [dekə&apos;reɪʃ(ə)n] underline:文本下一条线 [ʌndə&apos;laɪn] overline: 文本上一条线 line-through: 穿过文本一条线 [θruː]&#125;text-transform：&#123; //设置文本大小写 [træns&apos;fɔrm] capitalize: [&apos;kæpɪtəlaɪz] 文本单词开头大写 uppercase: [&apos;ʌpə&apos;keɪs] 文本定义大小 lowercase: [ləʊə&apos;keɪs] 文本定义小写&#125;letter-spacing: &#123; //定义字符之间的间隔 + - 对汉字起作用&#125;word-spacing: &#123; //定义单词与单词之间的间隔z 只对单词有作用（字母和汉字无效）&#125;顺序: font-style | font-variant(小体大写字母) | font-weight | font-size / line-height | font-family font:[italic] [bold] 20px/&#123;100px] &apos;楷体&apos;; 9. 行高(line-hight)文本行的基线间的距离 123456789101112默认字体16px =&gt; lin-hight=21px;line-lenght:number 此数字会与当前字体尺寸相乘来设置行间距(2=2em,1em=元素文本大小 )%：基于当前字体尺寸的百分比(100%=当前尺寸)10px16px10px10px16px10px文本在行高内垂直居中应用户单行文本 控制文本的垂直居中 应用于多行文本控制多行文本的间距 10. 边框(border)1234border-color:设置边框颜色 red green blue;上 左右 下border-weight: bordrer-style: 设置边框类型 dotted(点状) dashed(虚线) solid(实线) double(双线)border- : 元素的所有边框设置宽度，或者单独地为各边边框设置宽度。 1234567891011121314outline****：（轮廓）**是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用，轮廓线不会占据空间，也不一定是矩形。outline-widthoutline-styleoutline-coloroutline:简写border跟outline的区别：1. border可应用于几乎所有有形的html元素，而outline是针对链接、表单控件和ImageMap等元素设计2. border占据空间，outline不占据空间 11. 列表(list)1234567list-style：none;去掉列表符号//定义列表符号的位置 [pəˈzɪʃən]list-style-position:inside（列表项目放置在文本以内，且环绕文本根据标记对齐） outside(默认)list-style-image: 设置图片作为列表符号list-type: 设置列表项标记的类型disc(实心圆)square(实心方块)decimal(数字)[dɪsk] [skweə] [&apos;desɪm(ə)l] 12.盒模型12345678910 占据的宽度：width+左右padding+左右border+左右margin 占据的高度：height+上下padding+上下border+上下margin 1. 盒模型的四个组成部分： content[kən&apos;tent] padding border marginpadding: 调整内容在盒子中的位置关系1. 需要添加到父元素上2. 不允许是负边距值3. 可以把内容撑大 4. 行内可以设置padding,但是显示有问题(上下显示有问题，左右没问题) 1234567891011121）. 将图片放在超链接中，在ie的低版本浏览器中，会自动解释出边框； 解决方法:img&#123;border:0/none&#125;2）. 将图片放在行内元素中，在行内元素没有设置高度的基础上，会将行内元素在图片自身高度的基础上，撑大3~5px A. img&#123;display:block&#125; B. div&#123;font-size:0 c. overflow:hidden; d.float:left;&#125;”。如果要实现图文混排，这种方法是很好的选择5. display:设置元素的显示类型 block：将元素设置为块状元素 图片将盒子撑大3~5px的原因：、 因为图片是行内元素，跟匿名文本之间的对齐方式是基线对齐，在文本基线的下行距 会 外边距(margin)12 1234567% 属性总结text-indent:参照父元素的宽度计算padding margin :基于父元素的宽度计算width height: 父元素的width,heightline-height：参照元素的font-sizebackground-size: 参照父元素 你 absolut:left/right/top/bottom 123456负值属性text-indent -负值background-postion: 负值marginabsolut:left/right/top/bottomz-index: 0=auto 123456简写属性background:border:font:list-style: type positionlist-style: url position 12345678910margin：auto - 浏览器计算 --具体valuepx/em/cm/mm %padding：不能为auto ，---具体valuepx/em/cm/mm % 1. 给子元素设置margin-top时，会影响到父元素一起向下移动； A. 给父元素后者子元素添加浮动 B. 给父元素加边框 C. overflow:hidden; 2. 两个盒子之间的margin区域是可以重叠的（没有浮动的情况下）； 3. 两个浮动盒子之间的margin区域是不重叠的； 4. margin可以设置负值，显示方向和正值完全相反； 5. 行内元素可以执行margin，但是上下显示 不正确，左右显示正确(padding一样) overflow1234567891011121314151617overflow: //主要应用 设置溢出盒子的显示方式 visible:默认溢出，正常显示 [ˈvɪzəbl] hidden:溢出以后，隐藏 [&apos;hɪdn] scroll: 显示滚动条 [skrəʊl] auto: 如果溢出显示滚动条，如果不溢出就不显示滚动条其他应用：A，给父元素添加overflow:hidden 可以解决高度塌陷B. 给父元素添加overflow:hidden 解决给子元素设置maring-top 影响父元素一起向上移动overflow-xoverflow-y省略text-overflow: clip //直接裁剪 ellipsis //显示省略号 string 新增的，浏览器不支持width:设置官渡overflow: hidden white-space:nowrap //强制让文本在一行内显示 123456789101112131415161718块级格式化上下文 BFC 其实归根结底，这里的浮动没有清除，只是因为overflow属性的值是hidden的时候会形成一个BFC，而BFC就是一个隔离的渲染区域，因此浮动造成的高崩塌会导致对外部布局的影响，为了消除这种不益的表现，计算高度的时候浮动元素也计算进去了。需要保证满足下面至少一条就会触发BFC：根元素body；设置了float值不为none的元素；设置了overflow属性不为visible的元素；设置了属性position不为relative和static的元素；设置了display的值为flex、table-cell、table-caption和inline-block中的任何一个的元素。可以看出来，就是一个比较独立的块，因为是一个独立的环境，在开发时候适度使用会有效降低开发和维护难度。大致可以归纳为三个方面：独立性、垂直分布规则和水平分布规则。独立性：BFC是页面上一个隔离的容器，和外面的关系是不会互相影响，对浮动而言也是，不会和浮动元素发生重叠，高也和上面提到的一样不会崩塌；垂直分布规则：BFC的内部里面的一个个盒子在垂直方向一个接着一个排放，位置由margin决定，两个相邻的盒子margin会发生重叠；水平分布规则：BFC里面的盒子的左外边缘和包含块的左边相接触，简单的理解就是水平方向不会发生margin重叠。 123456要实现溢出时产生省略号的效果还需定义： 1）、容器宽度：width：value；2）、强制文本在一行内显示:white-space：nowrap;3）、溢出内容为隐藏：overflow：hidden；4）、溢出文本显示省略号：text-overflow：ellipsis; [ɪ&apos;lɪpsɪs] 元素类型 块状元素 123456789101112131415161718192021222324 1. display: //设置盒子的显示类型 none:此标签在浏览器中不显示 block：此标签显示为块状元素-div p ul ol dl dt dd h1 form h1~h6 inline:此标签显示为行内元素-a span b strong i em img br sup sub inline-block:此标签显示为行内块元素 - input; 行内 list-item:此标签显示为列表项标签 - li table:此标签显示为块级表格标签 - table 元素类型： 块状级元素：display:block list-item table 行内级元素：display:inline inline-block inline-table;2. 块状元素的特征： (1) 可以设置宽度和高度 (2) 自占一行 (3) 作为容器使用，作为盒子使用，可以正确解释4盒模型中的属性； (4) 给盒子添加浮动之后，盒子在没有设置宽度和高度的情况下，在没有内容的情况下，宽度，高度为0；行内设置 a img span i em b strong br sub sup del s3. 行内元素的特征： A。不能设置宽度和高度 B。可以和其他行内元素在一行内显示 C。行内元素也符合盒模型的特征，也能执行盒模型中的规则，但是margin，padding，border的上下显示不正确，左右显示正常； D。盒子的大小有内容而定，如果给行内元素添加浮动之后，会生成块级框，变成块状元素 123451.行内元素2.行内元素1ver-align练习置换元素和飞置换元素小米商城 123456行内元素垂直方向的对齐方式：默认基线对齐1.给元素添加float 摆脱基线对齐 基线(小写字母x ,s,a 的下断沿的先)2.行内元素在开发工具书写时，如果进行换行和空格 解决：A. 写在一行，不进行换行 B. 给所有的行内元素添加float c. 给行内元素的父元素设置 font-size: 0; 当时行内元素有继承 font-size:0; 影响元素内的文本大小为0； 解决：给行内元素再设置font-size vertical-align12345678910vertical-align 设置元素的垂直的对齐方式 baseline: 默认 元素放在父元素的基线上(父元素的基线就是文本内容的基线) top bottom middle 垂直居中对齐 sub: 垂直对齐文本的下标 super: 在没有边距没区别 %：当前line-hight(开发不推荐) 允许负值 正值：向上移动当前行高的大小 负值：向下移动当前行高的大小 置换元素 定位12345postion: absolute 绝对定位 相当于static 定位以为的第一个父元素定位body--position:static div没设就是statichmlt---是绝对定为诶元素最大的参照物-默认fixed 行内元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061621. 行内元素在垂直方向的对其方式：默认是基线对其 基线：参照css核心属性的笔记-line-height 小写的英文字母x,s,a的下断沿的线2. 行内元素在开发工具中书写时，如果进行换行或者空格，在浏览器中，两个标签之间有一个空格；3. 去掉空格： A. 写在一行中，不进行换行； B. 给所有的行内元素添加浮动； C. 给行内元素的父元素设置font-size：0；可以解决这个问题，但是行内元素会继承font-size:0;造成元素内的文本大小为0； 解决：给行内元素单独再设置文本大小 D. 都都转为inline-block4. vertical-align： 设置元素的垂直对齐方式 注意：用在行内元素上面才有效5. 图片将盒子撑大3~5px的原因 因为图片是行内元素，跟空白字节之间的对其方式是基线对其，在文本基线的下面有下行间距，下行间距会将盒子撑大3~5px； 方法：img&#123;display：block&#125; div&#123;font-size:0;&#125; img&#123;vertical-align:只要不是baseline ，推荐使用top，middle，bottom&#125; 6. 静态定位的特点： position:static; 静态定位-没有特殊的定位效果，正常在文档流中显示 绝对定位的使用和特点： (1) : position:absolute-绝对定位; (2) : 根据参照物进行定位（参照物==包含块：有除了static以外的定位设置，并且是定位元素的父元素） (3) : left right top bottom 确定元素坐标的位置 (4) : left right top bottom:属性值可以是正值也可以是负值,属性值可以为%，px (5) 我们可以改变包含块的对象，不一定非是html 只要是父元素，只要设置了其他的定位设置（除static以为），都可以作为定位元素的参照物 (6) 绝对定位会使元素脱离正常文档流； body: ----默认是position:static; html:----是绝对定位元素最大的参照物，具有除静态定位以外的其他定位设置； 相对定位的使用和特点： （1）相对定位不会使元素脱离正常文档流； 7. 元素在垂直方向上的层叠顺序 (1) 如果元素没有设置css表现，按正常的书写，后书写的显示在上面 (2) 如果元素设置定位（除static之外），层叠顺序比没有设置定位的元素高； (3) 如果两个盒子都设置了定位，后书写的比较高 (4) 可以设置z-index属性，来提高元素的层叠顺序； z-index: auto/number; 值越大，层叠顺序越高 值越小，层叠顺序越低 z-index属性必须结合position属性使用才有效（属性值除static以外）；重点： 给盒子添加浮动，会脱离文档流 给行内元素添加浮动，产生块级框，变成块状元素 给盒子添加绝对定位，会脱离文档流 给行内元素添加绝对定位，产生块级框，变成块状元素 p 标签不能 嵌套diva 标签不能嵌套 a标签h1 标题不能嵌套 标题 盒模型 content(width,height) + border + padding + margin overflow使用-设置溢出容器的内容，如何显示 visible:表示溢出正常显示 [ˈvɪzəbl] hidden：表示溢出容器的内容，被裁剪掉 scroll：让容器显示滚动条，查看其余的内容 [skrəʊl] auto：如果溢出显示滚动条，不溢出就不显示 省略号的设置： text-overflow：clip - 直接裁剪 ellipsis- 显示省略号 string - 新增的，浏览器不支持 width:设置宽度 overflow：hidden-溢出隐藏 white-space：nowrap 强制让文本在一行内显示； 元素类型类型分类： 块状元素 行内（内联）元素块状元素：对应的标签：li ul ol dt dd form table h1~h6 div p​ 特征:(1) 能设置宽度和高度（2）自占一行 （3）作为容器使用，能正常解释盒模型的属性 （4）盒子在浏览器中以块的形式显示，宽度默认是auto与父元素同宽，高度根据内容而定，没有内容宽度为0行内元素：对应标签： a img i em b strong span br sup sub del s input​ 特征：（1）不能设置宽度和高度 （2）在一行内显示（3）也可以遵循盒模型的规则，但是个别显示不正确，border，padding，margin上下显示不正确，左右显示正常 （4）盒子的大小有内容而定，如果添加了浮动，盒子变成块状元素display：设置盒子的显示类型​ none：让盒子消失不可见​ block：快装​ inline：行内​ inline-block：行内块元素​ list-item：显示列表项 -li​ table：显示为块状表格 定位：position：absolute：绝对定位​ （1） 会使元素脱离正常文档流​ （2） 根据包含块进行定位​ 包含块：离绝对定位元素最近的并且有定位设置的父元素，定位设置不能是默认值-static​ （3） 根据left right top bottom相对定位：relative [‘relətɪv]​ （1） 不会使元素脱离正常文档流​ （2） 根据自身在正常文档流中的位置进行坐标的偏移​ （3） 根据left right top bottom [‘bɒtəm]​ fixed：固定定位 [fɪkst]​ （1） 会使元素脱离正常文档流​ （2） 根据窗口进行定位​ （3） 根据left right top bottom​ stiky：粘性定位​ （1）在窗口范围内，定位效果像相对定位，当移动浏览器滚动条，盒子距离窗口的位置=设置的像素数时，盒子位置不发生改变，像固定定位​ static：默认的定位效果，没有任务特殊的定位，在正常文档流中显示z-index：设置元素的堆叠顺序；​ auto：跟父元素的堆叠顺序相同​ number：数字越大，顺序越高，数字越小，顺序越低注意：必须结合position：absolute，relative，fixed，不能是static包含块的概念：为绝对定位的元素提供坐标偏移的参照物设置元素为包含块：给元素添加position：absolute，relative ，fixed 不能是static（推荐使用相对定位，因为不会使用元素脱离正常文档流） 锚点：（1）a href = “#锚点名”​ 在同一页面的不同位置进行跳转​ （2） a href =“文件路径#锚点名”​ 跳转到另外一个页面的锚点元素所在的位置overflow-x，y：设置某个方向上内容溢出如何显示，属性值跟overflow相同 宽高自适应： 概念，优势 伪元素选择符：5个 after[‘ɑːftə] 元素的高度如何自适应窗口的高度 清除浮动的三种方式：3种 overflow:hidden ​ [ə(ʊ)’pæsɪtɪ] 隐藏元素：display：none opacity：0-1 visibility：visible hidden 一组属性；min/max-width/height ming max 属性选择符：权重是10； 图片整合的概念（精灵图 图片精灵） 图片整合的优势（1）减少请求次数，提高加载速度 （2）减小图片的体积 兼容 五大浏览器采用的都是单内核，而随着浏览器的发展现在也出现了双内核。360浏览器、QQ浏览器都是采用双内核。 1、IE浏览器内核：Trident内核，也是俗称的IE内核； 2、Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核； 3、Firefox浏览器内核：Gecko内核，俗称Firefox内核； 4、Safari浏览器内核：Webkit内核； 5、Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是Blink内核； 6、360浏览器、猎豹浏览器内核：IE+Chrome双内核； 7、搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）； 8、百度浏览器、世界之窗内核：IE内核； 9、2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核； 常见的兼容问题：​ 双倍边界​ 默认高度​ 图片间隙​ cursor属性：设置鼠标指针的形状；​ png：ie支持png8位图片的背景透明，不支持其他的位数； H5特点：添加 语意标签 canvas画布 多媒体交互标签 (video src ) mack(高亮显示文字) 骨架更简单 header nav section aside(侧边栏) footer figcaption email url 检测地址 number 专门用来输入数字 max min step:默认1 range: max min step search: 比文本框多了x color: 调色板 tel: 和文本框没区别 兼容性很大 date： month 年月 week 年周 time 小时分钟 datetime 没显示 世界统一时 datetime-local 北京时间 output：输出框 属性 required:内容空白不能提交 placeholder: pattern:正则表达式 autofocus: 页面刚加载自动获得焦点 list:（datalistId）与datalist标签&gt;option 配合使用 类似select autocomplete:自动完成功能-name历史记录 min max step novalidate: 规定在提交表单，取消验证内容 multiple: 输入可以输入多个内容，用 ， 分开 form(fomrId值):控件链接idfrom 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283浏览器模式标准模式：ie高版本浏览器 chrome safari 怪异模式：ie6 ie7什么情况下会在怪异模式下解析：​ - 文档声明不正确，或者不存在​ -h5中只有一种文档声明 &lt;!DOCTYPE html&gt;​ html4中文不能中 1. 过渡版本 标签的使用：不能使用框架标签 2. 严格版本 不能使用弃用标签，不能使用表现性标签，不能使用框架标签盒模型在不同浏览器中的解释#### css3渐进增强优雅降级![](HTML笔记/css3.png)基本选选择符层级选择符属性选择符：​ input[type=&quot;e&quot;]//e开头​ input[type=&quot;$e&quot;]//以e结尾的input标签​ input[ytpe=&quot;*=e&quot;] //包含e的input标签伪元素选择器::first-letter::firset-line::before::after::selection 伪类选择器:target //目标伪类选择器：某个目标元素被触发的时候​ 锚点e:not(f) 否定伪类选择器结构伪类选择器e:mpty // ：当元素内容为空时结构:root // 给根元素(html)添加有:nth-child(n) 匹配父元素中的第n个子元素​ n:表达式：2n+1=odd, 2n=even​ 数字 表达式 关键字 n:nth-last(n) :nth-of-type(n)://先看类型在看个数:only-child :看个数再看来下:only-of-type //来类型再看数字:first-child :last-child :first-of-type:last-of-typeUI元素状态伪类选择器:hover:active:focusE:disabled //设置该元素处于不可用状态的样式E:enabled //设置元素处于可用状态的样式E:read-only //元素处于只读状态E:read-write //E:checked //表单中radio or checkbox 处于选中状态E:default //页面打开时 默认处于选中状态 （一直执行）E:selection //指定当元素处于选中状态时的样式E:indeterminate //当页面打开时，如果一组单选框都没有选中才执行，如果用户选中了一个，则样式取消validinvalid###### 内核前缀Trident内核 -ms -ms-border-radiusGecko内核： -moz (火狐)Presto内核 -oWebkit内核: -webkit###### 文本属性 中文默认自动换行，字母word-break: ​ norm:默认​ break-all：允许单词内换行​ keep-all: - 字符才换行word-wrap: 允许长单词 or url 内部进行换行text-shadow: 向文本添加应用​ 3px 3px 模糊 color,-3px -5px 模糊 color###### 边框border-radius: 20px 30px; //对角线角 圆角边框border-image: //边框图片 border-top-left-radius:40px 90px 水平半径 垂直半径border-image-source &amp;&amp; border-image-slice: //裁剪border-image-repeat: 图片平铺border-image-width: 图片边框宽度border-image-outsetbrder-colors //设置边框颜色box-shadow: //设置盒子的阴影​ h-shadow: 0 ​ v-shadow ：0​ blur： 模糊距离​ []: 阴影大小 默认和盒子一样大​ color​ inset: 内阴影指定元素的的宽度与高度的计算方法box-sizing: content-box //width =盒子内容区域大小 =标准模式​ border-box // 边框盒子大小 （content+padding+border) =怪异模式![](HTML笔记/微信图片_20190405175634.png)##### 背景background 属性提升background-size: width height ​ %：盒子宽度的% 盒子的%​ number: 会改变比例​ cover: 等比例改变宽高，能覆盖 可能超出盒子​ contain: 等比例改变宽高，按最小的放大默认情况下：如果盒子有内边距，背景图从内边距的padding开始显示如果没有padding,背景图从内容盒子的background-origin // 规定图片的显示区域​ border-box //背景图从边框盒子开始显示​ padding-box //默认效果​ conente-box //从内容位置开始显示 没有paddingbackground-clip //背景图片的裁剪区域​ border-box 背景裁剪到边框盒​ padding-box //​ content-box 背景图裁剪到内容区可见​ text-webkit-text-fill-color: //文本填充颜色​ 颜色rgba()hsl(色调，饱和度，亮度) &#123;0,360&#125; &#123;0,100%&#125; &#123;0,100%&#125;hsaltransparent##### 字体.ttf eot woff otf svg 定义字体 font-face规则 字体定义规则@font-face{​ 定义字体名称​ font-family: “myfont”​ 字体路径​ src:url(../font)}font-family: “myfont”123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113作业 名鞋侧边栏​ 淘宝工具栏##### css3弹性盒新的布局模式-flexible box布局，即收缩布局盒模型(弹性盒布局)![](HTML笔记/css3弹性.jpg)​ ![](HTML笔记/css3啊.jpg)​ 3个版本 旧版本 混合版本 新版本容器上：display //设置元素为弹性盒​ flex/line-flex //块状弹性盒​ 使内部元素获得弹性布局效果 ，原本垂直 块级弹性盒：​ 父元素如果是弹性盒子，子元素作为弹性项目，在没有设置width 的情况下，width 与内容铜矿，​ 子元素作为弹性项目，在主轴方向方向从主轴起点上一次排序 子元素在没有设置height的情况下，height会拉伸与父元素同高 ，如果设置了多高就多高行内弹性盒：​ flex-direction //规定灵活项目的方向​ row:默认值，灵活的项目水平显示​ row-reverse: 与fow相同，但是以相反的顺序排列​ column: 灵活项目将垂直显示​ column-reverse: 主轴方向垂直，但是以相反的顺序排列flex-wrap // 用于设置​ nowrap: 默认 不换行不换列 改变width height​ wrap : 规定灵活项目必要时换行，换列​ wrap-reverse 简写：flex-flow：flex-flow: column-reverse wrap-reverse justify-content //设置子元素在主轴(水平方向的/垂直方向)上的对齐方式​ flex-start //项目位于主轴的开头、​ flex-end //项目位于主轴的结尾​ enter //位于主轴的中心​ space-between // 如果父元素的width大于子元素，留下的空白平均分给两个子元素之间​ space-around: //平均分别分给每个元素的两边align-items //设置子元素在侧轴方向的对齐方式​ stretch ： 拉伸到适应容器 父元素没有height ​ center: 元素位于容器中心​ flex-start : 侧轴的起点开始​ flex-end: ​ baseline align-content // 设置多行子元素在侧轴上的对齐方式（多行时，属性才生效)​ stretch: //元素拉伸以适应容器​ center //元素位于容器的中心​ flex-start: //侧轴起点位置​ flex-end //侧轴重点​ space-between: //​ space-around:##### 视口（viewport）视口：初始视口980 考虑移动端访问pc端 &lt;meta name=”viewport” content=”width=device-diwh，initial=scale=”1.0&gt; 视口的width=设备屏幕的width （1 = 按页面实际尺寸显示 无缩放） 2. minimum-scale 设定最小做小比例 (0-10，1=禁止用户缩小至实际尺寸之下) 3. maximum-scale 这顶最大缩放比例 (0-10，1=禁止用户放大至实际尺寸之上) 4. user-scalable=&quot;no/yes&quot; (在实际尺寸之上用户是否可也缩放) 1234##### #### css3媒体查询 @media meatype and|not|only ((条件表达式){ screen }css3添加媒体属性only： 限定某种设备执行媒体查询ccs2：媒体只能查询设备，没有条件 ` 移动端适配 改变html-font-sizevwjs@media 不精细,避免 响应式布局常见布局方案 固定布局：以像素作为页面的基本单位，不管设备屏幕及浏览器宽度，只设计一套尺寸； 可切换的固定布局：同样以像素作为页面单位，参考主流设备尺寸，设计几套不同宽度的布局。通过识别的屏幕尺寸或浏览器宽度，选择最合适的那套宽度布局； 弹性布局：以百分比作为页面的基本单位，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果； 混合布局：同弹性布局类似，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果；只是混合像素、和百分比两种单位作为页面单位。 布局响应：对页面进行响应式的设计实现，需要对相同内容进行不同宽度的布局设计，有两种方式：pc优先（从pc端开始向下设计）；​ 移动优先（从移动端向上设计）； 无论基于那种模式的设计，要兼容所有设备，布局响应时不可避免地需要对模块布局做一些变化（发生布局改变的临界点称之为断点）","categories":[{"name":"HTML","slug":"HTML","permalink":"http://meijuna.github.io/categories/HTML/"}],"tags":[{"name":"语法","slug":"语法","permalink":"http://meijuna.github.io/tags/语法/"},{"name":"HTML","slug":"HTML","permalink":"http://meijuna.github.io/tags/HTML/"},{"name":"css","slug":"css","permalink":"http://meijuna.github.io/tags/css/"}]},{"title":"Hexo + github 搭建个人博客","slug":"Hexo + github 搭建个人博客","date":"2019-06-18T11:24:38.051Z","updated":"2019-06-21T12:22:41.222Z","comments":true,"path":"2019/06/18/Hexo + github 搭建个人博客/","link":"","permalink":"http://meijuna.github.io/2019/06/18/Hexo + github 搭建个人博客/","excerpt":"","text":"1.博客维护1.发布文章在站点文件夹中打开 git bash，输入如下命令部署和发布文章: 1$ hexo g -d 建议：在使用 hexo g 部署之后，可以先使用 hexo s 运行本地站点，然后在浏览器输入地址 http://lacolhost:4000/ 查看运行结果，检查无误后再使用 hexo d 发布 2.新建博客时添加对应的图片文件夹将 站点配置文件 中的 post_asset_folde 选项的值设置为 true 在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件 这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可 例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 添加图片 3.模板设置当我们使用命令 hexo new &quot;title&quot; 创建文章时，Hexo 会根据 /scaffolds/post.md 对新文章进行初始化 换言之，/scaffolds/post.md 就是新文章的 模板，所以我们可以修改它来适应自己的写作习惯 在每篇利用 Hexo 创建的文章的开头，都会有对文章进行说明的文字，叫做 文章头部 文章的头部除了可以设置文章标题、发布日期等基础信息外，还可以为文章添加标签、分类等 一个简单的示例如下： 1234title: Titledate: YYYY-MM-DD HH:MM:SStags: [tag1, tag2, ...]categories: category 注意：属性和属性值之间必须有一个空格，否则会解析错误 2.搭建博客1.搭建github博客1.github新建博客文件，库名要所有者名字一样，如：meijuna.github.io 的格式 2.Settings =&gt; 选择一个主题保存 就可以访问 meijuna.github.io 了 2.Hexo搭建本地博客hexo命令 hexo s(server) –&gt; 启动本地服务 hexo clean –&gt; 清除缓存 hexo g (generate) –&gt; 创建网页 hexo d (deploy) –&gt; 同步到github 1.安装node.js + git 以Windows环境安装node.js为例，首先登录node.js官网，选择适合自己的版本进行下载，然后进行安装。 登录git官网选择版本进行下载，基本一路next下去即可轻松完成安装。 2.首先在本地磁盘中建立一个Hexo文件夹用于存储本地文件(做本地文件保存以及测试使用) 3.下载Hexo: 1npm install hexo -g 4.初始化博客空间，生成博客运作所需要的文件，接下来安装依赖包 1npm install 5.同步Github,允许公共访问 1.首先找到我们的博客仓库，并拷贝仓库地址：git clone 主题仓库地址 放到 themes 文件夹下 2.打开_config.yml 文件配置： 1234deploy: type: git repo: https://github.com/meijuna/meijuna.github.io branch: master 3.最后执行控制台命令： 123npm install hexo-deployer-git —save //安装部署插件hexo d //部署到github 就用 meijuna.github.io 访问博客了 2.Hexo 的主题美化1.到 Hexo主题官网 下载主题放到 themes 文件夹 2.配置根目录的 _config.yml 中： 1theme: pure //选择下载主体文件的名字 3.hexo clean -&gt; hexo g -d 看效果 4.具体主题美化看下载的主题文档 3.在Hexo博客上添加可爱的Live 2D模型首先，安装npm包： 1npm install --save hexo-helper-live2d 然后在hexo的根目录配置文件_config.yml中添加如下配置，详细配置可以参考文档： 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-koharu display: position: right width: 150 height: 300 mobile: show: true 然后下载模型，模型名称可以到这里参考，一些模型的预览可以在这里。 1npm install live2d-widget-model-koharu 下载完之后，在 Hexo 根目录中新建文件夹 live2d_models，然后在node_modules文件夹中找到刚刚下载的live2d模型，将其复制到 live2d_models 中，然后编辑_config.yml配置文件中的model.use项，将其修改为live2d_models文件夹中的模型文件夹名称。 一切就绪之后，用hexo server命令启动服务器，大功告成！ 4.阿里云解析域名1.阿里云购买域名 解析 -&gt; 添加记录 -&gt; A 类型 -&gt; www -&gt; 默认 -&gt; ping meijuna.github.io 地址的值 -&gt;ttl 10 3.在根目录下的 source 文件夹 创建 CNAME 文件 ，内容为 www.meijuna.top 5.其他1.hexo中添加图片的方法1.下载插件 1npm install hexo-asset-image --save // hexo n &quot;文件&quot; 自动生成相同文件名的文件夹存放图片 2.设置站点配置_config.yml 1post_asset_folder: true","categories":[{"name":"博客","slug":"博客","permalink":"http://meijuna.github.io/categories/博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://meijuna.github.io/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"http://meijuna.github.io/tags/博客/"}]},{"title":"Git 使用","slug":"Git-使用","date":"2019-06-18T11:24:38.002Z","updated":"2019-06-18T13:08:21.382Z","comments":true,"path":"2019/06/18/Git-使用/","link":"","permalink":"http://meijuna.github.io/2019/06/18/Git-使用/","excerpt":"","text":"git 操作git checkout -- file可以丢弃工作区的修改 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 git status命令看看结果： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看： git diff 比较的是工作区文件与暂存区文件的区别（上次git add 的内容）git diff –cached 比较的是暂存区的文件与仓库分支里（上次git commit 后的内容）的区别 ———————–版本库——————————————–| |​ git diff –cached （是只比较暂存区和版本库的区别） || |————-暂存区———————- git diff HEAD （只比较工作区和版本库（最后一次commit）的区别）|​ git diff （工作区和暂存区（最后一次add）） || |—–工作区————————————————————– 123456789$ git diff readme.txt diff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software. git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add： 版本回退在Git中，我们用git log命令显示从最近到最远的提交日志： 123456789101112131415161718$ git logcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPLcommit e475afc93c209a690c39c13a46716e8fa000c366Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:03:36 2018 +0800 add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： 1234$ git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file 好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是add distributed的那个版本，怎么做呢？ 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令： 12$ git reset --hard HEAD^HEAD is now at e475afc add distributed 还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态： 123456789101112$ git logcommit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:03:36 2018 +0800 add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file 最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本： 12$ git reset --hard 1094aHEAD is now at 83b0afe append GPL 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： 12345$ git refloge475afc HEAD@&#123;1&#125;: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPLe475afc HEAD@&#123;3&#125;: commit: add distributedeaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file 现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下： 12Git is a distributed version control system.Git is free software distributed under the GPL. 然后尝试提交： 1234$ git add readme.txt$ git commit -m &quot;append GPL&quot;[master 1094adb] append GPL 1 file changed, 1 insertion(+), 1 deletion(-) 像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。 现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了： 版本1：wrote a readme file 12Git is a version control system.Git is free software. 版本2：add distributed 12Git is a distributed version control system.Git is free software. 版本3：append GPL 12Git is a distributed version control system.Git is free software distributed under the GPL. 当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看： 123456789101112131415161718$ git logcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPLcommit e475afc93c209a690c39c13a46716e8fa000c366Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:03:36 2018 +0800 add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： 1234$ git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file 需要友情提示的是，你看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线： 好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是add distributed的那个版本，怎么做呢？ 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令： 12$ git reset --hard HEAD^HEAD is now at e475afc add distributed --hard参数有啥意义？这个后面再讲，现在你先放心使用。 看看readme.txt的内容是不是版本add distributed： 123$ cat readme.txtGit is a distributed version control system.Git is free software. 果然被还原了。 还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态： 123456789101112$ git logcommit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:03:36 2018 +0800 add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file 最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本： 12$ git reset --hard 1094aHEAD is now at 83b0afe append GPL 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 再小心翼翼地看看readme.txt的内容： 123$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL. 果然，我胡汉三又回来了。 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL： 改为指向add distributed： 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： 12345$ git refloge475afc HEAD@&#123;1&#125;: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPLe475afc HEAD@&#123;3&#125;: commit: add distributedeaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file 终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。 小结现在总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 撤销修改 git checkout – file 可以丢弃工作区的修改： 自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行： 123456$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 在你准备提交前，一杯咖啡起了作用，你猛然发现了stupid boss可能会让你丢掉这个月的奖金！ 既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 你可以发现，Git会告诉你，git checkout -- file可以丢弃工作区的修改： 1$ git checkout -- readme.txt 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 现在，看看readme.txt的文件内容： 12345$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 文件内容果然复原了。 git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了： 12345678$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.$ git add readme.txt 庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交： 123456$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.txt Git同样告诉我们，用命令git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区： 123$ git reset HEAD readme.txtUnstaged changes after reset:M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 再用git status查看一下，现在暂存区是干净的，工作区有修改： 1234567$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txt 还记得如何丢弃工作区的修改吗？ 12345$ git checkout -- readme.txt$ git statusOn branch masternothing to commit, working tree clean 小结又到了小结时间。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件 当你要删除文件的时候，可以采用命令：rm test.txt 这个时候有两种情况 第一种情况:的确要把test.txt删掉， 那么可以执行 git rm test.txt ​ git commit -m “remove test.txt” 文件被删除，且删除记录上传本地库 第二种情况:误删文件，想恢复，这时候还没有commit -m “remove test.txt”， 执行git checkout test.txt将文件恢复。 如果执行完git commit -m “remove test.txt”后就不能用checkout恢复了，得用git reset –hard HEAD^ 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容 远程库1$ git remote add origin git@github.com:meijuna/learngit.git 请千万注意，把上面的meijuna替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 12345678910$ git push -u origin masterCounting objects: 20, done.Delta compression using up to 4 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.Total 20 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5/5), done.To github.com:michaelliao/learngit.git * [new branch] master -&gt; masterBranch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 从现在起，只要本地作了提交，就可以通过命令： 1$ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ SSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： 123The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： 1Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 小结要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 初次安装git配置用户名和邮箱查看邮箱 和shh key是否设置： 12345$ git config user.name //查看用户名&amp;邮箱$ git config user.email$ ssh -T git@github.com //ssh 用户名和邮箱的作用： 用户名和邮箱地址相当于你的身份标识，是本地Git客户端的一个变量，不会随着Git库而改变。 每次commit都会用用户名和邮箱纪录。 github的contributions跟你的邮箱是有关联的。 1234567891011$ git config --global user.name &quot;meijuna&quot;$ git config --global user.email &quot;1914623558@qq.com&quot;$ git config user.name //查看用户名&amp;邮箱$ git config user.email$ git config --global user.name &quot;xxx&quot; //修改用户名邮箱$ git config --global user.email &quot;xxx&quot; git使用ssh密钥git支持https和git两种传输协议，github分享链接时会有两种协议可选： 1.git使用https协议，每次pull, push都会提示要输入密码 2.使用git协议，然后使用ssh密钥，这样免去每次都输密码的麻烦 初次使用git的用户要使用git协议大概需要三个步骤： 一、生成密钥对 二、设置远程仓库（本文以github为例）上的公钥 三、把git的 remote url 修改为git协议（以上两个步骤初次设置过以后，以后使用都不需要再次设置，此步骤视以后项目的remote url而定，如果以后其他项目的协议为https则需要此步骤） 一、生成密钥对大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥。 SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。进去看看 123$ cd ~/.ssh$ lsid_rsa id_rsa.pub key_backup/ known_hosts 看一下有没有id_rsa和id_rsa.pub(或者是id_dsa和id_dsa.pub之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。 假如没有这些文件，甚至连 .ssh 目录都没有，可以用 ssh-keygen 来创建： 1$ ssh-keygen -t rsa-C \"your_email@youremail.com\" //你的github绑定的邮箱 直接按Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码) 如果之后你出现了这个界面之后，就说明你的密匙已经成功创建了。现在你就需要去他刚刚显示的存储位置打开它，把其中的内容复制出来。 到此为止，你本地的密钥对就生成了。 二、添加公钥到你的远程仓库（github） 查看你的公匙 123$ cat ~/.ssh/id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0X6L1zLL4VHuvGb8aJH3ippTozmReSUzgntvk434aJ/v7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8vR3c8E7CjZN733f5AL8uEYJA+YZevY5UCvEg+umT7PHghKYaJwaCxV7sjYP7Z6V79OMCEAGDNXC26IBMdMgOluQjp6o6j2KAdtRBdCDS/QIU5THQDxJ9lBXjk1fiq9tITo/aXBvjZeD+gH/Apkh/0GbO8VQLiYYmNfqqAHHeXdltORn8N7C9lOa/UW3KM7QdXo6J0GFlBVQeTE/IGqhMS5PMln3 admin@admin-PC 登陆你的github帐户。点击你的头像，然后 Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key 然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，自己随便起个名字。 点击 Add key 完成以后，验证下这个key是不是正常工作： 1$ ssh -T git@github.com 如果出现 HI XXX 说明设置成功1Hi meijuna! You&apos;ve successfully authenticated, but GitHub does not provide shell access 三、修改git的remote url 使用命令 git remote -v 查看你当前的 remote url (远程仓库) 123$ git remote -vorigin https://github.com/someaccount/someproject.git (fetch)origin https://github.com/someaccount/someproject.git (push) 如果是以上的结果那么说明此项目是使用https协议进行访问的（如果地址是git开头则表示是git协议） 你可以登陆你的github，就像本文开头的图例，你在上面可以看到你的ssh协议相应的url 复制此ssh链接，然后使用命令 git remote set-url 来调整你的url。 1git remote set-url origin git@github.com:someaccount/someproject.git 然后你可以再用命令 git remote -v查看一下，url是否已经变成了ssh地址。 然后你就可以愉快的使用git fetch, git pull , git push，再也不用输入烦人的密码了 git 操作添加远程仓库1git remote add pb https://github.com/zhousg/letao.git 查看远程仓库123git remote -vpb https://github.com/zhousg/letao.git (fetch)pb https://github.com/zhousg/letao.git (push) 现在你可以在命令行中使用字符串 pb 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 git fetch pb： 12345678$ git fetch pbremote: Counting objects: 43, done.remote: Compressing objects: 100% (36/36), done.remote: Total 43 (delta 10), reused 31 (delta 5)Unpacking objects: 100% (43/43), done.From https://github.com/paulboone/ticgit * [new branch] master -&gt; pb/master * [new branch] ticgit -&gt; pb/ticgit 现在 Paul 的 master 分支可以在本地通过 pb/master 访问到 - 你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 Git 分支 中详细介绍什么是分支以及如何使用分支。） 从远程仓库中抓取与拉取1$ git fetch [remote-name] 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作 Git 分支 分支简介当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。 现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息） 做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。 Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它。 分支创建1234567891011查看分支：git branch创建分支：git branch &lt;name&gt;切换分支：git checkout &lt;name&gt;创建+切换分支：git checkout -b &lt;name&gt;合并某分支到当前分支：git merge &lt;name&gt;删除分支：git branch -d &lt;name&gt; 1git branch testing //创建testing分支 那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 HEAD 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。 指向当前所在的分支你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。 1234$ git log --oneline --decoratef30ab (HEAD, master, testing) add feature #32 - ability to add new34ac2 fixed bug #1328 - stack overflow under certain conditions98ca9 initial commit of my project 正如你所见，当前 “master” 和 “testing” 分支均指向校验和以 f30ab 开头的提交对象。 分支切换要切换到一个已存在的分支，你需要使用 git checkout 命令。 我们现在切换到新创建的 testing 分支去： 1git checkout testing 这样 HEAD 就指向 testing 分支了。 HEAD 指向当前所在的分支那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次： 12$ vim test.rb$ git commit -a -m 'made other changes' 现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。 HEAD 分支随着提交操作自动向前移动如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看： 1git checkout master 这条命令做了两件事。 一是使 HEAD 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing分支所做的修改，以便于向另一个方向进行开发。 分支切换会改变你工作目录中的文件 在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。 我们不妨再稍微做些修改并提交： 12$ vim test.rb$ git commit -a -m 'made other changes' 现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。 项目分叉历史可以简单地使用 git log 命令查看分叉历史。 运行 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。 1234567$ git log --oneline --decorate --graph --all* c2b9e (HEAD, master) made other changes| * 87ab2 (testing) made a change|/* f30ab add feature #32 - ability to add new formats to the* 34ac2 fixed bug #1328 - stack overflow under certain conditions* 98ca9 initial commit of my project 分支的新建与合并让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤： 开发某个网站。 为实现某个新的需求，创建一个分支。 在这个分支上开展工作。 正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理： 切换到你的线上分支（production branch）。 为这个紧急任务新建一个分支，并在其中修复它。 在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。 切换回你最初工作的分支上，继续工作。 新建分支首先，我们假设你正在你的项目上工作，并且已经有一些提交。 一个简单提交历史 现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 -b 参数的 git checkout 命令： 12$ git checkout -b iss53Switched to a new branch \"iss53\" 它是下面两条命令的简写： 12$ git branch iss53$ git checkout iss53 创建一个新分支指针你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，iss53 分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的 HEAD 指针指向了 iss53 分支） 现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 iss53 的修改混在一起，你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 master 分支。 但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit amending）），我们会在 储藏与清理 中看到关于这两个命令的介绍。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 master 分支了： 1$ git checkout master 这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。 接下来，你要修复这个紧急问题。 让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决： 123456$ git checkout -b hotfixSwitched to a new branch 'hotfix'$ vim index.html$ git commit -a -m 'fixed the broken email address'[hotfix 1fb7853] fixed the broken email address 1 file changed, 2 insertions(+) 基于 master 分支的紧急问题分支 hotfix branch你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的 master 分支来部署到线上。 你可以使用 git merge 命令来达到上述目的： 123456$ git checkout master$ git merge hotfixUpdating f42c576..3a0874cFast-forward index.html | 2 ++ 1 file changed, 2 insertions(+) 在合并的时候，你应该注意到了”快进（fast-forward）”这个词。 由于当前 master 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。 现在，最新的修改已经在 master 分支所指向的提交快照中，你可以着手发布该修复了。 关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 hotfix分支，因为你已经不再需要它了 —— master 分支已经指向了同一个位置。 你可以使用带 -d 选项的 git branch 命令来删除分支： 12$ git branch -d hotfixDeleted branch hotfix (3a0874c). 现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。 123456$ git checkout iss53Switched to branch \"iss53\"$ vim index.html$ git commit -a -m 'finished the new footer [issue 53]'[iss53 ad82d7a] finished the new footer [issue 53]1 file changed, 1 insertion(+) 你在 hotfix 分支上所做的工作并没有包含到 iss53 分支中。 如果你需要拉取 hotfix 所做的修改，你可以使用 git merge master 命令将 master 分支合并入 iss53 分支，或者你也可以等到 iss53 分支完成其使命，再将其合并回 master 分支。 分支的合并假设你已经修正了 #53 问题，并且打算将你的工作合并入 master 分支。 为此，你需要合并 iss53 分支到 master 分支，这和之前你合并 hotfix 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 git merge 命令： 123456$ git checkout masterSwitched to branch 'master'$ git merge iss53Merge made by the 'recursive' strategy.index.html | 1 +1 file changed, 1 insertion(+) 这和你之前合并 hotfix 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的工作祖先（C2），做一个简单的三方合并。 ​ 和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。 需要指出的是，Git 会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础；这和更加古老的 CVS 系统或者 Subversion （1.5 版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。 Git 的这个优势使其在合并操作上比其他系统要简单很多。 既然你的修改已经合并进来了，你已经不再需要 iss53 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。 1$ git branch -d iss53 遇到冲突时的分支合并有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 hotfix 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突： 1234$ git merge iss53Auto-merging index.htmlCONFLICT (content): Merge conflict in index.htmlAutomatic merge failed; fix conflicts and then commit the result. 此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件： 1234567891011$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run \"git commit\")Unmerged paths: (use \"git add &lt;file&gt;...\" to mark resolution) both modified: index.htmlno changes added to commit (use \"git add\" and/or \"git commit -a\") 任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子： 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html&lt;div id=\"footer\"&gt;contact : email.support@github.com&lt;/div&gt;=======&lt;div id=\"footer\"&gt; please contact us at support@github.com&lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html 上述的冲突解决方案仅保留了其中一个分支的修改，并且 &lt;&lt;&lt;&lt;&lt;&lt;&lt; , ======= , 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。 如果你想使用图形化工具来解决冲突，你可以运行 git mergetool，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突： 12345678910111213$ git mergetoolThis message is displayed because 'merge.tool' is not configured.See 'git mergetool --tool-help' or 'git help config' for more details.'git mergetool' will now attempt to use one of the following tools:opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emergeMerging:index.htmlNormal merge conflict for 'index.html': &#123;local&#125;: modified file &#123;remote&#125;: modified fileHit return to start merge resolution tool (opendiff): 等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 git status 来确认所有的合并冲突都已被解决： 12345678$ git statusOn branch masterAll conflicts fixed but you are still merging. (use \"git commit\" to conclude merge)Changes to be committed: modified: index.html 如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 git commit 来完成合并提交。 默认情况下提交信息看起来像下面这个样子： 12345678910111213141516171819Merge branch 'iss53'Conflicts: index.html## It looks like you may be committing a merge.# If this is not correct, please remove the file# .git/MERGE_HEAD# and try again.# Please enter the commit message for your changes. Lines starting# with '#' will be ignored, and an empty message aborts the commit.# On branch master# All conflicts fixed but you are still merging.## Changes to be committed:# modified: index.html# 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward： 1234$ git merge --no-ff -m &quot;merge with no-ff&quot; devMerge made by the &apos;recursive&apos; strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史： 1234567$ git log --graph --pretty=oneline --abbrev-commit* e1e9c68 (HEAD -&gt; master) merge with no-ff|\\ | * f52c633 (dev) add merge|/ * cf810e4 conflict fixed... 可以看到，不使用Fast forward模式，merge后就像这样： 分支管理现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。 git branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表： 1234$ git branch iss53* master testing 注意 master 分支前的 * 字符：它代表现在检出的那一个分支（也就是说，当前 HEAD 指针所指向的分支）。 这意味着如果在这时候提交，master 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 git branch -v 命令： 1234$ git branch -v iss53 93b412c fix javascript issue* master 7a98805 Merge branch 'iss53' testing 782fd34 add scott to the author list in the readmes --merged 与 --no-merged 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 git branch --merged： 123$ git branch --merged iss53* master 因为之前已经合并了 iss53 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。 查看所有包含未合并工作的分支，可以运行 git branch --no-merged： 12$ git branch --no-merged testing 这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败： 123$ git branch -d testingerror: The branch 'testing' is not fully merged.If you are sure you want to delete it, run 'git branch -D testing'. 如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 -D 选项强制删除它。 git stash保留现场git stash 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了 先说几个名词未被追踪的文件:指的是新建的文件或文件夹且还没加入到暂存区(新建的还没有被git add 过得)未加入到暂存区的文件:指的是已经被追踪过，但是没有加入到暂存区(已经执行过git add/commit的但是这次修改后还没有git add)举例:readme.md 已经被git add/git commit过，但是呢 我这次只是修改了，而且没有修改完，不能committest 新建的文件夹,没有被git add/git commit过有个急事需要处理,这时候我需要切换分支，去处理紧急任务,比如文中的举例去修改bug，正确的步骤:git add test（让git去追踪这个新文件）git stash保留现场如果我不执行这两个命令，那么我在修改BUG完成之后git status，就会发现readme.md 没有添加到暂存区，同时又多了个test文件,但是自己的readme.md没有完成，万万不可以提交，这样导致bug的修改代码也提交不了。所以你需要git stash，这样你在提交修改bug代码的时候 ，就不会看见readme.md 和 test。可以安心提交修改bug的代码。 Feature分支 没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。 于是准备开发： 12$ git checkout -b feature-vulcanSwitched to a new branch &apos;feature-vulcan&apos; 12345678910111213$ git add vulcan.py$ git statusOn branch feature-vulcanChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: vulcan.py$ git commit -m &quot;add feature vulcan&quot;[feature-vulcan 287773e] add feature vulcan 1 file changed, 2 insertions(+) create mode 100644 vulcan.py 切回dev，准备合并： 1$ git checkout dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 git branch -D feature-vulcan 强制删除未合并的分支 查看远程库的信息，用git remote123$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 1$ git push origin master 如果要推送其他分支，比如dev，就改成： 1$ git push origin dev master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 分支开发工作流 长期分支因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。 许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 develop 或者 next 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了。 这样，在确保这些已完成的特性分支（短期分支，比如之前的 iss53 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。 事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。 通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。 你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 proposed（建议） 或 pu: proposed updates（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 next 或者 master 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。 特性分支你已经在上一节中你创建的 iss53 和 hotfix 特性分支中看到过这种用法。 你在上一节用到的特性分支（iss53 和 hotfix 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。 考虑这样一个例子，你在 master 分支上工作到 C1，这时为了解决一个问题而新建 iss91 分支，在 iss91分支上工作到 C4，然而对于那个问题你又有了新的想法，于是你再新建一个 iss91v2 分支试图用另一种方法解决那个问题，接着你回到 master 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 C10的时候新建一个 dumbidea 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子： 现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 iss91v2 分支中方案；另外，你将 dumbidea 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢弃 C5 和 C6 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子： 创建标签 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息； 命令git tag可以查看所有标签。 在Git中打标签非常简单，首先，切换到需要打标签的分支上： 12345$ git branch* dev master$ git checkout masterSwitched to branch &apos;master&apos; 然后，敲命令git tag &lt;name&gt;就可以打一个新标签： 1$ git tag v1.0 可以用命令git tag查看所有标签： 12$ git tagv1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了： 12345678910111213141516$ git log --pretty=oneline --abbrev-commit12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 1014c805e2 fix bug 101e1e9c68 merge with no-fff52c633 add mergecf810e4 conflict fixed5dc6824 &amp; simple14096d0 AND simpleb17d20e branch testd46f35e remove test.txtb84166e add test.txt519219b git tracks changese43a48b understand how stage works1094adb append GPLe475afc add distributedeaadf4e wrote a readme file 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令： 1$ git tag v0.9 f52c633 再用命令git tag查看标签： 123$ git tagv0.9v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show &lt;tagname&gt;查看标签信息： 123456789$ git show v0.9commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:56:54 2018 +0800 add mergediff --git a/readme.txt b/readme.txt... 可以看到，v0.9确实打在add merge这次提交上。 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb 用命令git show &lt;tagname&gt;可以看到说明文字： 123456789101112131415$ git show v0.1tag v0.1Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 22:48:43 2018 +0800version 0.1 releasedcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPLdiff --git a/readme.txt b/readme.txt... 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 操作标签如果标签打错了，也可以删除： 12$ git tag -d v0.1Deleted tag &apos;v0.1&apos; (was f15b0dd) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin &lt;tagname&gt;： 1234$ git push origin v1.0Total 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git * [new tag] v1.0 -&gt; v1.0 或者，一次性推送全部尚未推送到远程的本地标签： 1234$ git push origin --tagsTotal 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git * [new tag] v0.9 -&gt; v0.9 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： 12$ git tag -d v0.9Deleted tag &apos;v0.9&apos; (was f52c633) 然后，从远程删除。删除命令也是push，但是格式如下： 123$ git push origin :refs/tags/v0.9To github.com:michaelliao/learngit.git - [deleted] v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。","categories":[{"name":"前端","slug":"前端","permalink":"http://meijuna.github.io/categories/前端/"}],"tags":[{"name":"git","slug":"git","permalink":"http://meijuna.github.io/tags/git/"}]},{"title":"开发工具","slug":"开发工具","date":"2019-06-18T11:17:05.236Z","updated":"2019-06-21T12:20:56.999Z","comments":true,"path":"2019/06/18/开发工具/","link":"","permalink":"http://meijuna.github.io/2019/06/18/开发工具/","excerpt":"","text":"VsCodesubline Text31.插件下载安装方法快捷键ctrl + shift + p, 打开sublime命令工具，输入 Install Package 2.插件1.格式化代码：html/css/js Prettify 格式化代码快捷键 Ctrl + Shift + H 2.vue语法高亮： vue-syntax-highlight","categories":[{"name":"工具","slug":"工具","permalink":"http://meijuna.github.io/categories/工具/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://meijuna.github.io/tags/vscode/"},{"name":"sublime，快捷键","slug":"sublime，快捷键","permalink":"http://meijuna.github.io/tags/sublime，快捷键/"}]},{"title":"npm 包管理工具","slug":"npm包管理工具","date":"2019-06-18T11:17:05.214Z","updated":"2019-06-18T05:41:26.215Z","comments":true,"path":"2019/06/18/npm包管理工具/","link":"","permalink":"http://meijuna.github.io/2019/06/18/npm包管理工具/","excerpt":"","text":"npm 包管理工具1. 什么是 npm ? npm是 Node 的包管理工具 ，是全球最大的开源库生态系统 官网 https://www.npmjs.com/ 2. 常见命令1234567891011121314151617181920初始化项目 $ npm init $ npm init --yes 默认配置 下载命令: npm init 初始化包管理文件 npm install 包名 下载 npm install 包名 -g 下载到全局 npm install 包名 --save-dev-- 包管理文件生成开发依赖 devDependencies:&#123;xxx:xxx&#125; npm install 包名 -d --save-dev--的简写 npm config ls 查看npm的默认配置 //开发环境使用 devDepencies -D === --save--dev // 生产环境使用 -S == --save 卸载命令: npm uninstall 包名 卸载本地包 npm unpublish 包名@版本号 卸载发布后的远程包 发布1小时内有效 3. 上传包1234567上传包: 1) 登入npm官方网站 www.npmjs.com 2) 注册 设置好邮箱 3) 在dos命令窗口登入npm adduser (注意密码输入不显示) 4) 发布包 npm publish 5) package.json中必备两个字段 name(包名) version(版本号) ps:如果发布的包名与npm官网重复会导致发布失败 2. 设置淘宝镜像 123456//1. 安装 cnpm 设置淘宝镜像 npm install -g cnpm --registry=https://registry.npm.taobao.org//2. 下载 nrm 用于切换源 cnpm install nrm -g nrm ls 查看当前源 nrm use xx 切换源 3. npm脚本123456789101112131415161718npm run build = node build.js 为什么使用npm 脚本： 命令会记录在build1. 集中存放当前项目的所有脚本命令2. 外接口，用户不同项目的脚本命令，只要功能相同，就可以是同样的3. 提供很多辅助功能（多个脚本执行(&amp;|$$) 通配符 *.js 以下npm 脚本可以简写 npm start np stop npm test npm restart 默认提供脚本：1. &quot;start&quot;: &quot;node server.js&quot;2. &quot;install&quot;: &quot;node-gyp rebuild&quot;3. &quot;build&quot;: &quot;node build.js&quot;钩子： pre和pst两个钩子 4. nvm node版本管理下载安装 nvm nvm-setup.zip nvm 命令 1234567nvm list #查看本地所有node版本nvm install 4.2.2 #安装 4.2.2 版本nvm use 4.2.2 #切换至 4.2.2 版本nvm uninstall 4.2.2 #卸载4.2.2 版本","categories":[{"name":"npm","slug":"npm","permalink":"http://meijuna.github.io/categories/npm/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://meijuna.github.io/tags/Node/"},{"name":"npm","slug":"npm","permalink":"http://meijuna.github.io/tags/npm/"}]},{"title":"Node 基础语法","slug":"Node基础要点","date":"2019-06-18T11:17:05.191Z","updated":"2019-06-18T05:41:20.999Z","comments":true,"path":"2019/06/18/Node基础要点/","link":"","permalink":"http://meijuna.github.io/2019/06/18/Node基础要点/","excerpt":"","text":"Node 基础语法 浏览器Javascript 不能做什么？ 访问数据库 不能对文件进行操作 不能对系统进行操作 原因是为了安全，和浏览器的运行机制有关 在开发人员能力相同的情况下编程语言的能力取决于什么？ 取决于平台， cordova hbuilder 平台 platform java java虚拟机 （运行平台） php php虚拟机 +c# .net framework mono +js 解析内核 chrome v8 1. node 特点什么是node ? Node.js 是一个运行在Chrome V8 引擎的JavaScript 的一个运行环境 Node.js使用了一个事件驱动、非阻塞式I/O的模型,使其轻量又高效 事件驱动： 任务执行，发布者，订阅者，事件驱动 （ on emit ） 非阻塞： 执行某一个任务的同时也可以执行其他任务 阻塞： 执行某一个任务，这个任务如果没有执行完成，其他任务必须等待 同步 异步 I/O: 输入/输出（ 数据库，文件系统操作等操作 ） 非阻塞I/O模型： 当我们使用Node.js来实现数据库操作、文件系统等操作时，要进行的异步操作，异步操作的核心传统实现方式就是回调函数 2. 服务器： 定义： 可以运行在服务端的一个网站（站点） 种类： web服务器（ 静态服务器 ），可以运行在浏览器中的服务器 api 服务器（ 后端接口 )，后端语言暴露一个数据接口，用于前端的请求 1. http 创建web服务器： http 模块 createServer( callback(request, response, [next]){ }) listen(port, host, callback) //监听服务器 （ 反馈服务器状态） 123456789101112131415161718192021222324252627282930 // 1. 引入http模块(对象) const http = reqiure('http'); //2. 通过httpP模块上的 createServer 这个api 创建一个函数 //3. 创建服务器端口和域名 const port = 8888; const host = 'localhost';//127.0.0.1 const server = http.createServer( (request, response) =&gt; &#123; response.writeHead(200, &#123; //设置响应头 'Content-Type': 'text/html;charset=UTFf8' &#125;) response.write('返回给客户端的数据');//向前台发送信息 response.end(); //发送已经结束 &#125;).listen( port, host, () =&gt; &#123; console.log(`The server running at:http://$&#123; host &#125; : $&#123; port &#125; `) &#125;); ps:因为浏览器在请求时会默认发送favicon.ico图标请求,如需阻止在http回调函数里环境里判断阻止代码示例: if(request.url.indexOf(\"favicon.ico\") === -1)&#123; return false; &#125;;ps:关于设置响应头解析类型的设置 \"Content-type\":\"text/html;charset=utf-8\" 解析HTML标签以及属性 \"text/plain\" 纯文本 \"text/css\" 解析css \"text/javascript\" 解析js \"text/png\" 解析图片 \"text/json\" json数据 \"......\" 2. express 来创建api服务器12345678app.get(路由路径，(路由回调函数(路由中间件),next) =&gt; &#123; &#125;)const express = require('express');const app = express() //创建了一个app对象app.get('/', (req, res, next) =&gt; &#123;&#125;)app.listen(port, hostname, () =&gt; &#123; //创建一个服务器 console.log(`The server is runinng at:http://$&#123; hostname&#125;:$&#123; port &#125;`)&#125;) 3. Node 中文乱码问题解决：1. 设置请求头123response.writeHead(200, &#123; 'Content-Type': 'text/html;charset=UTF8' &#125;) 2. 发送 response.write()1response.write('&lt;meta charset=UTF-8&gt;') 3. toString()1对二进制有效：将二进制 -》 toSrgin() 4. Node 实时监听(自动刷新)借助第三方工具： nodemon [ 推荐 ] supervisor 5. commonJS规范 CommonJs 规范的提出，主要是为了弥补 javascript 没有标准的缺陷，希望javascript 能在任何地方运行，能向java和Python具有开发大型应用的基础能力，可不是停留在脚本程序的阶段。 commonJS规范思想 是单独的文件就是一个模块,每一个模块都是一个独立的作用域 每个文件对外接口都是module.exports对象 1. CommonJs的模块规范CommonJS对模块的定义主要分为： 1. 模块定义1234567//1. 模块定义const student = &#123; //可以是对象(可以传多个)、函数、字符串 name: 'meijuna', jineng () &#123; console.log('I cn fly'); &#125;&#125; 2. 模块导出123456//2. 模块导出module.exports = student; //安全性不高，只能到处多个module.exports = &#123; //更安全，批量导出 student, fn&#125;; 3. 模块引用123//3. 模块引用const student = require('./xx.js'); // orconst &#123; student, fn &#125; = requie('./xx.js); //可以按需引用 2. 模块标识符主要分类：1. 内置模块 （http、fs)1）url 模块：处理 urlURL模块提供了三种处理path的方法 123456789101112131415161718192021222324252627281) 将path字符类型转成对象left url = \"http://user:pass@host.com:8080/p/a/t/h?query=string#hash\";url.parse(url,[可选布尔值],[可选项布尔值]); &#123; 单词解释 解析属性 属性解释 协议 protocol:\"http:\", 协议 斜线 slashes:true, 是否有// 认证 auth:\"user:pass\", 用户名与密码 主机 host:\"host.com:8080\", 主机 接口 port:\"8080\", 端口 主机名 hostname:\"host.com\", 域名 搞砸 hash:\"#hash\", 片段标识符,指向html页面某个dom元素的id 搜索 search:\"?query=string\", ? + 查询字符串 查询 query:\"query=string\", 查询字符 路径名 pathname:\"/p/a/t/h\", 端口号和?之间的 路径那部分 路径 path:\"/p/a/t/h?query=string\", pathname + search 水平基准 href:全路径url 原始路径 &#125; 2) 将对象转成url字符串 url.format(obj) ps:参考结合parse方法; 3) 替换或者替换(未验证) url.resolve(from,to) from 源地址 to 需要添加或替换的标签 ps:form源地址末尾有/就是添加 没有就是替换 具体待验证 2) fs 模块fs 模块是专门处理操作磁盘文件,特点每个方法都有同步和异步两种 (需注意:同步以sync结尾) 123456789101112131415161718192021222324252627282930313233读取文件: fs.readFile(\"文件路径\",&#123;opt&#125;,function(err,data)&#123; &#123;opt&#125;:可选项 encoding:\"utf-8\" 以utf-8国际编码读取文件内容 flag:\"r+\" read的简称,只读取文件,不存在即报错 flag:\"w+\" write的简称,读写文件,不存在则自动创建 err:errorObject 报错机制 一般用if判断用throw抛出错误 列: if(err)&#123; throw err &#125; ps:console.error() 抛出错误,不影响程序执行 data:成功读取的数据,是以buffer数据二进制存储格式存在 ps:data.toString()可以转成UTF-8格式,等价于可选项中的encoding:\"utf-8\"; &#125;); 写入文件: fs.writeFile(\"写入路径\",\"内容数据\",&#123;opt&#125;,function(err)&#123;&#125;); 追加内容: fs.appendFile(\"追加文件路径\",\"内容数据\",function()&#123;&#125;); 读取文件夹: fs.readdir(\"文件夹路径\",function(err,paths)&#123; ps:readdir是directory的缩写 paths:成功读取文件夹 用数组存储文件内容 &#125;) 创建文件夹: fs.mkdir(\"文件夹路径,同时也是文件夹名称\",function(err)&#123;&#125;) 3）path 模块1234拼接路径: join(xx,xx,xxx,.）使用平台特定的分隔符,将所有给定的段连接在一起 ps:常用到的路径 __dirname 当前执行文件所在的绝对路径 4）querystring 模块querystring模块一般是对 http 请求的 URL 所带的数据进行解析处理 123456789101112131415161718191) 格式数据格式化为字符串:stringify let objData = &#123; name:\"skye\", url:\"http://skyelovedj.com\" &#125; let querystring = require(\"querystring\"); querystring.stringify(objData,\"分隔符\",\"分配符\")2) 将参数字符格式为对象: let strData = \"name:skye&amp;age=18\" let querystring = require(\"querystring\"); querystring.parse(strData,\"分隔符\",\"分配符\") ps:分隔符和分配符是可选项3) 编码: querystring.escape(\"data\") 只对符号与中文编码 4) 解码: querystring.Unescape(\"data\") 只对符号与中文解码 5) zlib制作压缩包的模块 流 * 可读的流： 可以通过文件系统读取的流 （ 数据流 ） * 可写的流： 可以通过文件系统写入的流 * 管道流 ： 连通两个文件的通道 pipe 12345678910111213const fs = require( 'fs' );const zlib = require( 'zlib'); //制作压缩包的模块//创建可读的流const readStream = fs.createReadStream('./a.txt' );//创建空压缩包const gzib = zlib.createGzip();//创建可写的流const writeStream = fs.createWriteStream('./b.text.gz');//创建流程readStream .pipe( gzib ) .pipe( writeStream ); 2. 第三方模块3. 自定义模块6. 发送数据请求： http.request request(封装 http-request 的第三方包) http.get(options, (res) =&gt;{ }) 7. 前端模块化为什么前端要使用模块化： 模块化：具有特定功能的一个对象(广义理解) 模块定义的流程： 1. 定义模块 2. 导出模块 3. 应用模块 好处： 1. 可以存储多个独立的功能块 2. 复用性高 种类： 1. ADM （ require.js ) 1234567define(&#123; a:1, b:2 &#125;) require([./a.js], function( moduleA ) &#123; //moduleA指的是 &#125;) CMD ( sea.js ) 12345define(function(require, exports, module )&#123; &#125;) require('./b.js', function( moduleB )&#123; //moduleB就是b模块中导出的内容 &#125;) Common.js （ require.js ） 12345678910111213141516171819Node 使用了 Common.js 的规范/*目录结构： name.js index.js *///模块定义 name.jsconst nameObj = &#123; name: 'MeiJuna'&#125;//模块导出module.exports = nameObj;//模块引用const nameObj = require('./nameObj)Node中Common.规范使用的三种类型： 1. 内置模块 (指的是挂载在Node全局对象身上的 api ) 2. 自定义模块 3. 第三方模块 7. 跨域问题前端跨域1. jsonp2. 反向代理（前端创建一个虚拟后端服务器，后台服务器帮助我们跨域） 后端跨域1. 设置响应头12res.setHeader(&apos;Access-Control-Allow-Origin&apos;, req.headers.origin);// req.headers.origin = http://127.0.0.1:5500/ 2. 使用第三方中间件 (cors)123456app.use( cors(&#123; \"origin\": \"*\", \"methods\": \"GET,HEAD,PUT,PATCH,POST,DELETE\", \"preflightContinue\": false, \"optionsSuccessStatus\": 200&#125;)) 中间件: 就是具有一定功能的函数 8. 前端的异步流程异步流程的任务是放在异步队列中的， 传统的原始异步 异步函数 事件 使用异步流程工具 （ 别人封装好的东西 ) es6 Promise 对象 all :依次执行完再执行 race: 谁快谁执行 es6 generator 函数 1234567891011121314151617在function 关键字后加一个 * * 通过 yield关键字定义任务 * fn().next() 来执行任务 结果返回一个对象 &#123;value: &apos;任务结果&apos;, done: false &#125; value表示 yield关键字有任务执行的结果 done 表示当前定义的所有的任务十分执行完整的一种状态 * 理解： -多任务的定义，多任务执行 -让自己定义的多个任务一次执行，上一个任务如果没有完成，下一个任务就不会开始 function* fn() &#123; yield &apos;任务1&apos; yield &apos;任务2&apos; return &apos;任务&apos; &#125; console.log( a.next()) console.log( a.next()); es6(7) async 函数 12345678910111213es6,7 * 配合关键字 await表示等待，await 任务1 执行结束才会 执行任务2 * 使用场景： 数据先请求，然后把结果赋值到变量 async function fn() &#123; const result = await &apos;任务1&apos;; console.log( &apos;任务二&apos; );&#125;2. 箭头函数的写法const fn1 = async () =&gt; &#123; const res = await &apos;任务3&apos;; console.log( res ); cosnole.log( &apos;任务4&apos; );&#125; node中的 nextTick() 和 setImmediate() ​​ nextTIck​ setImmediate​ ​ 轮询： 一个事件往复执行，那么每一次执行完成，我们就认为是个轮询​ 事件轮询前， 使用nextTick​ 事件轮询后， 使用setImmediate​ ​ * nextTick &gt; () =&gt; &gt; setImmediate ​ 第三方的 async.js 库 文档： async 12345678910 cnpm i yarn -g yarn add async -D- parallel: 并行- series ：串行,return 数组，任务都是完整正确的，如果一个任务失败，后面的任务也会失败 主线程 并行 parallel &#123; two: 2, one: 1 &#125; 串行 series &#123; one: 1, two: 2 &#125; 结论： 主线程先执行，然后 parallel (谁快谁先走),最后 series 并行 (上个运行完，在运行下一个) 9. socket 通信1. 基于后端的通信 ( pc ) node 中的 net 模块 服务器 123456789101112131415161718192021222324252627282930313233343536373839404142const net = require( 'net');const hostname = \"localhost\";const port = 9000;const clients = &#123;&#125;; //存储每一个客户端let count = 0; //给客户端编号//1. 创建服务器const server = new net.createServer()//2. 连接客户端server.on( 'connection', client =&gt; &#123; client.name = ++count; ///每个客户端起个名字 clients[ client.name ] = client; //将每一个客户端 都存储在 clients 中，key:client.name //3. 获取客户端发来的数据 client.on( 'data', msg =&gt; &#123; boardcast( client, msg.toString() ); console.log( `用户 $&#123; client.name &#125; 说: $&#123; msg.toString()&#125;` ) &#125;); //监听客户端的异常 client.on( 'error', error =&gt; &#123; console.log(`error is $&#123; error &#125;`); &#125;); //监听客户端的下线行为 client.on( 'close', () =&gt; &#123; //将下线的客户端清除 --清除 clents 对象 delete clients[ client.name ] console.log(`客户端$&#123; client.name &#125; closed~~`) &#125;)&#125;)//4. 将客户端发来的信息展示到自己终端上( 广播 ) function boardcast( client, msg) &#123; // 客户端 客户端发来的消息 for(var key in clients) &#123; clients[ key ].write( msg ); &#125;&#125;//5. 监听服务器server.listen( port, hostname, () =&gt;&#123; console.log(`The srerver is ruuing at:http://$&#123;hostname&#125;:$&#123;port&#125;`)&#125;) 客户端 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* 客户端： 1. 创建socket 2. socket连接服务器 3. 给服务器发送信息*/// 1. 创建socket const net = require( 'net' ); const socket = new net.Socket(); const port = 9000; const hostname = 'localhost'; const readline = require( 'readline' );//这是用来做命令行读取 const rl = readline.createInterface(&#123; input: process.stdin, output: process.stdout &#125;); // 2. socket连接服务器 socket.connect( port,hostname, () =&gt; &#123; //当我第一次连接好服务器之后，我给服务器发送一个我连接好的信息 socket.write( '欢迎xxx来到xxx的直播间' ) &#125;) //客户端监听自己的异常 socket.on( 'error', error =&gt; &#123; console.log( `socket error is $&#123; error &#125;` ) &#125;) socket.on( 'close' , () =&gt; &#123; console.log( `socket connection closed ~~~` ) &#125;)// 3. 给服务器发送信息 socket.on( 'data', msg =&gt; &#123; console.log( msg.toString() )//客户端自己显示写的内容 say() &#125;) function say () &#123; rl.question('请输入: ', ( answer ) =&gt; &#123; if( answer === 'bye' )&#123; //要进行命令行的结束 socket.destroy() //清除连接 rl.close()// 关闭命令行读取 &#125;else&#123; socket.write( answer ) &#125; &#125;); &#125; 2. 基于H5的 webSocket 来完成 ( 应用于移动端 )服务器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 主服务器 1. 通过ws模块来创建服务器 2. 服务器连接客户端 - 给客户端编号 3. 接收客户端发来的信息 4. 监听客户端下线*/// 1. 通过 ws模块 来创建服务器 const webSocket = require( 'ws' ); const ws = new webSocket.Server(&#123; port: 8000, host: '10.31.161.48' &#125;)// 2. 服务器连接客户端 const clients = &#123;&#125;; let count = 0; ws.on( 'connection', client =&gt; &#123; // - 给客户端编号 client.name = ++count; clients[ client.name ] = client //接收客户端发来的数据 client.on( 'message', msg =&gt; &#123; console.log( `客户端 $&#123; client.name &#125;说：$&#123; msg &#125;`) boardcast( client,msg ) &#125;) // 4. 监听客户端下线 client.on( 'close', () =&gt; &#123; delete clients[ client.name ] console.log( `客户端 $&#123; client.name &#125; closed~~` ) &#125;) &#125;) function boardcast ( client,msg ) &#123; for( var key in clients )&#123; clients[ key ].send( msg ) &#125; &#125; 客户端 1234567891011121314151617181920212223242526/* 客户端连接服务器文件 \\(^o^)/~ h5 提供了一个 Socket 的全局对象*/ const ws = new WebSocket( 'ws://10.31.161.48:8000' ) ws.onopen = () =&gt; &#123; ws.send( '欢迎来到xxx的直播间' ) &#125; ws.onmessage = ( msg ) =&gt; &#123; const content = document.querySelector( '#content' ); content.innerHTML += msg.data + '&lt;br/&gt;' &#125; ws.onerror = ( error ) =&gt; &#123; if( error )&#123; console.log( error ) &#125; &#125; ws.onclose = () =&gt; &#123; console.log( `xxx下线了` ) &#125; 3. 低版本浏览器使用的 socket.io","categories":[{"name":"Node","slug":"Node","permalink":"http://meijuna.github.io/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://meijuna.github.io/tags/Node/"},{"name":"语法","slug":"语法","permalink":"http://meijuna.github.io/tags/语法/"}]},{"title":"express Node 核心框架","slug":"express框架","date":"2019-06-17T13:50:29.972Z","updated":"2019-06-18T05:40:34.721Z","comments":true,"path":"2019/06/17/express框架/","link":"","permalink":"http://meijuna.github.io/2019/06/17/express框架/","excerpt":"","text":"express Node 核心框架express是一个功能极简, 完全是由路由和中间件构成的一个web开发框架,是非侵入式的框架 1. 为什么要学习 express ?- express 是 Node 的核心框架 - express 可以帮助我们快速构建 web 服务器 / api 服务器 - express 提供了一个快速生成工具 express-generator - 快速生成工具： 帮助我们快速创建一个项目的工具 2. 安装方式1. 全局安装123$ npm i express-generator -g or $ yarn add express-generator -g 2. npx 安装12345(如果npm版本在 5.2+，那可以不用全局，用npx)$ npx express -e express_demo -e : 指的是我们使用一个叫 ejs 的模板（ejs.js 可以兼容html标签, 可以在标签中写 js ） 3. 项目目录 bin www 启动了一个静态服务器 （ web服务器 ） node_modules 这个项目的依赖包 public 静态资源文件 ( html，css，images) routes 路由文件夹 view xxx.ejs （ 项目模板 ) app.js ( 这个项目的入口文件 ) 4. app.js 文件代码解读- app对象的功能 1. 通过app.use来使用具有特定功能的函数 ( 又叫中间件 ) - 中间件分类 1. 应用中间件 （ cors ) 2. 路由中间件 app.get( &apos;/&apos; , (req, res, next ) =&gt; { } ) 3. 错误处理中间件 function( err, req, res, next ) { } 5. express 创建 api 服务器 （ 创建接口 ） api 服务器是给前端提供接口数据 api 服务器需要使用的给测试工具来测试，不能用浏览器展示 注意： 后端个前端发送的数据类型是 JSON 字符串，前端需要 JSON.parse() 转换成对象 6. restful api 规则​ restful aip 规则 是一个暴露接口的规则 ，实现是一个接口使用不同的数据请求方式来实现不同的功能 7. 数据请求格式1. get 发送数据时，携带的参数时，形式是 Query string Parameters 后端 req.query 获取前端传来的数据 2. post 发送数据时，携带的参数时，形式是 Form Data 前端 req.body 获取前端传来的数据 8. ecj 模板ecj 官网 EJS 是一套简单的模板语言，帮你利用 JavaScript 代码生成 HTML 页面。 12345ejs模板语法: &lt;% jsCode %&gt; 执行正常js代码 &lt;% =data %&gt; 转移输出 &lt;% -&quot;data&quot; %&gt; 非转义输出","categories":[{"name":"express","slug":"express","permalink":"http://meijuna.github.io/categories/express/"}],"tags":[{"name":"框架","slug":"框架","permalink":"http://meijuna.github.io/tags/框架/"},{"name":"Node","slug":"Node","permalink":"http://meijuna.github.io/tags/Node/"}]},{"title":"面试","slug":"面试","date":"2019-04-14T08:30:09.000Z","updated":"2019-06-21T12:15:09.311Z","comments":true,"path":"2019/04/14/面试/","link":"","permalink":"http://meijuna.github.io/2019/04/14/面试/","excerpt":"","text":"1.工作技能要求1234567891011121314招聘岗位：高级前端开发工程师薪资：12k - 20k职位描述：根据产品需求和设计完成前端页面代码，实现交互效果与后台工程师协作，完成数据交互、动态信息展现维护及优化网站前端页面执行性能和加载性能，优化前端代码规范能够有效地解决实际开发问题，与后台技术开发保持良好沟通，快速理解、消化各方需求，并落实为具体的开发工作职位要求：熟练运用 html5/css3 布局，具备一定的审美能力和观察能力，能快速精确的还原设计稿(PS/Sketch)，有移动端项目开发经验代码结构清晰，javascript 基础扎实，熟悉掌握任意一门前端 MV*框架，如 vueJS、reactJS 等对前端组件化、模块化、工程化有深入的见解和实践熟悉前端构建工具基本用法（ webpack、gulp、grunt ）熟悉 CSS 预处理 LESS/SASS 等有 github 项目经验者优先，请附上 github 或 个人博客地址 2.题目123456789101112131415161718192021222324252627网络通信协议有哪些？TCP三次握手说的越详细越好。服务器代理为啥能实现跨域？src为啥不受同源策略影响？301和303有啥区别？304是怎么产生的？我就缓存和几个状态码第三次握手的必要性delete. Post. Trace. Head. 这些请求问vue和jq你了解过吗问我期望薪资的时候，vue让你封装一个表格组件什么场景？有什么功能，需求是什么以前的技术栈?react15和ng2vue框架中你能一般使用什么uielement-ui iview vant 人事问题12345678910我今天来到这里很不容易，路途比较远，我知道我可能不太符合公司的岗位需求，我想知道我刚才说的，我想向你请教下，如果今天能和您学习，我虽然拿不到 offer ,当是我觉得今天的面试没有浪费时间， 而且向你学到了很多知识。 目的： 希望得到反馈我希望我的领导给我更多的知道，当我在工作中有错误的地方，能够及时的提醒我沟通？认同 接收你的职业规划？我希望我能学到更多的技术，提高自己的技能，在1到3年内从初级软件开发工程师向高级软件开发工程师转变，争取向技术总监的岗位转变，","categories":[{"name":"面试","slug":"面试","permalink":"http://meijuna.github.io/categories/面试/"}],"tags":[]},{"title":"Ajax,jQuery ajax,axios和fetch的区别","slug":"Ajax,jQuery ajax,axios和fetch的区别","date":"2019-04-14T08:30:09.000Z","updated":"2019-06-21T13:21:35.195Z","comments":true,"path":"2019/04/14/Ajax,jQuery ajax,axios和fetch的区别/","link":"","permalink":"http://meijuna.github.io/2019/04/14/Ajax,jQuery ajax,axios和fetch的区别/","excerpt":"","text":"Ajax,jQuery ajax,axios和fetch的区别 12345678910Ajax： ajax，最早出现的发送后端请求技术，隶属于原始js中，核心使用XMLHttpRequest对象，多个请求之间如果有先后关系的话，就会出现回调地狱。Jquery Ajax： 是jQuery框架中的发送后端请求技术，由于jQuery是基于原始的基础上做的封装，所以，jquery Ajax自然也是对原始ajax的封装Fetch： fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是，一定记住fetch不是ajax的进一步封装，而是原生js。Fetch函数就是原生js，没有使用XMLHttpRequest对象。axios： axios不是原生JS的，需要进行安装，它不但可以在客户端使用，而且可以在nodejs端使用。Axios也可以在请求和响应阶段进行拦截。同样也是基于promise对象的。 Ajax 前端程序员常说的Ajax是 Asynchronous JavaScript and XML的缩写，意思是异步网络请求。区别于传统web开发中采用的同步方式。 Ajax带来的最大影响就是页面可以无刷新的请求数据。以往，页面表单提交数据，在用户点击完”submit“按钮后，页面会强制刷新一下，体验十分不友好。 fetch代表着更先进的技术方向，但是目前兼容性不是很好，在项目中使用的时候得慎重。 实现一个Ajax 请求 12345678910111213141516var request = new XMLHttpRequest() ; //创建XMLHttpRequest()request.onreadystatcechange = function () &#123; if ( request.readyState === 4) &#123; // 状态发生变化时，函数被回调 if (request.status === 200) &#123; return success(request.responseText); // 成功，通过responseText拿到响应的文本: &#125; else &#123; //失败，更具响应码判断失败原因： return fail(request.status); &#125; &#125; else &#123; //HTTP请求还在继续... &#125;&#125;request.open(&apos;GET&apos;, &apos;/api/categories&apos;);request.setRequestHeader(&quot;Content-Type&quot;, &quot;application/json&quot;) //设置请求头request.send(); //到这一步，请求才正式发出 使用原生的js还是比较繁琐，实际工程中建议使用jQuery之类的库，封装的ajax请求方法非常好用，且解决了浏览器兼容性的问题。 jQuery ajax12345678$.ajax(&#123; type: &apos;POST&apos;, url: url, data: data, dataType: dataType, success: function () &#123;&#125;, error: function () &#123;&#125;&#125; 优缺点 ​本身是针对MVC的编程,不符合现在前端MVVM的浪潮 基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案 JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务） axiosAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，有以下特点： 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 123456789101112131415postData () &#123; let params = new URLSearchParams() //用来接收参数 params.append( 'a', 2); params.append( 'b', 1); axios( &#123; url: 'http://localhost/post', method: 'post', headers: &#123; 'Content-Type': \"application/x-www-form-urlencoded\" &#125;, data: params &#125;) .then( res =&gt; console.log( res )) .then( error =&gt; console.log( error )) &#125; 优缺点 设计简洁，API简单，支持浏览器和node， 从 node.js 创建 http 请求 支持 Promise API 客户端支持防止CSRF 提供了一些并发请求的接口（重要，方便了很多的操作） PS:防止CSRF:就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，假冒的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。 fetchfetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是，一定记住fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。 使用fetch获取数据的例子 12345678910111213141516171819 //fetch get请求 getData () &#123; fetch(&apos;./data/data.josn&apos;) .then( res =&gt; res.json() ) //对数据进行格式化 .then( data =&gt; console.log( data ) ) //格式化后的数据 .catch( error =&gt; console.log( error ))&#125;//fetch post请求 fetch( &apos;http://localhost/post.php&apos;,&#123; method: POST, headers: new Headers(&#123; &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos; //指定提交方式为表单提交 &#125;), body: new URLSearchParams([[&quot;a&quot;,1],[&quot;b&quot;,2]]).toString() //携带参数 &#125;) .then( res = res.text() ) .then( data =&gt; console.log( data ));&#125; fetch要手动进行一次数据格式化，但是axios是内部进行了数据的格式化 fetch get 方法请求数据，参数要直接连接在url上 fetch 格式化数据 有三种 处理方法 .json() 格式化 json 类型数据， 将 json类型 string 转换成 json 对象 .text() 格式化文本 .blob() 格式化二进制数据 fetch 如果按照官网文档书写post请求，也有坑， 携带数据出现了问题 fetch post处理 设置请求头 通过 new URLSearchPrams 来携带参数 在使用fetch的时候需要注意： 当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。 默认情况下，fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）。 原文 https://www.toutiao.com/a6658039407179727374/?tt_from=weixin&amp;utm_campaign=client_share&amp;wxshare_count=1×tamp=1552952814&amp;app=news_article&amp;utm_source=weixin&amp;utm_medium=toutiao_ios&amp;group_id=6658039407179727374 https://blog.csdn.net/qq_36803558/article/details/81237753 .","categories":[{"name":"数据请求","slug":"数据请求","permalink":"http://meijuna.github.io/categories/数据请求/"}],"tags":[{"name":"ajax，axios，fetch","slug":"ajax，axios，fetch","permalink":"http://meijuna.github.io/tags/ajax，axios，fetch/"}]},{"title":"vue 基础语法","slug":"vue 基础语法","date":"2018-01-21T13:39:53.000Z","updated":"2019-06-21T13:42:54.857Z","comments":true,"path":"2018/01/21/vue 基础语法/","link":"","permalink":"http://meijuna.github.io/2018/01/21/vue 基础语法/","excerpt":"","text":"ECMAScript6 基础语法","categories":[],"tags":[]}]}