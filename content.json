{"meta":{"title":"Meijuna","subtitle":"没有比脚更长的路，走过去，前面是个天！","description":null,"author":"MeiJuna","url":"http://yoursite.com"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2018-12-24T12:20:30.995Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com//404.html","excerpt":"","text":""},{"title":"关于","date":"2018-12-25T02:31:36.149Z","updated":"2018-12-25T02:31:36.149Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"12345678910111213141516171819202122232425262728293031&#123; name: &apos;梅伟军&apos; age: 22, gender: &apos;男&apos;, profession: &apos;Web Developer&apos;, experience: &apos;应届毕业生&apos;, address: &apos;浙江省丽水市&apos;, education: &apos;专科&apos;, github: &apos;https://github.com/meijuna&apos;, blog: &apos;http://blog.meijuna.com&apos;, email: &apos;1914623558@qq.com&apos;, description: &apos;致力于网站建设与前端用户体验设计&apos;, skills: [ [&apos;Html&apos;, &apos;Javascript&apos;, &apos;jQuery&apos;, &apos;CSS&apos;, &apos;ES6&apos;, &apos;Node&apos;], [&apos;Webpack&apos;, &apos;Gulp&apos;], [&apos;Less&apos;,&apos;Sass&apos;], [&apos;Git&apos;], [&apos;Vue&apos;], [&apos;Bootstrap&apos;, &apos;SUI Mobile&apos;, &apos;light7&apos;], [&apos;平面设计&apos;] ], devTools: [ [&apos;Sublime Text&apos;, &apos;Visual Studio Code&apos;, &apos;Notepad++&apos;], [&apos;Chrome DevTools&apos;, &apos;Fiddler&apos;], [&apos;SourceTree&apos;, &apos;TortoiseSVN&apos;], [&apos;SwitchHosts&apos;], [&apos;Navicat&apos;], ] &#125;"},{"title":"书单","date":"2018-12-25T02:07:47.632Z","updated":"2018-12-25T02:07:47.632Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-12-24T12:20:31.015Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-12-24T12:20:31.015Z","updated":"2018-10-04T14:11:17.000Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-12-24T12:20:31.025Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-12-24T12:20:31.025Z","updated":"2018-10-04T14:11:17.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"设计思路","slug":"设计思路","date":"2019-03-28T05:06:11.000Z","updated":"2019-03-28T08:27:57.533Z","comments":true,"path":"2019/03/28/设计思路/","link":"","permalink":"http://yoursite.com/2019/03/28/设计思路/","excerpt":"","text":"1. 导航 123456实现： 鼠标移动图片选项选者框框 html: ul&gt;li&gt;a&gt;img span1. 设置 a display：bolck; width height1. 先给li添加白色背景 鼠标li:hover 再li添加background框框图片 2. 需要实现行内元素图片在li水平垂直居中：text-align:center; 垂直居中：设置span空标签为inle-block ,高度和li一样，span和img都设置 verticalalign: middel 实现垂直居中B: 也可以使用定位，margin来实现垂直居中","categories":[{"name":"设计思路","slug":"设计思路","permalink":"http://yoursite.com/categories/设计思路/"}],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"思路","slug":"思路","permalink":"http://yoursite.com/tags/思路/"}]},{"title":"Git 使用","slug":"Git-使用","date":"2019-01-03T00:53:13.558Z","updated":"2019-03-28T13:08:52.913Z","comments":true,"path":"2019/01/03/Git-使用/","link":"","permalink":"http://yoursite.com/2019/01/03/Git-使用/","excerpt":"","text":"git 操作git checkout -- file可以丢弃工作区的修改 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 git status命令看看结果： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看： git diff 比较的是工作区文件与暂存区文件的区别（上次git add 的内容）git diff –cached 比较的是暂存区的文件与仓库分支里（上次git commit 后的内容）的区别 ———————–版本库——————————————–| |​ git diff –cached （是只比较暂存区和版本库的区别） || |————-暂存区———————- git diff HEAD （只比较工作区和版本库（最后一次commit）的区别）|​ git diff （工作区和暂存区（最后一次add）） || |—–工作区————————————————————– 123456789$ git diff readme.txt diff --git a/readme.txt b/readme.txtindex 46d49bf..9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is free software. git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add： 版本回退在Git中，我们用git log命令显示从最近到最远的提交日志： 123456789101112131415161718$ git logcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPLcommit e475afc93c209a690c39c13a46716e8fa000c366Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:03:36 2018 +0800 add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： 1234$ git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file 好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是add distributed的那个版本，怎么做呢？ 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令： 12$ git reset --hard HEAD^HEAD is now at e475afc add distributed 还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态： 123456789101112$ git logcommit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:03:36 2018 +0800 add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file 最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本： 12$ git reset --hard 1094aHEAD is now at 83b0afe append GPL 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： 12345$ git refloge475afc HEAD@&#123;1&#125;: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPLe475afc HEAD@&#123;3&#125;: commit: add distributedeaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file 现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下： 12Git is a distributed version control system.Git is free software distributed under the GPL. 然后尝试提交： 1234$ git add readme.txt$ git commit -m &quot;append GPL&quot;[master 1094adb] append GPL 1 file changed, 1 insertion(+), 1 deletion(-) 像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。 现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了： 版本1：wrote a readme file 12Git is a version control system.Git is free software. 版本2：add distributed 12Git is a distributed version control system.Git is free software. 版本3：append GPL 12Git is a distributed version control system.Git is free software distributed under the GPL. 当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看： 123456789101112131415161718$ git logcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPLcommit e475afc93c209a690c39c13a46716e8fa000c366Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:03:36 2018 +0800 add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： 1234$ git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file 需要友情提示的是，你看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线： 好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是add distributed的那个版本，怎么做呢？ 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令： 12$ git reset --hard HEAD^HEAD is now at e475afc add distributed --hard参数有啥意义？这个后面再讲，现在你先放心使用。 看看readme.txt的内容是不是版本add distributed： 123$ cat readme.txtGit is a distributed version control system.Git is free software. 果然被还原了。 还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态： 123456789101112$ git logcommit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:03:36 2018 +0800 add distributedcommit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file 最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本： 12$ git reset --hard 1094aHEAD is now at 83b0afe append GPL 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 再小心翼翼地看看readme.txt的内容： 123$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL. 果然，我胡汉三又回来了。 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL： 改为指向add distributed： 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： 12345$ git refloge475afc HEAD@&#123;1&#125;: reset: moving to HEAD^1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPLe475afc HEAD@&#123;3&#125;: commit: add distributedeaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file 终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。 小结现在总结一下： HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 撤销修改 git checkout – file 可以丢弃工作区的修改： 自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行： 123456$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 在你准备提交前，一杯咖啡起了作用，你猛然发现了stupid boss可能会让你丢掉这个月的奖金！ 既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 你可以发现，Git会告诉你，git checkout -- file可以丢弃工作区的修改： 1$ git checkout -- readme.txt 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 现在，看看readme.txt的文件内容： 12345$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 文件内容果然复原了。 git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了： 12345678$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.$ git add readme.txt 庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交： 123456$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.txt Git同样告诉我们，用命令git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区： 123$ git reset HEAD readme.txtUnstaged changes after reset:M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 再用git status查看一下，现在暂存区是干净的，工作区有修改： 1234567$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txt 还记得如何丢弃工作区的修改吗？ 12345$ git checkout -- readme.txt$ git statusOn branch masternothing to commit, working tree clean 小结又到了小结时间。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件 当你要删除文件的时候，可以采用命令：rm test.txt 这个时候有两种情况 第一种情况:的确要把test.txt删掉， 那么可以执行 git rm test.txt ​ git commit -m “remove test.txt” 文件被删除，且删除记录上传本地库 第二种情况:误删文件，想恢复，这时候还没有commit -m “remove test.txt”， 执行git checkout test.txt将文件恢复。 如果执行完git commit -m “remove test.txt”后就不能用checkout恢复了，得用git reset –hard HEAD^ 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容 远程库1$ git remote add origin git@github.com:meijuna/learngit.git 请千万注意，把上面的meijuna替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 12345678910$ git push -u origin masterCounting objects: 20, done.Delta compression using up to 4 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done.Total 20 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5/5), done.To github.com:michaelliao/learngit.git * [new branch] master -&gt; masterBranch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 从现在起，只要本地作了提交，就可以通过命令： 1$ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ SSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： 123The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： 1Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 小结要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 初次安装git配置用户名和邮箱查看邮箱 和shh key是否设置： 12345$ git config user.name //查看用户名&amp;邮箱$ git config user.email$ ssh -T git@github.com //ssh 用户名和邮箱的作用： 用户名和邮箱地址相当于你的身份标识，是本地Git客户端的一个变量，不会随着Git库而改变。 每次commit都会用用户名和邮箱纪录。 github的contributions跟你的邮箱是有关联的。 1234567891011$ git config --global user.name &quot;meijuna&quot;$ git config --global user.email &quot;1914623558@qq.com&quot;$ git config user.name //查看用户名&amp;邮箱$ git config user.email$ git config --global user.name &quot;xxx&quot; //修改用户名邮箱$ git config --global user.email &quot;xxx&quot; git使用ssh密钥git支持https和git两种传输协议，github分享链接时会有两种协议可选： 1.git使用https协议，每次pull, push都会提示要输入密码 2.使用git协议，然后使用ssh密钥，这样免去每次都输密码的麻烦 初次使用git的用户要使用git协议大概需要三个步骤： 一、生成密钥对 二、设置远程仓库（本文以github为例）上的公钥 三、把git的 remote url 修改为git协议（以上两个步骤初次设置过以后，以后使用都不需要再次设置，此步骤视以后项目的remote url而定，如果以后其他项目的协议为https则需要此步骤） 一、生成密钥对大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先你要确认一下本机是否已经有一个公钥。 SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。进去看看 123$ cd ~/.ssh$ lsid_rsa id_rsa.pub key_backup/ known_hosts 看一下有没有id_rsa和id_rsa.pub(或者是id_dsa和id_dsa.pub之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。 假如没有这些文件，甚至连 .ssh 目录都没有，可以用 ssh-keygen 来创建： 1$ ssh-keygen -t rsa-C \"your_email@youremail.com\" //你的github绑定的邮箱 直接按Enter就行。然后，会提示你输入密码，如下(建议输一个，安全一点，当然不输也行，应该不会有人闲的无聊冒充你去修改你的代码) 如果之后你出现了这个界面之后，就说明你的密匙已经成功创建了。现在你就需要去他刚刚显示的存储位置打开它，把其中的内容复制出来。 到此为止，你本地的密钥对就生成了。 二、添加公钥到你的远程仓库（github） 查看你的公匙 123$ cat ~/.ssh/id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC0X6L1zLL4VHuvGb8aJH3ippTozmReSUzgntvk434aJ/v7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8vR3c8E7CjZN733f5AL8uEYJA+YZevY5UCvEg+umT7PHghKYaJwaCxV7sjYP7Z6V79OMCEAGDNXC26IBMdMgOluQjp6o6j2KAdtRBdCDS/QIU5THQDxJ9lBXjk1fiq9tITo/aXBvjZeD+gH/Apkh/0GbO8VQLiYYmNfqqAHHeXdltORn8N7C9lOa/UW3KM7QdXo6J0GFlBVQeTE/IGqhMS5PMln3 admin@admin-PC 登陆你的github帐户。点击你的头像，然后 Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key 然后你复制上面的公钥内容，粘贴进“Key”文本域内。 title域，自己随便起个名字。 点击 Add key 完成以后，验证下这个key是不是正常工作： 1$ ssh -T git@github.com 如果出现 HI XXX 说明设置成功1Hi meijuna! You&apos;ve successfully authenticated, but GitHub does not provide shell access 三、修改git的remote url 使用命令 git remote -v 查看你当前的 remote url (远程仓库) 123$ git remote -vorigin https://github.com/someaccount/someproject.git (fetch)origin https://github.com/someaccount/someproject.git (push) 如果是以上的结果那么说明此项目是使用https协议进行访问的（如果地址是git开头则表示是git协议） 你可以登陆你的github，就像本文开头的图例，你在上面可以看到你的ssh协议相应的url 复制此ssh链接，然后使用命令 git remote set-url 来调整你的url。 1git remote set-url origin git@github.com:someaccount/someproject.git 然后你可以再用命令 git remote -v查看一下，url是否已经变成了ssh地址。 然后你就可以愉快的使用git fetch, git pull , git push，再也不用输入烦人的密码了 git 操作添加远程仓库1git remote add pb https://github.com/zhousg/letao.git 查看远程仓库123git remote -vpb https://github.com/zhousg/letao.git (fetch)pb https://github.com/zhousg/letao.git (push) 现在你可以在命令行中使用字符串 pb 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 git fetch pb： 12345678$ git fetch pbremote: Counting objects: 43, done.remote: Compressing objects: 100% (36/36), done.remote: Total 43 (delta 10), reused 31 (delta 5)Unpacking objects: 100% (43/43), done.From https://github.com/paulboone/ticgit * [new branch] master -&gt; pb/master * [new branch] ticgit -&gt; pb/ticgit 现在 Paul 的 master 分支可以在本地通过 pb/master 访问到 - 你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 Git 分支 中详细介绍什么是分支以及如何使用分支。） 从远程仓库中抓取与拉取1$ git fetch [remote-name] 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作 Git 分支 分支简介当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。 现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息） 做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。 Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它。 分支创建1234567891011查看分支：git branch创建分支：git branch &lt;name&gt;切换分支：git checkout &lt;name&gt;创建+切换分支：git checkout -b &lt;name&gt;合并某分支到当前分支：git merge &lt;name&gt;删除分支：git branch -d &lt;name&gt; 1git branch testing //创建testing分支 那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 HEAD 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。 指向当前所在的分支你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。 1234$ git log --oneline --decoratef30ab (HEAD, master, testing) add feature #32 - ability to add new34ac2 fixed bug #1328 - stack overflow under certain conditions98ca9 initial commit of my project 正如你所见，当前 “master” 和 “testing” 分支均指向校验和以 f30ab 开头的提交对象。 分支切换要切换到一个已存在的分支，你需要使用 git checkout 命令。 我们现在切换到新创建的 testing 分支去： 1git checkout testing 这样 HEAD 就指向 testing 分支了。 HEAD 指向当前所在的分支那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次： 12$ vim test.rb$ git commit -a -m 'made other changes' 现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。 HEAD 分支随着提交操作自动向前移动如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看： 1git checkout master 这条命令做了两件事。 一是使 HEAD 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing分支所做的修改，以便于向另一个方向进行开发。 分支切换会改变你工作目录中的文件 在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。 如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。 我们不妨再稍微做些修改并提交： 12$ vim test.rb$ git commit -a -m 'made other changes' 现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。 项目分叉历史可以简单地使用 git log 命令查看分叉历史。 运行 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。 1234567$ git log --oneline --decorate --graph --all* c2b9e (HEAD, master) made other changes| * 87ab2 (testing) made a change|/* f30ab add feature #32 - ability to add new formats to the* 34ac2 fixed bug #1328 - stack overflow under certain conditions* 98ca9 initial commit of my project 分支的新建与合并让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤： 开发某个网站。 为实现某个新的需求，创建一个分支。 在这个分支上开展工作。 正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理： 切换到你的线上分支（production branch）。 为这个紧急任务新建一个分支，并在其中修复它。 在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。 切换回你最初工作的分支上，继续工作。 新建分支首先，我们假设你正在你的项目上工作，并且已经有一些提交。 一个简单提交历史 现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 -b 参数的 git checkout 命令： 12$ git checkout -b iss53Switched to a new branch \"iss53\" 它是下面两条命令的简写： 12$ git branch iss53$ git checkout iss53 创建一个新分支指针你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，iss53 分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的 HEAD 指针指向了 iss53 分支） 现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 iss53 的修改混在一起，你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 master 分支。 但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit amending）），我们会在 储藏与清理 中看到关于这两个命令的介绍。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 master 分支了： 1$ git checkout master 这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。 接下来，你要修复这个紧急问题。 让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决： 123456$ git checkout -b hotfixSwitched to a new branch 'hotfix'$ vim index.html$ git commit -a -m 'fixed the broken email address'[hotfix 1fb7853] fixed the broken email address 1 file changed, 2 insertions(+) 基于 master 分支的紧急问题分支 hotfix branch你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的 master 分支来部署到线上。 你可以使用 git merge 命令来达到上述目的： 123456$ git checkout master$ git merge hotfixUpdating f42c576..3a0874cFast-forward index.html | 2 ++ 1 file changed, 2 insertions(+) 在合并的时候，你应该注意到了”快进（fast-forward）”这个词。 由于当前 master 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。 现在，最新的修改已经在 master 分支所指向的提交快照中，你可以着手发布该修复了。 关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 hotfix分支，因为你已经不再需要它了 —— master 分支已经指向了同一个位置。 你可以使用带 -d 选项的 git branch 命令来删除分支： 12$ git branch -d hotfixDeleted branch hotfix (3a0874c). 现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。 123456$ git checkout iss53Switched to branch \"iss53\"$ vim index.html$ git commit -a -m 'finished the new footer [issue 53]'[iss53 ad82d7a] finished the new footer [issue 53]1 file changed, 1 insertion(+) 你在 hotfix 分支上所做的工作并没有包含到 iss53 分支中。 如果你需要拉取 hotfix 所做的修改，你可以使用 git merge master 命令将 master 分支合并入 iss53 分支，或者你也可以等到 iss53 分支完成其使命，再将其合并回 master 分支。 分支的合并假设你已经修正了 #53 问题，并且打算将你的工作合并入 master 分支。 为此，你需要合并 iss53 分支到 master 分支，这和之前你合并 hotfix 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 git merge 命令： 123456$ git checkout masterSwitched to branch 'master'$ git merge iss53Merge made by the 'recursive' strategy.index.html | 1 +1 file changed, 1 insertion(+) 这和你之前合并 hotfix 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的工作祖先（C2），做一个简单的三方合并。 ​ 和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。 需要指出的是，Git 会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础；这和更加古老的 CVS 系统或者 Subversion （1.5 版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。 Git 的这个优势使其在合并操作上比其他系统要简单很多。 既然你的修改已经合并进来了，你已经不再需要 iss53 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。 1$ git branch -d iss53 遇到冲突时的分支合并有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 hotfix 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突： 1234$ git merge iss53Auto-merging index.htmlCONFLICT (content): Merge conflict in index.htmlAutomatic merge failed; fix conflicts and then commit the result. 此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件： 1234567891011$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run \"git commit\")Unmerged paths: (use \"git add &lt;file&gt;...\" to mark resolution) both modified: index.htmlno changes added to commit (use \"git add\" and/or \"git commit -a\") 任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子： 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html&lt;div id=\"footer\"&gt;contact : email.support@github.com&lt;/div&gt;=======&lt;div id=\"footer\"&gt; please contact us at support@github.com&lt;/div&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html 上述的冲突解决方案仅保留了其中一个分支的修改，并且 &lt;&lt;&lt;&lt;&lt;&lt;&lt; , ======= , 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。 如果你想使用图形化工具来解决冲突，你可以运行 git mergetool，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突： 12345678910111213$ git mergetoolThis message is displayed because 'merge.tool' is not configured.See 'git mergetool --tool-help' or 'git help config' for more details.'git mergetool' will now attempt to use one of the following tools:opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emergeMerging:index.htmlNormal merge conflict for 'index.html': &#123;local&#125;: modified file &#123;remote&#125;: modified fileHit return to start merge resolution tool (opendiff): 等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 git status 来确认所有的合并冲突都已被解决： 12345678$ git statusOn branch masterAll conflicts fixed but you are still merging. (use \"git commit\" to conclude merge)Changes to be committed: modified: index.html 如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 git commit 来完成合并提交。 默认情况下提交信息看起来像下面这个样子： 12345678910111213141516171819Merge branch 'iss53'Conflicts: index.html## It looks like you may be committing a merge.# If this is not correct, please remove the file# .git/MERGE_HEAD# and try again.# Please enter the commit message for your changes. Lines starting# with '#' will be ignored, and an empty message aborts the commit.# On branch master# All conflicts fixed but you are still merging.## Changes to be committed:# modified: index.html# 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward： 1234$ git merge --no-ff -m &quot;merge with no-ff&quot; devMerge made by the &apos;recursive&apos; strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史： 1234567$ git log --graph --pretty=oneline --abbrev-commit* e1e9c68 (HEAD -&gt; master) merge with no-ff|\\ | * f52c633 (dev) add merge|/ * cf810e4 conflict fixed... 可以看到，不使用Fast forward模式，merge后就像这样： 分支管理现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。 git branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表： 1234$ git branch iss53* master testing 注意 master 分支前的 * 字符：它代表现在检出的那一个分支（也就是说，当前 HEAD 指针所指向的分支）。 这意味着如果在这时候提交，master 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 git branch -v 命令： 1234$ git branch -v iss53 93b412c fix javascript issue* master 7a98805 Merge branch 'iss53' testing 782fd34 add scott to the author list in the readmes --merged 与 --no-merged 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 git branch --merged： 123$ git branch --merged iss53* master 因为之前已经合并了 iss53 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。 查看所有包含未合并工作的分支，可以运行 git branch --no-merged： 12$ git branch --no-merged testing 这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败： 123$ git branch -d testingerror: The branch 'testing' is not fully merged.If you are sure you want to delete it, run 'git branch -D testing'. 如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 -D 选项强制删除它。 git stash保留现场git stash 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了 先说几个名词未被追踪的文件:指的是新建的文件或文件夹且还没加入到暂存区(新建的还没有被git add 过得)未加入到暂存区的文件:指的是已经被追踪过，但是没有加入到暂存区(已经执行过git add/commit的但是这次修改后还没有git add)举例:readme.md 已经被git add/git commit过，但是呢 我这次只是修改了，而且没有修改完，不能committest 新建的文件夹,没有被git add/git commit过有个急事需要处理,这时候我需要切换分支，去处理紧急任务,比如文中的举例去修改bug，正确的步骤:git add test（让git去追踪这个新文件）git stash保留现场如果我不执行这两个命令，那么我在修改BUG完成之后git status，就会发现readme.md 没有添加到暂存区，同时又多了个test文件,但是自己的readme.md没有完成，万万不可以提交，这样导致bug的修改代码也提交不了。所以你需要git stash，这样你在提交修改bug代码的时候 ，就不会看见readme.md 和 test。可以安心提交修改bug的代码。 Feature分支 没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。 于是准备开发： 12$ git checkout -b feature-vulcanSwitched to a new branch &apos;feature-vulcan&apos; 12345678910111213$ git add vulcan.py$ git statusOn branch feature-vulcanChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: vulcan.py$ git commit -m &quot;add feature vulcan&quot;[feature-vulcan 287773e] add feature vulcan 1 file changed, 2 insertions(+) create mode 100644 vulcan.py 切回dev，准备合并： 1$ git checkout dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 git branch -D feature-vulcan 强制删除未合并的分支 查看远程库的信息，用git remote123$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 1$ git push origin master 如果要推送其他分支，比如dev，就改成： 1$ git push origin dev master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 分支开发工作流 长期分支因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。 许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 develop 或者 next 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了。 这样，在确保这些已完成的特性分支（短期分支，比如之前的 iss53 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。 事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。 通常把他们想象成流水线（work silos）可能更好理解一点，那些经过测试考验的提交会被遴选到更加稳定的流水线上去。 你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 proposed（建议） 或 pu: proposed updates（建议更新）分支，它可能因包含一些不成熟的内容而不能进入 next 或者 master 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。 特性分支你已经在上一节中你创建的 iss53 和 hotfix 特性分支中看到过这种用法。 你在上一节用到的特性分支（iss53 和 hotfix 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在特性分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。 考虑这样一个例子，你在 master 分支上工作到 C1，这时为了解决一个问题而新建 iss91 分支，在 iss91分支上工作到 C4，然而对于那个问题你又有了新的想法，于是你再新建一个 iss91v2 分支试图用另一种方法解决那个问题，接着你回到 master 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 C10的时候新建一个 dumbidea 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子： 现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 iss91v2 分支中方案；另外，你将 dumbidea 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢弃 C5 和 C6 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子： 创建标签 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息； 命令git tag可以查看所有标签。 在Git中打标签非常简单，首先，切换到需要打标签的分支上： 12345$ git branch* dev master$ git checkout masterSwitched to branch &apos;master&apos; 然后，敲命令git tag &lt;name&gt;就可以打一个新标签： 1$ git tag v1.0 可以用命令git tag查看所有标签： 12$ git tagv1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了： 12345678910111213141516$ git log --pretty=oneline --abbrev-commit12a631b (HEAD -&gt; master, tag: v1.0, origin/master) merged bug fix 1014c805e2 fix bug 101e1e9c68 merge with no-fff52c633 add mergecf810e4 conflict fixed5dc6824 &amp; simple14096d0 AND simpleb17d20e branch testd46f35e remove test.txtb84166e add test.txt519219b git tracks changese43a48b understand how stage works1094adb append GPLe475afc add distributedeaadf4e wrote a readme file 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令： 1$ git tag v0.9 f52c633 再用命令git tag查看标签： 123$ git tagv0.9v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show &lt;tagname&gt;查看标签信息： 123456789$ git show v0.9commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:56:54 2018 +0800 add mergediff --git a/readme.txt b/readme.txt... 可以看到，v0.9确实打在add merge这次提交上。 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb 用命令git show &lt;tagname&gt;可以看到说明文字： 123456789101112131415$ git show v0.1tag v0.1Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 22:48:43 2018 +0800version 0.1 releasedcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPLdiff --git a/readme.txt b/readme.txt... 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 操作标签如果标签打错了，也可以删除： 12$ git tag -d v0.1Deleted tag &apos;v0.1&apos; (was f15b0dd) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin &lt;tagname&gt;： 1234$ git push origin v1.0Total 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git * [new tag] v1.0 -&gt; v1.0 或者，一次性推送全部尚未推送到远程的本地标签： 1234$ git push origin --tagsTotal 0 (delta 0), reused 0 (delta 0)To github.com:michaelliao/learngit.git * [new tag] v0.9 -&gt; v0.9 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： 12$ git tag -d v0.9Deleted tag &apos;v0.9&apos; (was f52c633) 然后，从远程删除。删除命令也是push，但是格式如下： 123$ git push origin :refs/tags/v0.9To github.com:michaelliao/learngit.git - [deleted] v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"前端笔记","slug":"HTML笔记","date":"2018-12-26T12:45:14.899Z","updated":"2019-03-28T12:57:12.622Z","comments":true,"path":"2018/12/26/HTML笔记/","link":"","permalink":"http://yoursite.com/2018/12/26/HTML笔记/","excerpt":"","text":"一、HTML123456背景不能继承background-image: url(&apos;&apos;);background-color: #000;background-position: top/bottom/left/right/center % pxbackground-repeat: no-repeat;background-attachment: fixed; 什是么网站？ ​ 网站(Website)开始是指在因特网上根据一定的规则，使用HTML等工具制作的用于展示特定内容相关网页的集合 什么是网页？ ​ 网页是一个包含HTML标签的纯文本文件，它可以存放在世界某个角落的某一台计算机中，是超文本标记语言格式文件扩展名为.html。 文字与图片是构成一个网页的两个最基本的元素。 1. WEB标准的概念及组成 结构： HTML- 超文本标记语言 (Hyper Text Markup Language) XHTML-可扩展超文本标记语言(EXtensible HyperText Markup Language) 表现： CSS-层叠样式表（Cascading Style Sheets） 行为： JavaScript-是轻量级的脚本语言 2. XHTM基本语法1、常规标记/双标记1&lt;标记 属性=“属性值” 属性=“属性值”&gt;&lt;/标记&gt; 2、空标记/单标记&lt;标记 属性=“属性值” /&gt; 说明： ​ 写在&lt;&gt;中的第一个单词叫做标记、标签、元素名。 ​ 标记和属性用空格隔开，属性和属性值用等号连接，属性值必须放在“”号内。 ​ 一个标记可以没有属性也可以有多个属性，属性和属性之间不分先后顺序。 ​ 空标记没有单独的结束标签，用“/”代替。 3. HTML5 基本结构123456789101112&lt;!doctype html&gt;文档类型声明&lt;html&gt;&lt;/html&gt;说明文档写的是标记语言 ，根标签&lt;head&gt;&lt;/head&gt;文件头部&lt;title&gt;&lt;/title&gt;文件标题（显示在状态栏上的内容）&lt;meta charset=\"utf-8\" /&gt;['metə]编码格式--meta标记用于定义文件信息，对网页文件进行说明，便于搜索引擎查找设置关键字等 &lt;body&gt;&lt;/body&gt;文件主体(所有要写的内容) 4. 标签(&lt;&gt;)（1）标签单双分类（根据有无单独的结束标签）：​ 1. 双标签（常规标签）：有单独的结束标签 ​ h1~h6 p b strong i em del sup sub s strike ul ol dl dt dd li a table tr td ​ div span ​ 2. 单标签（空标签）：没有单独结束标签 ​ br hr img ​ （2）元素行块分类（根据有没有自占一行进行分类的）：​ 1. 块状元素：自占一行： ​ h1~h6 p hr ul ol dl dt dd li table div del ​ 2.行内元素：宽度跟内容大小一致，并且可以跟其他的行内元素在一行内并列显示的： ​ b strong i em del s strike sup sub br img a imput buttom span （3）标签作用12345678910111213141516171819202122232425加粗：&lt;b&gt;定义粗体的文本&lt;/b&gt; //没有语义强调的意思，一般称为物理字体格式化标签&lt;strong&gt;把文本定义为语气更强的强调的内容&lt;/strong&gt; //有语意 强调倾斜：&lt;i&gt;显示斜体文本效果&lt;/i&gt; //没有语义强调的意思，一般称为物理字体格式化标签&lt;em&gt;把文本定义为强调的内容&lt;/em&gt; //有语意 强调删除标记：&lt;del&gt;&lt;s&gt;元素，已废弃，用来给文本加删除线(在HTML 4.01中废除)HTML5 重定义了 &lt;s&gt; 元素，现在是被用来定义那些不正确的文本。&lt;strike&gt; 定义加删除线文本(html5不推荐使用)sup ：上标文本 sub：下标文本**注：**语义强调作用的```&lt;strong&gt;&lt;em&gt;```比```&lt;b&gt;&lt;i&gt;```更容易引起搜索引擎的注意，但是如果只是为了加粗样式，建议在css样式表里面实现 **div标记** (division-部分)可定义文档中的分区或节,可以把文档分割为独立的、不同的部分作用：文档区域，文档布局对象**span标记**文本结点：用来组合文档中的行内元素 5. 列表（ul, ol, dl）HTML中有三种列表，分别是：无序列表(ul)，有序列表(ol)，自定义列表(dl) 1234567891011121314151617无序列表&lt;ul&gt;--unordered List &lt;li&gt;列表项内容&lt;/li&gt; … …&lt;/ul&gt;有序列表&lt;ol&gt;-ordered List &lt;li&gt;列表项内容&lt;/li&gt; … …&lt;/ol&gt;自定义列表 &lt;dl&gt;Definition List &lt;dt&gt;名词&lt;/dt&gt;Definition term &lt;dd&gt;解释&lt;/dd&gt;Definition Description&lt;/dl&gt; 6. 图片(img)1&lt;img src=\"目标文件路径及全称\" alt=\"图片替换文本\" title=\"图片标题\" /&gt; 1. src属性：规定显示图像的 URL 2. title属性: 在你鼠标悬停在该图片上时显示一个小提示，鼠标离开就没有了，HTML的绝大多数标签都支持title属性，title属性就是专门做提示信息的; 3. alt属性: 规定图像的替代文本。[ælt] olt 注:所要插入的的图片必须放在站点下 src==source所用图片的来源(路径) 7. 超链接(a)1&lt;a href=\"\" title=\"\" target=\"_blank\"&gt; 链接文本/图片&lt;/a&gt; 1. href属性：设置目标文件路径 2. title属性：超链接标题 3. target属性：设置超链接的打开方式 [‘tɑrɡɪt] 属性值：_blank-新窗口打开 [blæŋk] ​ _self-默认的打开方式（本窗口打开） ​ _top 在顶层WINDOW对象中打开,一般用于多层框架嵌套的情况​ _parent 在父窗口打开,一般用于框架内的窗口改变父窗口页面 [‘peər(ə)nt] Href== Hypertext Reference的缩写，意思是超文本引用 8. 表单(from) 作用：用来收集用户信息的： 123456&lt;form action=\"test.html\" method=\"post\" name=\"myFomr\"&gt; &lt;p&gt;&lt;input type=\"text\" name=\"userName\" maxlength=\"50\" placeholder=\"邮箱账号或手机账号\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"password\" name=\"userPassword\" placeholder=\"密码\"&gt;&lt;/p&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;input type=\"reset\" value=\"reset\"&gt;&lt;/form&gt; action属性：规定当提交表单时，向何处发送表单数据。’ækʃ(ə)n] method属性：规定如何发送表单数据（表单数据发送到 action 属性所规定的页面）浏览器使用method属性设置的方法将表单中的数据传送给服务器进行处理。共有两种方法：POST 方法和 GET 方法。[‘meθəd] 1.文本框(input)1&lt;input type=\"text\" name=\"uername\" value=\"内容\" placeholder=\"提示\" maxlength=\"20\"/&gt; type属性： 规定 input 元素的类型；（password，email，button）。 value属性: 为 input 元素设定值； name属性：规定 input 元素的名称。name 属性用于对提交到服务器后的表单数据进行标识，或者在客户端通过 JavaScript 引用表单数据，只有设置了name属性的表单元素才能在提交表单时传递它们的值。 placeholder属性：规定帮助用户填写输入字段的提示 maxlength属性：规定输入字段中的字符的最大长度 2. 按钮(button)1&lt;input type=&quot;button&quot; name=&quot;&quot; value=&quot;按钮内容&quot; /&gt; button和submit的区别： submit是提交按钮起到提交信息的作用，button只是一个按钮 9. 表格(table)作用：显示数据 123456789&lt;table width=\"600px\" height=\"400px\" border=\"3\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td rowspan=\"4\"&gt;第一个单元格&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td colspan=\"2\" rowspan=\"4\"&gt;&lt;/td&gt; &lt;td rowspan=\"4\"&gt;&lt;/td&gt; &lt;td rowspan=\"4\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; table: 标签定义HTML表格 tr: 元素定义表格行(table row) td: 元素定义表格单元(table data数据) border: “表格的边框” bordercolor:“表格边框颜色” cellspacing=0: 单元格与单元格之间的间距 cellpadding: 单元格与内容之间的空隙 ​ 水平对齐方式：align=”left/center/right”; ​ 垂直对齐方式： vertical-align=”top/middle/bottom”; ​ 注：对其方式在td,tr上使用 colspan: 所要合并的单元格的列数” 横向合并; rowspan: 所要合并单元格的行数” 纵向合并; 10. HTML和XHTML的语法区别123456XHTML 要求标签正确嵌套XHTML 所有标签必须关闭 /XHTML 区分大小写 XHTML 属性值要用双引号XHTML 用 id 属性代替 name 属性XHTML 特殊字符的处理 &amp;nbsp; &amp;lt; &amp;gt; 二、CSS基础1234white-space:pre nowrap //文本不进行换行知道text-overflow: //设置单行文本溢出是否显示省略号 clip 修剪文本 CSS (cascading style sheets)WEB标准中的表现标准语言,表现标准语言在网页中主要对网页信息的显示进行控制，简单说就是如何修饰网页的显示样式。—级联样式表、层叠样式表 语法：选择符 { 属性：属性值；属性：属性值 } 1.样式表分类(内部、外部、内嵌)1. 内部样式(style)1&lt;style type=\"text/css\"&gt;选择符 &#123; 属性：属性值；属性：属性值 &#125; &lt;/style&gt; 2. 外部样式(link)1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"目标文件路径\" /&gt; rel: 规定当前文档与被连接文档之间的关系 stylesheet: 样式表 type: 规定被链接文档的类型 href: 规定被链接文档的位置 3.外部样式表的导入-2(@import)123&lt;style type=\"text/css\"&gt; @import url(目标文件的路径就文件全称);&lt;/style&gt; 注：@和import之间没有空格 url和小括号之间也没有空格；必须结尾以分号结束 3.外部样式对比两种导入样式表的方法比较： link 属于 HTML 标签，而 @import 是 CSS 提供的。 页面被加载时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载。 @import 只在 IE 5 以上才能识别，而 link 是 HTML 标签，无兼容问题。 link 方式的样式的权重高于 @import 权重。 一般推荐使用 link 导入样式表的方法，@import 可以作为补充方法使用。 2. 选择器（选择符）1. 元素选择器/类型选择器（标签 )123语法：元素名称&#123;属性：属性值；&#125;说明：元素选择符就是以文档语言对象类型作为选择符，即使用结构中元素名称作为选择符。例如body、div、p,img,em,strong,span等。 2. id选择器 (#)123456语法：#id名&#123; &#125;&#123;属性：属性值;&#125; &lt;标记 id=\"名称1 名称2\" &gt;&lt;/标记&gt;说明：1） id属性值，在一个html文档中，必须是唯一的，不可重复，不能用关键字(所有的标记和属性都是关键字)2）一个id名称只能对应文档中一个具体的元素对象，因为id只能定义页面中某一个唯一的元素对象。3) 最大的用处：创建网页的外围结构 3. css选择器(.)1234567语法：.class名&#123;属性：属性值;&#125; &lt;标记 class=\"名称1 名称2\" &gt;&lt;/标记&gt;说明：1）class选择符更适合定义一类样式； 2） 一个标记可以设置多个class名3）class名可以重复4）限定标签类型 4. 群组选择器(,)123语法：选择器1，选择器2，选择器3&#123;属性：属性值;&#125;说明：当有多个选择符应用相同的样式时，可以将选择符用“，”分隔的方式，合并为一组 5. 后代选择器/包含选择器1234语法：选择器1 选择器2&#123;属性：属性值;&#125;说明：包含选择器选择器1和选择器2用空格隔开，含义就是选择符1中包含的所有选择器2; 6. 子选择器(&gt;)1234语法： 选择器1&gt;选择器2&#123;属性：属性值;&#125;说明：选择符1和选择符2用&gt;链接，选择符2必须是选择符1的子类 7. 伪类选择器(:hover)123456789语法 ： :link&#123;属性：属性值;&#125; //超链接的初始状态; :visited&#123;属性：属性值;&#125; //超链接被访问后的状态; ['vɪzɪtɪd] :hover&#123;属性：属性值;&#125; //鼠标悬停，即鼠标划过超链接时的状态; :active&#123;属性：属性值;&#125; //超链接被激活时的状态，即鼠标按下时超链接的状态; ['æktɪv] :focus //元素获得焦点的样式 ['fəʊkəs] 说明：1）当这4个超链接伪类选择符联合使用时，应注意他们的顺序，正常顺序为：a:link,a:visited,a:hover,a:active,错误的顺序有时会使超链接的样式失效； 2）使用与超链接相关的伪类选择符时，应为a元素定义href属性; 8. 通配符(*)1234567语法：*&#123;属性：属性值；&#125;说明：通配选择符的写法是“*”，其含义就是所有元素。用法：常用来重置样式全局样式*&#123;margin:0;padding:0;&#125;margin:0 auto; 让子元素相对父元素水平居中显示 3. 选择器的权重 12345678910111213内联 id class 标签 1 0 0 0# css中用四位数字表示权重，权重的表达方式如：0，0，0，0# id 0100# class选择器 （伪类选择符 :focus,:hover以及&lt;a&gt;:link） 0010 # 属性选择符的权重为 0010# 元素a 伪元素 :before、:after 0001# 后代选择符：1 2 = 1 + 2 # 子选择器 1 &gt; 2 = 1 + 2# 群组看选择符类型# *&#123;&#125;(通配符) 0 # 继承 0# 权重相同时，根据书写顺序而定，后书写的会把县书写的覆盖掉，会显示后书写的代码效果 4. CSS特性：(层叠性和继承性)层叠性：一个元素可能同时被多个css选择器选中，每个选择器都有一些css规则，这就是层叠。 CSS的处理原则是： 1）如果多个选择器定义的规则不发生冲突，则元素将应用所有选择器定义的样式。 2）如果多个选择器定义的规则发生了冲突，则CSS按选择器的特殊性(权重)让元素应用特殊性(权重)高的选择器定义的样式。 继承：所谓继承，就是父元素的规则也会适用于子元素。比如给body设置为color:Red;那么他内部的元素如果没有其他的规则设置，也都会变成红色。继承得来的规则没有特殊性。 多数边框类属性，比如Padding（补白），Margin（边界），背景和边框的属性都是不能继承的。(border属性是用来设置元素的边框的，它没有继承性) 块状、内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font-family、font-size、font-style、font-weight、text-decoration、text-transform. 块状元素可继承：text-indent和text-align。 列表元素可继承： list-style、list-style-type、list-style-position、list-style-image。 表格元素可继承：border-collapse。 css层叠性：​ 使用不同的选择符作用于同一个对象，每个选择符都有一些css声明/规则​ 如果规则没有发生冲突，这些样式都可以被执行​ 如果规则发生了冲突，根据选择符的权重/特殊性而定，执行权重高的选择符设置的样式​ 权重：​ 内联：1000​ id：100​ class 伪类：10​ 类型：1​ 群组：根据具体对象而定​ 包含：将使用的选择符相加=和​ 子：子结合符&gt; = 0 其他选择符相加=和​ 通配父，继承的样式 子结合符：权重为0​ css继承性： 子类可以继承父类的css样式​ 可以利用css继承，节省代码量，提高代码的可读性 5. 颜色(color)可以用以下方法来规定 CSS 中的颜色： 十六进制色 ：十六进制颜色是这样规定的：#RRGGBB，其中的 RR（红色）、GG（绿色）、BB（蓝色）十六进制整数规定了颜色的成分。所有值必须介于 0 与 FF 之间。举例说，#0000ff 值显示为蓝色，这是因为蓝色成分被设置为最高值（ff），而其他成分被设置为 0。 RGB 颜色：RGB 颜色值是这样规定的：rgb(red, green, blue)。每个参数 (red、green 以及 blue) 定义颜色的强度，可以是介于 0 与 255 之间的整数，或者是百分比值（从 0% 到 100%）。举例说，rgb(0,0,255) 值显示为蓝色，这是因为 blue 参数被设置为最高值（255），而其他被设置为 0。 RGBA 颜色：颜色值是 RGB 颜色值的扩展，带有一个 alpha 通道 - 它规定了对象的不透明度。 RGBA 颜色值是这样规定的：rgba(red, green, blue, alpha)。alpha 参数是介于 0.0（完全透明）与 1.0（完全不透明）的数字。 HSL 颜色：颜色值是这样规定的：hsl(hue, saturation, lightness)。 Hue 是色盘上的度数（从 0 到 360） - 0 (或 360) 是红色，120 是绿色，240 是蓝色。Saturation 是百分比值；0% 意味着灰色，而 100% 是全彩。Lightness 同样是百分比值；0% 是黑色，100% 是白色。 HSLA 颜色 ：颜色值是这样规定的：hsla(hue, saturation, lightness, alpha)，其中的 alpha 参数定义不透明度。alpha 参数是介于 0.0（完全透明）与 1.0（完全不透明）的数字。 预定义/跨浏览器颜色名 6. 浮动(float)123456789101112131415161718192021222324252627282930313233343536373839margin:0 auto/margin:auto;放置在一个标签上，可以使此标签在父元素中水平居中float:left/right/none A. 给元素添加浮动之后，会脱离正常文档流 B. 子元素浮动了，父元素在没有设置高度的情况下，会高度塌陷 C. 给元素添加浮动之后，元素会产生块级框，而不论本身是什么元素类型块状元素： 默认： width:auto - 与父元素同宽 height:auto - 与内容的高度相同 加浮动之后： width:auto - 与内容同宽 height:auto - 与内容的高度相同 设置具体的宽度和高度,设置的属性为多少，显示的大小就是多少 width:300px;height:300px 行内元素： 默认：不能设置宽度和高度，设置了显示无效 所以行内元素的显示大小，根据内容多少而定 加浮动之后：变成块状元素； width:auto; =不设宽度 A. 对于块状元素而言,浏览器自动计算，，会与父元素同宽， B. 对于块状元素而言，如果盒子浮动了，宽度与内容同宽 C. 如果给盒子设置具体的width:value，设置的多少，显示多宽2. 浮动对盒子宽度的影响： 标签的宽度为：width:auto; A. 对于块状元素而言,浏览器自动计算，，会与父元素同宽， B. 对于块状元素而言，如果盒子浮动了，宽度与内容同宽 盒子的宽度为：width:value； 如果给盒子设置具体的width:value，设置的多少，显示多宽 3. 浮动对盒子文档流的影响 添加了浮动的盒子，会脱离正常文档流； 4. 父元素的高度塌陷 父元素在没有设置具体高度的情况下，子元素全部浮动了，父元素的高度为0； 5. 浮动的图片应用：以往这个属性总应用于图像，使文本围绕在图像周围 6. 浮动元素会生成一个块级框，而不论它本身是何种元素。 块状元素，当width的属性值为auto/没写时，浏览器自动计算宽度，宽度是与父元素同宽 ​ 宽度：width:auto; ​ 高度：400px ​ 行内元素：不能设置宽度和高度，设置无效 7. background12345678910111213background-image:url(../img/mao.gif);background-repeat:no-repeat;background-position:100px 100px; 起始点时左上角 background-position:100% 100% 起始点时中心background-position:center;background-position:227px 99px; 背景颜色：background-color 背景图片：background-image 背景重复：background-repeat [rɪ'piːt] 重复 背景定位：background-position [pəˈzɪʃən] 位置 背景状态：background-attachment [ə'tætʃm(ə)nt] e ta xu ment background：color url repeat position attachment; ['kʌlə(r)] 单位 123456绝对长度单位、相对长度单位 绝对：cm mm in 等等 相对： ex - 字符x的高度 1ex=x的高度 em - 当前元素/父元素的文本大小 1em=font-size px - 设备上能显示的最小单位 css相对长度单位 8. 文本(font)[fɒnt]123456789101112131415161718192021222324252627282930313233343536373839404142434445font-size: &#123; none:[nʌn] norm:[nɔːm] px：设定固定值 %:基于父元素的一个百分比值&#125;font-family: &#123;//规定元素的字体系列 (1)此属性设置几个字体名称作为一种&quot;后备&quot;机制，如果浏览器不支持第一种字体，将尝试下一种字体。 (2) 如果字体系列的名称超过一个字，它必须用引号，如Font Family：&quot;宋体&quot;&quot;Times New Roman&quot;。 (3) 多个字体系列是用一个逗号分隔指明;&#125;font-weight:设置显示元素的文本中所用的字体加粗 &#123; [weɪt] 1-500=normal ,600-900=bold [bəʊld] bolder 更粗&#125;font-style: //设置文本倾斜&#123; italic [ɪ&apos;tælɪk] oblique [ə&apos;bliːk]&#125;text-indent&#123; %&#125;text-align:设置文本水平对齐&#123; [ə&apos;laɪn] left right center [ˈsentə(r)] justify 行内元素和文本是一样的 文本和行内元素都有作用对 块元素水平居中(0 auto)&#125;text-decoration: 文本修饰 [dekə&apos;reɪʃ(ə)n]&#123; // [dekə&apos;reɪʃ(ə)n] underline:文本下一条线 [ʌndə&apos;laɪn] overline: 文本上一条线 line-through: 穿过文本一条线 [θruː]&#125;text-transform：&#123; //设置文本大小写 [træns&apos;fɔrm] capitalize: [&apos;kæpɪtəlaɪz] 文本单词开头大写 uppercase: [&apos;ʌpə&apos;keɪs] 文本定义大小 lowercase: [ləʊə&apos;keɪs] 文本定义小写&#125;letter-spacing: &#123; //定义字符之间的间隔 + - 对汉字起作用&#125;word-spacing: &#123; //定义单词与单词之间的间隔z 只对单词有作用（字母和汉字无效）&#125;顺序: font-style | font-variant(小体大写字母) | font-weight | font-size / line-height | font-family font:[italic] [bold] 20px/&#123;100px] &apos;楷体&apos;; 9. 行高(line-hight)文本行的基线间的距离 123456789101112默认字体16px =&gt; lin-hight=21px;line-lenght:number 此数字会与当前字体尺寸相乘来设置行间距(2=2em,1em=元素文本大小 )%：基于当前字体尺寸的百分比(100%=当前尺寸)10px16px10px10px16px10px文本在行高内垂直居中应用户单行文本 控制文本的垂直居中 应用于多行文本控制多行文本的间距 10. 边框(border)1234border-color:设置边框颜色 red green blue;上 左右 下border-weight: bordrer-style: 设置边框类型 dotted(点状) dashed(虚线) solid(实线) double(双线)border- : 元素的所有边框设置宽度，或者单独地为各边边框设置宽度。 1234567891011121314outline****：（轮廓）**是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用，轮廓线不会占据空间，也不一定是矩形。outline-widthoutline-styleoutline-coloroutline:简写border跟outline的区别：1. border可应用于几乎所有有形的html元素，而outline是针对链接、表单控件和ImageMap等元素设计2. border占据空间，outline不占据空间 11. 列表(list)1234567list-style：none;去掉列表符号//定义列表符号的位置 [pəˈzɪʃən]list-style-position:inside（列表项目放置在文本以内，且环绕文本根据标记对齐） outside(默认)list-style-image: 设置图片作为列表符号list-type: 设置列表项标记的类型disc(实心圆)square(实心方块)decimal(数字)[dɪsk] [skweə] [&apos;desɪm(ə)l] 12.盒模型12345678910 占据的宽度：width+左右padding+左右border+左右margin 占据的高度：height+上下padding+上下border+上下margin 1. 盒模型的四个组成部分： content[kən&apos;tent] padding border marginpadding: 调整内容在盒子中的位置关系1. 需要添加到父元素上2. 不允许是负边距值3. 可以把内容撑大 4. 行内可以设置padding,但是显示有问题(上下显示有问题，左右没问题) 1234567891011121）. 将图片放在超链接中，在ie的低版本浏览器中，会自动解释出边框； 解决方法:img&#123;border:0/none&#125;2）. 将图片放在行内元素中，在行内元素没有设置高度的基础上，会将行内元素在图片自身高度的基础上，撑大3~5px A. img&#123;display:block&#125; B. div&#123;font-size:0 c. overflow:hidden; d.float:left;&#125;”。如果要实现图文混排，这种方法是很好的选择5. display:设置元素的显示类型 block：将元素设置为块状元素 图片将盒子撑大3~5px的原因：、 因为图片是行内元素，跟匿名文本之间的对齐方式是基线对齐，在文本基线的下行距 会 外边距(margin)12 1234567% 属性总结text-indent:参照父元素的宽度计算padding margin :基于父元素的宽度计算width height: 父元素的width,heightline-height：参照元素的font-sizebackground-size: 参照父元素 你 absolut:left/right/top/bottom 123456负值属性text-indent -负值background-postion: 负值marginabsolut:left/right/top/bottomz-index: 0=auto 123456简写属性background:border:font:list-style: type positionlist-style: url position 12345678910margin：auto - 浏览器计算 --具体valuepx/em/cm/mm %padding：不能为auto ，---具体valuepx/em/cm/mm % 1. 给子元素设置margin-top时，会影响到父元素一起向下移动； A. 给父元素后者子元素添加浮动 B. 给父元素加边框 C. overflow:hidden; 2. 两个盒子之间的margin区域是可以重叠的（没有浮动的情况下）； 3. 两个浮动盒子之间的margin区域是不重叠的； 4. margin可以设置负值，显示方向和正值完全相反； 5. 行内元素可以执行margin，但是上下显示 不正确，左右显示正确(padding一样) overflow12345678overflow: //主要应用设置溢出盒子的显示方式 visible:默认溢出，正常显示 [ˈvɪzəbl] hidden:溢出以后，隐藏 [&apos;hɪdn] scroll: 显示滚动条 [skrəʊl] auto: 如果溢出显示滚动条，如果不溢出就不显示滚动条3其他应用：A，给父元素添加overflow:hidden 可以解决高度塌陷B. 给父元素添加overflow:hidden 解决给子元素设置maring-top 影响父元素一起向上移动 123456789101112131415161718块级格式化上下文 BFC 其实归根结底，这里的浮动没有清除，只是因为overflow属性的值是hidden的时候会形成一个BFC，而BFC就是一个隔离的渲染区域，因此浮动造成的高崩塌会导致对外部布局的影响，为了消除这种不益的表现，计算高度的时候浮动元素也计算进去了。需要保证满足下面至少一条就会触发BFC：根元素body；设置了float值不为none的元素；设置了overflow属性不为visible的元素；设置了属性position不为relative和static的元素；设置了display的值为flex、table-cell、table-caption和inline-block中的任何一个的元素。可以看出来，就是一个比较独立的块，因为是一个独立的环境，在开发时候适度使用会有效降低开发和维护难度。大致可以归纳为三个方面：独立性、垂直分布规则和水平分布规则。独立性：BFC是页面上一个隔离的容器，和外面的关系是不会互相影响，对浮动而言也是，不会和浮动元素发生重叠，高也和上面提到的一样不会崩塌；垂直分布规则：BFC的内部里面的一个个盒子在垂直方向一个接着一个排放，位置由margin决定，两个相邻的盒子margin会发生重叠；水平分布规则：BFC里面的盒子的左外边缘和包含块的左边相接触，简单的理解就是水平方向不会发生margin重叠。 123456要实现溢出时产生省略号的效果还需定义： 1）、容器宽度：width：value；2）、强制文本在一行内显示:white-space：nowrap;3）、溢出内容为隐藏：overflow：hidden；4）、溢出文本显示省略号：text-overflow：ellipsis; [ɪ&apos;lɪpsɪs] 1234567891011121314151617181920212223 1. display: none:此标签在浏览器中不显示 block：此标签显示为块状元素-div p ul ol dl dt dd h1 form; inline:此标签显示为行内元素-a span b strong i em img br sup sub inline-block:此标签显示为行内块元素 - input; 行内 list-item:此标签显示为列表项标签 - li table:此标签显示为块级表格标签 - table 元素类型： 块状级元素：display:block list-item table 行内级元素：display:inline inline-block inline-table;2. 块状元素的特征： A。 可以设置宽度和高度 B。 自占一行 C。 作为容器使用，作为盒子使用，可以正确解释4盒模型中的属性； D。 给盒子添加浮动之后，盒子在没有设置宽度和高度的情况下，在没有内容的情况下，宽度，高度为0；3. 行内元素的特征： A。不能设置宽度和高度 B。可以和其他行内元素在一行内显示 C。行内元素也符合盒模型的特征，也能执行盒模型中的规则，但是margin，padding，border的上下显示不正确，左右显示正常； D。给行内元素添加浮动之后，会生成块级框，变成块状元素 123451.行内元素2.行内元素1ver-align练习置换元素和飞置换元素小米商城 123456行内元素垂直方向的对齐方式：默认基线对齐1.给元素添加float 摆脱基线对齐 基线(小写字母x ,s,a 的下断沿的先)2.行内元素在开发工具书写时，如果进行换行和空格 解决：A. 写在一行，不进行换行 B. 给所有的行内元素添加float c. 给行内元素的父元素设置 font-size: 0; 当时行内元素有继承 font-size:0; 影响元素内的文本大小为0； 解决：给行内元素再设置font-size vertical-align12345678910vertical-align 设置元素的垂直的对齐方式 baseline: 默认 元素放在父元素的基线上(父元素的基线就是文本内容的基线) top bottom middle 垂直居中对齐 sub: 垂直对齐文本的下标 super: 在没有边距没区别 %：当前line-hight(开发不推荐) 允许负值 正值：向上移动当前行高的大小 负值：向下移动当前行高的大小 置换元素 定位12345postion: absolute 绝对定位 相当于static 定位以为的第一个父元素定位body--position:static div没设就是statichmlt---是绝对定为诶元素最大的参照物-默认fixed","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"优雅的使用 Subline Text3","slug":"sbulime","date":"2018-12-25T11:44:56.643Z","updated":"2019-03-19T03:41:01.275Z","comments":true,"path":"2018/12/25/sbulime/","link":"","permalink":"http://yoursite.com/2018/12/25/sbulime/","excerpt":"","text":"1.插件下载安装方法快捷键ctrl + shift + p, 打开sublime命令工具，输入 Install Package 2.插件1.格式化代码：html/css/js Prettify 格式化代码快捷键 Ctrl + Shift + H 2.vue语法高亮： vue-syntax-highlight","categories":[{"name":"IDE工具","slug":"IDE工具","permalink":"http://yoursite.com/categories/IDE工具/"}],"tags":[{"name":"sublime，快捷键","slug":"sublime，快捷键","permalink":"http://yoursite.com/tags/sublime，快捷键/"}]},{"title":"Hexo + github 搭建个人博客","slug":"Hexo + github 搭建个人博客","date":"2018-12-25T07:56:57.878Z","updated":"2019-03-19T05:53:38.873Z","comments":true,"path":"2018/12/25/Hexo + github 搭建个人博客/","link":"","permalink":"http://yoursite.com/2018/12/25/Hexo + github 搭建个人博客/","excerpt":"","text":"1.博客维护1.发布文章在站点文件夹中打开 git bash，输入如下命令部署和发布文章: 1$ hexo g -d 建议：在使用 hexo g 部署之后，可以先使用 hexo s 运行本地站点，然后在浏览器输入地址 http://lacolhost:4000/ 查看运行结果，检查无误后再使用 hexo d 发布 2.新建博客时添加对应的图片文件夹将 站点配置文件 中的 post_asset_folde 选项的值设置为 true 在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件 这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可 例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 添加图片 3.模板设置当我们使用命令 hexo new &quot;title&quot; 创建文章时，Hexo 会根据 /scaffolds/post.md 对新文章进行初始化 换言之，/scaffolds/post.md 就是新文章的 模板，所以我们可以修改它来适应自己的写作习惯 在每篇利用 Hexo 创建的文章的开头，都会有对文章进行说明的文字，叫做 文章头部 文章的头部除了可以设置文章标题、发布日期等基础信息外，还可以为文章添加标签、分类等 一个简单的示例如下： 1234title: Titledate: YYYY-MM-DD HH:MM:SStags: [tag1, tag2, ...]categories: category 注意：属性和属性值之间必须有一个空格，否则会解析错误 2.搭建博客1.搭建github博客1.github新建博客文件，库名要所有者名字一样，如：meijuna.github.io 的格式 2.Settings =&gt; 选择一个主题保存 就可以访问 meijuna.github.io 了 2.Hexo搭建本地博客hexo命令 hexo s(server) –&gt; 启动本地服务 hexo clean –&gt; 清除缓存 hexo g (generate) –&gt; 创建网页 hexo d (deploy) –&gt; 同步到github 1.安装node.js + git 以Windows环境安装node.js为例，首先登录node.js官网，选择适合自己的版本进行下载，然后进行安装。 登录git官网选择版本进行下载，基本一路next下去即可轻松完成安装。 2.首先在本地磁盘中建立一个Hexo文件夹用于存储本地文件(做本地文件保存以及测试使用) 3.下载Hexo: 1npm install hexo-cli -g 4.初始化博客空间，生成博客运作所需要的文件，接下来安装依赖包 1npm install 5.同步Github,允许公共访问 1.首先找到我们的博客仓库，并拷贝仓库地址：git clone 主题仓库地址 放到 themes 文件夹下 2.打开_config.yml 文件配置： 1234deploy: type: git repo: https://github.com/meijuna/meijuna.github.io branch: master 3.最后执行控制台命令： 123npm install hexo-deployer-git —save //安装部署插件hexo d //部署到github 就用 meijuna.github.io 访问博客了 2.Hexo 的主题美化1.到 Hexo主题官网 下载主题放到 themes 文件夹 2.配置根目录的 _config.yml 中： 1theme: pure //选择下载主体文件的名字 3.hexo clean -&gt; hexo g -d 看效果 4.具体主题美化看下载的主题文档 3.在Hexo博客上添加可爱的Live 2D模型首先，安装npm包： 1npm install --save hexo-helper-live2d 然后在hexo的根目录配置文件_config.yml中添加如下配置，详细配置可以参考文档： 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-koharu display: position: right width: 150 height: 300 mobile: show: true 然后下载模型，模型名称可以到这里参考，一些模型的预览可以在这里。 1npm install live2d-widget-model-koharu 下载完之后，在 Hexo 根目录中新建文件夹 live2d_models，然后在node_modules文件夹中找到刚刚下载的live2d模型，将其复制到 live2d_models 中，然后编辑_config.yml配置文件中的model.use项，将其修改为live2d_models文件夹中的模型文件夹名称。 一切就绪之后，用hexo server命令启动服务器，大功告成！ 4.阿里云解析域名1.阿里云购买域名 解析 -&gt; 添加记录 -&gt; A 类型 -&gt; www -&gt; 默认 -&gt; ping meijuna.github.io 地址的值 -&gt;ttl 10 3.在根目录下的 source 文件夹 创建 CNAME 文件 ，内容为 www.meijuna.top 5.其他1.hexo中添加图片的方法1.下载插件 1npm install hexo-asset-image --save // hexo n &quot;文件&quot; 自动生成相同文件名的文件夹存放图片 2.设置站点配置_config.yml 1post_asset_folder: true ###","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Live 2D模型","slug":"Live-2D模型","permalink":"http://yoursite.com/tags/Live-2D模型/"},{"name":"博客，阿里云","slug":"博客，阿里云","permalink":"http://yoursite.com/tags/博客，阿里云/"}]},{"title":"Mackdown 基本语法","slug":"Mackdown语法","date":"2018-12-24T01:35:48.462Z","updated":"2019-03-19T06:23:15.120Z","comments":true,"path":"2018/12/24/Mackdown语法/","link":"","permalink":"http://yoursite.com/2018/12/24/Mackdown语法/","excerpt":"","text":"1、Markdown 简介但是，在我们正式写下第一个文字前，我们需要了解一下究竟什么是 Markdown？ Markdown 是一种可以使用普通文本编辑器编写的 标记语言，通过简单的 标记语法，它可以使普通文本内容具有一定的格式 基于 Markdown 语法的简洁性，它已经成为目前世界上最流行的用于书写博客的语言 2、Markdown 语法2、Markdown 语法在编写 Markdown 时，博主强烈的推荐给大家一款简洁易用的 Markdown 编辑器 —— Typora 按照官方的说法就是 简单而强大，它不仅支持原生的语法，也支持对应的快捷键，更重要的是它还可以 实时预览 这里附上 Typora 的下载地址：https://www.typora.io/，有兴趣的朋友可以下载来试试 好，下面开始进入正题，介绍一些常用的 Markdown 语法 （1）标题Markdown 语法： 1234567891011# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 Typora 快捷键： Ctrl+1：一级标题 Ctrl+2：二级标题 Ctrl+3：三级标题 Ctrl+4：四级标题 Ctrl+5：五级标题 Ctrl+6 ：六级标题 Ctrl+0：段落 （2）粗体、斜体、删除线和下划线Markdown 语法： 1234*斜体***粗体*****加粗斜体***~~删除线~~ Typora 快捷键： Ctrl+I：斜体 Ctrl+B：粗体 Ctrl+U：下划线 Alt+Shift+5：删除线 （3）引用块Markdown 语法： 12文字引用：&gt;Typora 快捷键： Ctrl+Shift+Q （4）代块Markdown 语法： 行内代码： 1234567行内代码多行代码：多行代码多行代码多行代码 Typora 快捷键： 行内代码：Ctrl+Shift+` 多行代码：Ctrl+Shift+K （5）公式块Markdown 语法： 123$$数学公式$$ Typora 快捷键： Ctrl+Shift+M （6）分割线Markdown 语法： 12345方法一：---方法二：+++方法三：*** （7）列表Markdown 语法： 12345671. 有序列表项* 无序列表项+ 无序列表项- 无序列表项 Typora 快捷键： 有序列表项：Ctrl+Shift+[ 无序列表项：Ctrl+Shift+] （8）表格Markdown 语法： 1234表头1|表头2-|-|-内容11|内容12内容21|内容22 表头1 表头2 内容11 内容12 内容21 内容22 Typora 快捷键： Ctrl+T （9）超链接Markdown语法： 12345方法一：[链接文字](链接地址 &quot;链接描述&quot;)例如：[示例链接](https://www.example.com/ &quot;示例链接&quot;)方法二：&lt;链接地址&gt;例如：&lt;https://www.example.com/&gt; Typora快捷键： Ctrl+K （10）图片Markdown语法： 12![图片文字](图片地址 &quot;图片描述&quot;)例如：![示例图片](https://www.example.com/example.PNG &quot;示例图片&quot;) Typora快捷键： Ctrl+Shift+I 说明：在 Hexo中 插入图片时，请按照以下的步骤进行设置 将 站点配置文件 中的 post_asset_folde 选项的值设置为 true 在站点文件夹中打开 git bash，输入命令 npm install hexo-asset-image –save 安装插件 这样，当使用 hexo new title 创建文章时，将同时在 source/_post 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可 例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 ![示例图片](title/example.PNG &quot;示例图片&quot;) 添加图片","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Mackdown","slug":"Mackdown","permalink":"http://yoursite.com/tags/Mackdown/"}]},{"title":"我的第一篇博客","slug":"我的第一条博客","date":"2018-12-21T15:03:47.376Z","updated":"2019-03-19T05:59:24.902Z","comments":true,"path":"2018/12/21/我的第一条博客/","link":"","permalink":"http://yoursite.com/2018/12/21/我的第一条博客/","excerpt":"","text":"Hello, 欢迎来到我的博客，以后我会不定时的发布博客，记录生活！","categories":[{"name":"测试","slug":"测试","permalink":"http://yoursite.com/categories/测试/"}],"tags":[]}]}